[{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"An introduction to the rSPDE package","text":"vignette provide brief introduction rSPDE package. main approach constructing rational approximations covariance-based rational SPDE approach (Xiong, Simas, Bolin 2022)(https://arxiv.org/abs/2209.04670). package contains three main “families” functions implement approach: interface R-INLA; interface inlabru; stand-alone implementation approach. illustrate different functions, begin using package generate simple data set, analyzed using different approaches. details family functions given following additional vignettes: R-INLA implementation rational SPDE approach inlabru implementation rational SPDE approach Rational approximation rSPDE package rSPDE package also separate group functions performing operator-based rational approximations introduced (Bolin Kirchner 2020)(https://www.tandfonline.com/doi/full/10.1080/10618600.2019.1665537). especially useful performing rational approximations fractional SPDE models non-Gaussian noise. example approximation suitable one -called type-G Lévy noises. refer reader (Wallin Bolin 2015)(https://onlinelibrary.wiley.com/doi/full/10.1111/sjos.12141), (Bolin 2013)(https://onlinelibrary.wiley.com/doi/abs/10.1111/sjos.12046) (Asar et al. 2020)(https://rss.onlinelibrary.wiley.com/doi/pdf/10.1111/rssc.12405) examples models driven type-G Lévy noises. also refer reader ngme package one can fit models. explore functions performing operator-based rational approximation vignette: Operator-based rational approximation rSPDE package","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"a-toy-data-set","dir":"Articles","previous_headings":"","what":"A toy data set","title":"An introduction to the rSPDE package","text":"begin generating toy data set. illustration, simulate data set two-dimensional spatial domain. end, need construct mesh domain interest compute matrices needed define operator. use R-INLA package create mesh obtain matrices interest. begin defining mesh \\([0,1]\\times [0, 1]\\):  now use matern.operators() function construct rational SPDE approximation order \\(m=2\\) Gaussian random field Matérn covariance function \\([0,1]\\times [0, 1]\\). choose \\(\\nu=0.5\\) corresponds exponential covariance. also set \\(\\sigma=1\\) range \\(0.2\\). can now use simulate function simulate realization field \\(u\\): Let us now consider simple Gaussian linear model spatial field \\(u(\\mathbf{s})\\) observed \\(m\\) locations, \\(\\{\\mathbf{s}_1 , \\ldots , \\mathbf{s}_m \\}\\) Gaussian measurement noise. \\(= 1,\\ldots,m,\\) \\[ \\begin{align}  y_i &= u(\\mathbf{s}_i)+\\varepsilon_i\\\\ \\end{align}, \\] \\(\\varepsilon_1,\\ldots,\\varepsilon_{m}\\) iid normally distributed mean 0 standard deviation 0.1. generate data set y model, first draw observation locations random domain use R-INLA function inla.spde.make.() construct observation matrix can used evaluate simulated field \\(u\\) observation locations. simply add measurment noise. generated data can seen following image.  simulated random field shown following figure.","code":"library(INLA) n_loc <- 2000 loc_2d_mesh <- matrix(runif(n_loc * 2), n_loc, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   max.edge = c(0.1, 0.5) ) plot(mesh_2d, main = \"\") library(rSPDE) sigma <- 1 range <- 0.2 nu <- 0.5 kappa <- sqrt(8 * nu) / range op <- matern.operators(   mesh = mesh_2d, nu = nu,   kappa = kappa, sigma = sigma, m = 2 ) u <- simulate(op) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 y <- A %*% u + rnorm(n_loc) * sigma.e library(ggplot2) library(gridExtra) df <- data.frame(x1 = as.double(loc_2d_mesh[, 1]),    x2 = as.double(loc_2d_mesh[, 2]), y = as.double(y)) ggplot(df, aes(x = x1, y = x2, col = y)) +   geom_point() +   scale_color_gradient(low = \"yellow\", high = \"red\") proj <- inla.mesh.projector(mesh_2d, dims = c(100, 100)) field <- inla.mesh.project(proj, field = as.vector(u)) grd <- expand.grid(1:100, 1:100) / 100 field.df <- cbind(grd, as.vector(field)) colnames(field.df) <- c(\"x1\", \"x2\", \"y\") ggplot(field.df, aes(x = x1, y = x2, fill = y)) +   geom_raster() +   scale_fill_gradient(low = \"yellow\", high = \"red\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"fitting-the-model-with-r-inla-implementation-of-the-rational-spde-approach","dir":"Articles","previous_headings":"","what":"Fitting the model with R-INLA implementation of the rational SPDE approach","title":"An introduction to the rSPDE package","text":"now fit model toy data set using R-INLA implementation rational SPDE approach. details implementation can found R-INLA implementation rational SPDE approach. begin creating \\(\\) matrix, index, inla.stack object. now create model object. need set upper bound smoothness parameter \\(\\nu\\). default value \\(4\\). increase upper bound \\(\\nu\\) also increase computational cost, decrease upper bound also decrease computatoinal cost. example set nu_upper_bound=2. See R-INLA implementation rational SPDE approach details. Finally, create formula fit model data: can get summary fit: get summary fit random field , can following:","code":"Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d)  st.dat <- inla.stack(   data = list(y = as.vector(y)),   A = Abar,   effects = mesh.index ) rspde_model <- rspde.matern(   mesh = mesh_2d,   nu_upper_bound = 2 ) f <-   y ~ -1 + f(field, model = rspde_model) rspde_fit <-   inla(f,     data = inla.stack.data(st.dat),     family = \"gaussian\",     control.predictor =       list(A = inla.stack.A(st.dat)),        inla.mode = \"experimental\"   ) summary(rspde_fit) #>  #> Call: #>    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  #>    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  #>    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  #>    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  #>    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  #>    = control.compute, \", \" control.predictor = control.predictor,  #>    control.family = control.family, \", \" control.inla = control.inla,  #>    control.fixed = control.fixed, \", \" control.mode = control.mode,  #>    control.expert = control.expert, \", \" control.hazard = control.hazard,  #>    control.lincomb = control.lincomb, \", \" control.update =  #>    control.update, control.lp.scale = control.lp.scale, \", \"  #>    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  #>    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  #>    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  #>    working.directory = working.directory, \", \" silent = silent, inla.mode  #>    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  #>    .parent.frame)\")  #> Time used: #>     Pre = 4, Running = 7.25, Post = 0.132, Total = 11.4  #> Random effects: #>   Name     Model #>     field RGeneric2 #>  #> Model hyperparameters: #>                                            mean    sd 0.025quant 0.5quant #> Precision for the Gaussian observations 101.719 3.388     95.092  101.708 #> Theta1 for field                         -4.049 0.556     -5.617   -4.213 #> Theta2 for field                          2.738 0.134      2.644    2.775 #> Theta3 for field                          0.079 0.296     -0.118    0.167 #>                                         0.975quant   mode #> Precision for the Gaussian observations    108.445 101.76 #> Theta1 for field                            -3.679  -3.60 #> Theta2 for field                             3.112   2.63 #> Theta3 for field                             0.916  -0.16 #>  #> Marginal log-Likelihood:  1031.81  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result_fit) #>             mean         sd  0.025quant   0.5quant 0.975quant       mode #> tau    0.0198626 0.00842679  0.00449581  0.0209342  0.0335036  0.0264883 #> kappa 15.5776000 2.24000000 13.17470000 14.8229000 21.4102000 13.8193000 #> nu     1.0365300 0.14223300  0.86688100  0.9914340  1.3820800  0.9196960 tau <- op$tau result_df <- data.frame(   parameter = c(\"tau\", \"kappa\", \"nu\"),   true = c(tau, kappa, nu), mean = c(     result_fit$summary.tau$mean,     result_fit$summary.kappa$mean,     result_fit$summary.nu$mean   ),   mode = c(     result_fit$summary.tau$mode,     result_fit$summary.kappa$mode,     result_fit$summary.nu$mode   ) ) print(result_df) #>   parameter       true        mean        mode #> 1       tau  0.1261566  0.01986256  0.02648834 #> 2     kappa 10.0000000 15.57756567 13.81929233 #> 3        nu  0.5000000  1.03653407  0.91969625"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"kringing-with-r-inla-implementation-of-the-rational-spde-approach","dir":"Articles","previous_headings":"","what":"Kringing with R-INLA implementation of the rational SPDE approach","title":"An introduction to the rSPDE package","text":"Let us now obtain predictions (.e., kriging) latent field dense grid region. begin creating grid locations want compute predictions. end, can use rspde.mesh.projector() function. function arguments function inla.mesh.projector() difference rSPDE version also argument nu argument rspde_order. Thus, proceed fashion R-INLA’s standard SPDE implementation: lattice contains 100 × 100 locations (default) shown following figure:  Let us now calculate predictions jointly estimation. end, first, begin linking prediction coordinates mesh nodes \\(\\) matrix now make stack prediction locations. data prediction locations, set y= NA. join stack estimation stack. joint estimation takes , therefore turn computation certain things interested , marginals random effect. also use simplified integration strategy (actually using posterior mode hyper-parameters) command control.inla = list(int.strategy = \"eb\"), .e. empirical Bayes: extract indices prediction nodes extract mean standard deviation response: Finally, plot results. First mean:  , marginal standard deviations:","code":"projgrid <- rspde.mesh.projector(mesh_2d,   xlim = c(0, 1),   ylim = c(0, 1) ) coord.prd <- projgrid$lattice$loc plot(coord.prd, type = \"p\", cex = 0.1) A.prd <- projgrid$proj$A ef.prd <- list(c(mesh.index)) st.prd <- inla.stack(   data = list(y = NA),   A = list(A.prd), tag = \"prd\",   effects = ef.prd ) st.all <- inla.stack(st.dat, st.prd) rspde_fitprd <- inla(f,   family = \"Gaussian\",   data = inla.stack.data(st.all),   control.predictor = list(     A = inla.stack.A(st.all),     compute = TRUE, link = 1   ),   control.compute = list(     return.marginals = FALSE,     return.marginals.predictor = FALSE   ),   control.inla = list(int.strategy = \"eb\") ) id.prd <- inla.stack.index(st.all, \"prd\")$data m.prd <- matrix(rspde_fitprd$summary.fitted.values$mean[id.prd], 100, 100) sd.prd <- matrix(rspde_fitprd$summary.fitted.values$sd[id.prd], 100, 100) grd <- expand.grid(1:100, 1:100) / 100 field.pred.df <- cbind(grd, as.vector(m.prd)) colnames(field.pred.df) <- c(\"x1\", \"x2\", \"y\") ggplot(field.pred.df, aes(x = x1, y = x2, fill = y)) +   geom_raster() +   scale_fill_gradient(low = \"yellow\", high = \"red\") field.pred.sd.df <- cbind(grd, as.vector(sd.prd)) colnames(field.pred.sd.df) <- c(\"x1\", \"x2\", \"y\") ggplot(field.pred.sd.df, aes(x = x1, y = x2, fill = y)) +   geom_raster()"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"fitting-the-model-with-inlabru-implementation-of-the-rational-spde-approach","dir":"Articles","previous_headings":"","what":"Fitting the model with inlabru implementation of the rational SPDE approach","title":"An introduction to the rSPDE package","text":"now fit model toy data set using inlabru implementation rational SPDE approach. details implementation can found inlabru implementation rational SPDE approach. begin loading inlabru package: creation model object R-INLA’s case: advantage inlabru need form stack manually, can simply collect required data data.frame(): Finally, create component fit: Note creation model component needs include mapper argument version inlabru version 2.5.3 used, whereas mapper argument required later versions inlabru. stage, can get summary fit just R-INLA case: also obtain summary field :","code":"library(inlabru) rspde_model <- rspde.matern(   mesh = mesh_2d,   nu_upper_bound = 2 ) toy_df <- data.frame(coord1 = loc_2d_mesh[,1],                      coord2 = loc_2d_mesh[,2],                      y = as.vector(y)) coordinates(toy_df) <- c(\"coord1\", \"coord2\") # For inlabru 2.5.3.9002 or above: cmp <-   y ~ -1 + field(coordinates, model = rspde_model) # For inlabru 2.5.3: cmp <-   y ~ -1 + field(coordinates, model = rspde_model,             mapper = bru_mapper(rspde_model)) rspde_bru_fit <-   bru(cmp,       data=toy_df,     options=list(     family = \"gaussian\",     inla.mode = \"experimental\")   ) summary(rspde_bru_fit) #> inlabru version: 2.5.3 #> INLA version: 22.09.15 #> Components: #>   field: Model types main='rgeneric', group='exchangeable', replicate='iid' #> Likelihoods: #>   Family: 'gaussian' #>     Data class: 'SpatialPointsDataFrame' #>     Predictor: y ~ . #> Time used: #>     Pre = 3.98, Running = 8.1, Post = 1.15, Total = 13.2  #> Random effects: #>   Name     Model #>     field RGeneric2 #>  #> Model hyperparameters: #>                                            mean    sd 0.025quant 0.5quant #> Precision for the Gaussian observations 101.719 3.388     95.092  101.707 #> Theta1 for field                         -4.048 0.555     -5.617   -4.213 #> Theta2 for field                          2.738 0.134      2.644    2.775 #> Theta3 for field                          0.079 0.296     -0.118    0.167 #>                                         0.975quant   mode #> Precision for the Gaussian observations    108.444 101.76 #> Theta1 for field                            -3.679  -3.60 #> Theta2 for field                             3.112   2.63 #> Theta3 for field                             0.916  -0.16 #>  #> Deviance Information Criterion (DIC) ...............: -3277.18 #> Deviance Information Criterion (DIC, saturated) ....: -2034.92 #> Effective number of parameters .....................: 291.42 #>  #> Watanabe-Akaike information criterion (WAIC) ...: -3268.18 #> Effective number of parameters .................: 261.13 #>  #> Marginal log-Likelihood:  1031.81  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit <- rspde.result(rspde_bru_fit, \"field\", rspde_model) summary(result_fit) #>             mean         sd  0.025quant   0.5quant 0.975quant       mode #> tau    0.0198656 0.00842394  0.00449887  0.0209419   0.033496  0.0264794 #> kappa 15.5763000 2.23894000 13.17510000 14.8214000  21.406500 13.8191000 #> nu     1.0364700 0.14217700  0.86695400  0.9913360   1.381930  0.9197910 tau <- op$tau result_df <- data.frame(   parameter = c(\"tau\", \"kappa\", \"nu\"),   true = c(tau, kappa, nu), mean = c(     result_fit$summary.tau$mean,     result_fit$summary.kappa$mean,     result_fit$summary.nu$mean   ),   mode = c(     result_fit$summary.tau$mode,     result_fit$summary.kappa$mode,     result_fit$summary.nu$mode   ) ) print(result_df) #>   parameter       true        mean        mode #> 1       tau  0.1261566  0.01986559  0.02647943 #> 2     kappa 10.0000000 15.57628967 13.81910692 #> 3        nu  0.5000000  1.03646506  0.91979086"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"kringing-with-inlabru-implementation-of-the-rational-spde-approach","dir":"Articles","previous_headings":"","what":"Kringing with inlabru implementation of the rational SPDE approach","title":"An introduction to the rSPDE package","text":"Let us now obtain predictions (.e., kriging) latent field dense grid region. begin creating grid locations want evaluate predictions. begin creating regular grid extract coorinates: Let us now compute predictions. advantage inlabru can fitting model data: following figure shows mean predictions:  following figure shows marginal standard deviations predictions:  alternative simple approach use pixel() function:","code":"grd <- expand.grid(1:100, 1:100) / 100 pred_coords <- data.frame(x1 = grd[,1],                           x2 = grd[,2]) coordinates(pred_coords) <- c(\"x1\", \"x2\") field_pred <- predict(rspde_bru_fit, pred_coords, ~field) field_pred_df <- field_pred@data field_pred_df <- cbind(field_pred_df, field_pred@coords) p <- ggplot(field_pred_df, aes(x = x1, y = x2, fill = mean)) +   geom_raster() +   scale_fill_gradient(low = \"yellow\", high = \"red\") p p <- ggplot(field_pred_df, aes(x = x1, y = x2, fill = sd)) +   geom_raster() p pxl <- pixels(mesh_2d)  field_pred <- predict(rspde_bru_fit, pxl, ~field)  ggplot() + gg(field_pred) +   scale_fill_gradient(low = \"yellow\", high = \"red\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"fitting-the-model-with-rspde","dir":"Articles","previous_headings":"","what":"Fitting the model with rSPDE","title":"An introduction to the rSPDE package","text":"now fit model toy data set without using R-INLA inlabru. end use rational approximation functions rSPDE package. details can found vignette Rational approximation rSPDE package. use function rSPDE.construct.matern.loglike() define likelihood. function object-based, sense obtains several quantities needs rSPDE model object. Notice already created rSPDE model object simulate data. , , use model object. Recall rSPDE model object created op. also already \\(\\) matrix connecting observation locations mesh, simply called . simplify parameter estimation, rSPDE.construct.matern.loglike() function factory returns negative log-likelihood function, parametrized using logarithm parameter avoid constrained optimization: can now estimate parameter using optimParallel() (one can also use optim()):","code":"mlik <- rSPDE.construct.matern.loglike(object = op, Y=y, A=A) library(optimParallel) # Preparing the parallel  # Checking if we have a limit to the number of cores chk <- Sys.getenv(\"_R_CHECK_LIMIT_CORES_\", \"\") if (nzchar(chk) && chk == \"TRUE\") {   n_cores <- 2L } else {   n_cores <- parallel::detectCores() - 1 }  cl <- makeCluster(n_cores) setDefaultCluster(cl = cl)  # Exporting the needed objects to the parallel cores # This step is not necessary for the regular optim parallel::clusterExport(cl, \"op\") parallel::clusterExport(cl, \"y\") parallel::clusterExport(cl, \"A\")  # Fitting the model theta0 <- c(get.inital.values.rSPDE(mesh = mesh_2d),   log(0.1 * sqrt(var(as.vector(y))))  )  start_time <- Sys.time() pars <- optimParallel(theta0, mlik) end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(   sigma = c(sigma, exp(pars$par[1])),   kappa = c(kappa, exp(pars$par[2])),   nu = c(nu, exp(pars$par[3])),   sigma.e = c(sigma.e, exp(pars$par[4])),   row.names = c(\"True\", \"Estimate\") ) print(results) #>             sigma     kappa        nu    sigma.e #> True     1.000000 10.000000 0.5000000 0.10000000 #> Estimate 1.014695  9.377185 0.5480289 0.09913223 # Total time print(total_time) #> Time difference of 13.19134 secs"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"kringing-with-rspde","dir":"Articles","previous_headings":"","what":"Kringing with rSPDE","title":"An introduction to the rSPDE package","text":"now kringing dense grid R-INLA-based rational SPDE approach, now using rSPDE functions. end use predict method rSPDE model object. Observe need \\(\\) matrix connecting mesh prediction locations. Let us now create \\(\\) matrix prediction locations used previous case (using R-INLA implementation): now use predict() method rSPDE model object argument compute.variances set TRUE can plot standard deviations. Let us also update values rSPDE model object fitted ones, also save estimated value sigma.e. Finally, plot results. First mean:  , standard deviations:","code":"predgrid <- inla.mesh.projector(mesh_2d,   xlim = c(0, 1),   ylim = c(0, 1) ) A.prd2 <- predgrid$proj$A sigma.e.est <- exp(pars$par[4]) op.prd <- update(op,   user_sigma = exp(pars$par[1]),   user_kappa = exp(pars$par[2]),   user_nu = exp(pars$par[3]) )  pred.rspde <- predict(op.prd,   A = A, Aprd = A.prd2, Y = y,   sigma.e = sigma.e.est,   compute.variances = TRUE ) field.pred2.df <- cbind(grd, as.vector(pred.rspde$mean)) colnames(field.pred2.df) <- c(\"x1\", \"x2\", \"y\") ggplot(field.pred2.df, aes(x = x1, y = x2, fill = y)) +   geom_raster() +   scale_fill_gradient(low = \"yellow\", high = \"red\") field.pred2.sd.df <- cbind(grd, as.vector(sqrt(pred.rspde$variance))) colnames(field.pred2.sd.df) <- c(\"x1\", \"x2\", \"y\") ggplot(field.pred2.sd.df, aes(x = x1, y = x2, fill = y)) +   geom_raster()"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Operator-based rational approximation","text":"Several popular Gaussian random field models can represented solutions stochastic partial differential equations (SPDEs) form \\[ L^{\\beta} (\\tau u) = \\mathcal{W}. \\] \\(\\mathcal{W}\\) Gaussian white noise, \\(L\\) second-order differential operator, fractional power \\(\\beta>0\\) determines smoothness \\(u\\), \\(\\tau>0\\) scales variance \\(u\\). \\(2\\beta\\) integer domain \\(\\mathcal{D}\\) model defined bounded, \\(u\\) can approximated Gaussian Markov random field (GMRF) \\(\\boldsymbol{\\mathrm{u}}\\) via finite element method (FEM) SPDE. Specifically, approximation can written \\[ u_h(s) = \\sum_{=1}^n u_i \\varphi_i(s). \\] \\(\\{\\varphi_i\\}\\) piecewise linear basis functions defined triangulation \\(\\mathcal{D}\\) vector weights \\(\\boldsymbol{\\mathrm{u}} = (u_1,\\ldots,u_n)^T\\) normally distributed, \\(N(\\boldsymbol{\\mathrm{u}},\\tilde{\\boldsymbol{\\mathrm{Q}}}^{-1})\\), \\(\\tilde{\\boldsymbol{\\mathrm{Q}}}\\) sparse. See (Lindgren, Rue, Lindström 2011)(https://rss.onlinelibrary.wiley.com/doi/full/10.1111/j.1467-9868.2011.00777.x) details. vignette focus operator-based rational approximation. approach, introduced (Bolin Kirchner 2020)(https://www.tandfonline.com/doi/full/10.1080/10618600.2019.1665537), results approximation original SPDE form \\(P_l x = P_r \\mathcal{W}\\), \\(P_l\\) \\(P_r\\) non-fractional operators defined terms polynomials \\(p_l\\) \\(p_r\\). order \\(p_r\\) given \\(m\\) order \\(p_l\\) \\(m + m_{\\beta}\\) \\(m_{\\beta}\\) integer part \\(\\beta\\) \\(\\beta>1\\) \\(m_{\\beta} = 1\\) otherwise. combination rational approximation operator FEM discretization yields approximation \\(u_h\\) \\(u\\) basis expansion form . difference non-fractional case vector stochastic weights now \\(\\boldsymbol{\\mathrm{u}} \\sim N(\\boldsymbol{\\mathrm{0}},\\boldsymbol{\\mathrm{P}}_r\\boldsymbol{\\mathrm{Q}}^{-1}\\boldsymbol{\\mathrm{P}}_r^T)\\) \\(\\boldsymbol{\\mathrm{Q}}\\) \\(\\boldsymbol{\\mathrm{P}}_r\\) sparse matrices. Alternatively, \\(\\boldsymbol{\\mathrm{u}}\\) can represented \\(\\boldsymbol{\\mathrm{u}} = \\boldsymbol{\\mathrm{P}}_r \\boldsymbol{\\mathrm{x}}\\) \\(\\boldsymbol{\\mathrm{x}} \\sim N(\\boldsymbol{\\mathrm{0}},\\boldsymbol{\\mathrm{Q}}^{-1})\\), means discrete approximation latent GMRF. can used computationally efficient inference simulation. See Bolin Kirchner (2020) details.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"using-the-package-to-perform-operator-based-rational-approximations","dir":"Articles","previous_headings":"","what":"Using the package to perform operator-based rational approximations","title":"Operator-based rational approximation","text":"main purpose rSPDE package provide functions creating rational approximation. vignette focus operator-based rational approximation, means assembling matrices \\(\\boldsymbol{\\mathrm{Q}}\\) \\(\\boldsymbol{\\mathrm{P}}_r\\). three functions computing rational approximation. general function fractional.operators(), works wide class models general differential operator \\(L\\). stationary Matérn case, \\(L = \\kappa^2 - \\Delta\\), function matern.operators() provides simplified model specification. generalized non-stationary Matérn model, defined SPDE \\[ (\\kappa(s)^2 - \\Delta)^\\beta (\\tau(s)u(s)) = \\mathcal{W}, \\] function spde.matern.operators() can used. alternative covariance-based rational approximation, refer reader Rational approximation rSPDE package vignette. worth noting covariance-based rational approximation applies fractional SPDE models Gaussian noise, whereas operator-based rational approximation can used general models models driven type-G Lévy noise considered (Wallin Bolin 2015)(https://onlinelibrary.wiley.com/doi/full/10.1111/sjos.12141), (Bolin 2013)(https://onlinelibrary.wiley.com/doi/abs/10.1111/sjos.12046), (Asar et al. 2020)(https://rss.onlinelibrary.wiley.com/doi/pdf/10.1111/rssc.12405). approximation constructed, can included manually statistical models just non-fractional case. package built-functions basic use approximation, simulate() can applied simulation field. also functions likelihood evaluation kriging prediction geostatistical models Gaussian measurement noise. following sections, illustrate usage functions.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"constructing-the-approximation","dir":"Articles","previous_headings":"Using the package to perform operator-based rational approximations","what":"Constructing the approximation","title":"Operator-based rational approximation","text":"section, explain different main functions can used constructing rational approximation. first step constructing rational SPDE approximation define FEM mesh. section, use simple FEM implementation rSPDE package models defined interval. Assume want define model interval \\([0,1]\\). start defining vector mesh nodes \\(s_i\\) basis functions \\(\\varphi_i\\) centered. Based nodes, use built-function rSPDE.fem1d() assemble two matrices needed creating approximation basic Matérn model. matrices mass matrix \\(\\boldsymbol{\\mathrm{C}}\\), elements \\(C_{ij} = \\int \\varphi_j(s) \\varphi_i(s) ds\\), stiffness matrix \\(\\boldsymbol{\\mathrm{G}}\\), elements \\(G_{ij} = \\int \\nabla\\varphi_j(s) \\cdot \\nabla\\varphi_i(s) ds\\). can now use matern.operators() construct rational SPDE approximation degree \\(m=1\\) Gaussian random field Matérn covariance function interval. Since using operator-based approximation, must set type \"operator\". object op contains matrices needed evaluating distribution stochastic weights \\(\\boldsymbol{\\mathrm{u}}\\). want evaluate \\(u_h(s)\\) locations \\(s_1,\\ldots, s_n\\), need multiply weights basis functions \\(\\varphi_i(s)\\) evaluated locations. , can construct observation matrix \\(\\boldsymbol{\\mathrm{}}\\) elements \\(A_{ij} = \\varphi_j(s_i)\\), links FEM basis functions locations. matrix can constructed using function rSPDE.A1d(). evaluate accuracy approximation, let us compute covariance function process \\(s=0.5\\) locations s compare true covariance function, folded Matérn covariance, see Theorem 1 explicit link Gaussian fields Gaussian Markov random fields: stochastic partial differential equation approach. covariances can calculated \\[ \\boldsymbol{\\mathrm{}} \\boldsymbol{\\mathrm{P}}_r \\boldsymbol{\\mathrm{Q}}^{-1}\\boldsymbol{\\mathrm{P}}_r^T\\boldsymbol{\\mathrm{v}}. \\] \\(\\boldsymbol{\\mathrm{}}\\) identity matrix since evaluating approximation nodes FEM mesh \\(\\boldsymbol{\\mathrm{v}}\\) vector basis functions evaluated \\(s=0.5\\). covariance function error compared Matérn covariance shown following figure.  improve approximation can increase degree polynomials, increasing \\(m\\), /increase number basis functions used FEM approximation. Let us, example, compute approximation \\(m=2\\) using mesh, well approximation increase number basis functions use \\(m=1\\) \\(m=2\\). resulting errors shown following figure.  Since error induced rational approximation decreases exponentially \\(m\\), rarely need approximation large value \\(m\\). good number non-zero elements \\(\\boldsymbol{\\mathrm{P}}_r\\) \\(\\boldsymbol{\\mathrm{Q}}\\) increases \\(m\\), makes approximation computationally costly use. , condition numbers \\(\\boldsymbol{\\mathrm{P}}_r\\) \\(\\boldsymbol{\\mathrm{Q}}\\) increase \\(m\\), can cause numerical problems working matrices. illustrate , let us compute norm approximation error different \\(m\\). see error decreases increasing \\(m\\) \\(1\\) \\(2\\), large \\(m=3\\) \\(m=4\\). reason approximation bad, numerical accuracy product \\(\\boldsymbol{\\mathrm{P}}_r\\boldsymbol{\\mathrm{Q}}^{-1}\\boldsymbol{\\mathrm{P}}_rv\\) low due large condition numbers matrices. important note alternative covariance-based rational approximation numerically stable. main reason relies decomposition field \\(u\\) sum random fields, removes need computing higher order finite element matrices large values \\(m\\). See Rational approximation rSPDE package vignette details. handle issue operator-based rational approximation, package contains functions performing operations \\(\\boldsymbol{\\mathrm{P}}_rv\\) \\(\\boldsymbol{\\mathrm{P}}_r^{-1}v\\) takes advantage structure \\(\\boldsymbol{\\mathrm{P}}_r\\) avoid numerical instabilities. complete list function can seen typing ?operator.operations. One functions Sigma.mult(), performs multiplication \\(\\boldsymbol{\\mathrm{P}}_r\\boldsymbol{\\mathrm{Q}}^{-1}\\boldsymbol{\\mathrm{P}}_rv\\) numerically stable way. Let us use function compute errors approximations see indeed get better approximations \\(m\\) increases.","code":"s <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(s) kappa <- 20 sigma <- 2 nu <- 0.8 op <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem$G, C = fem$C, d = 1, m = 1,   type = \"operator\" ) v <- t(rSPDE.A1d(s, 0.5)) c.approx <- op$Pr %*% solve(op$Q, op$Pr %*% v) c.true <- folded.matern.covariance.1d(rep(0.5, length(s)), abs(s), kappa, nu, sigma) opar <- par(   mfrow = c(1, 2), mgp = c(1.3, 0.5, 0),   mar = c(2, 2, 0.5, 0.5) + 0.1 ) plot(s, c.true,   type = \"l\", ylab = \"C(|s-0.5|)\", xlab = \"s\", ylim = c(0, 5),   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, c.approx, col = 2) legend(\"topright\",   bty = \"n\",   legend = c(\"Matérn\", \"m=1 rSPDE\"),   col = c(\"black\", \"red\"),   lty = rep(1, 2), ncol = 1,   cex = 0.8 )  plot(s, c.true - c.approx,   type = \"l\", ylab = \"Error\", xlab = \"s\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) par(opar) op2 <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem$G, C = fem$C, d = 1, m = 2,   type = \"operator\" ) c.approx2 <- op2$Pr %*% solve(op2$Q, op2$Pr %*% v)  s2 <- seq(from = 0, to = 1, length.out = 501) fem2 <- rSPDE.fem1d(s2) op <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem2$G, C = fem2$C, d = 1, m = 1,   type = \"operator\" ) A <- rSPDE.A1d(s2, s) v <- t(rSPDE.A1d(s2, 0.5)) c.approx3 <- A %*% op$Pr %*% solve(op$Q, op$Pr %*% v) op <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem2$G, C = fem2$C, d = 1, m = 2,   type = \"operator\" ) c.approx4 <- A %*% op$Pr %*% solve(op$Q, op$Pr %*% v) opar <- par(mgp = c(1.3, 0.5, 0), mar = c(2, 2, 0.5, 0.5) + 0.1) plot(s, c.true - c.approx,   type = \"l\", ylab = \"Error\", xlab = \"s\", col = 1,   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, c.true - c.approx2, col = 2) lines(s, c.true - c.approx3, col = 3) lines(s, c.true - c.approx4, col = 4) legend(\"bottomright\",   bty = \"n\",   legend = c(\"m=1 coarse mesh\", \"m=2 coarse mesh\",   \"m=1 fine mesh\", \"m=2 fine mesh\"),   col = c(1, 2, 3, 4),   lty = rep(1, 2), ncol = 1,   cex = 0.8 ) par(opar) errors <- rep(0, 4) for (i in 1:4) {   op <- matern.operators(     kappa = kappa, sigma = sigma, nu = nu,     G = fem2$G, C = fem2$C, d = 1, m = i,     type = \"operator\"   )   c.app <- A %*% op$Pr %*% solve(op$Q, op$Pr %*% v)   errors[i] <- norm(c.true - c.app) } print(errors) #> [1]  1.0120165  0.1100542 52.4841240 54.6499071 errors2 <- rep(0, 4) for (i in 1:4) {   op <- matern.operators(     kappa = kappa, sigma = sigma, nu = nu,     G = fem2$G, C = fem2$C, d = 1, m = i,     type = \"operator\"   )   c.app <- A %*% Sigma.mult(op, v)   errors2[i] <- norm(c.true - c.app) } print(errors2) #> [1] 1.01201540 0.10479953 0.02474815 0.01788324"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"a-non-stationary-model","dir":"Articles","previous_headings":"","what":"A non-stationary model","title":"Operator-based rational approximation","text":"Let us now examine non-stationary model \\((\\kappa(s)^2 - \\Delta)^\\beta (\\tau(s)u(s)) = \\mathcal{W}\\) \\(\\kappa(s) = 10(1+2s^2)\\) \\(\\tau(s) = 0.1(1 - 0.7s^2)\\). can use spde.matern.operators() create rational approximation \\(m=1\\) follows. Let us compute covariance function \\(C(s,s_i)\\) non-stationary model locations \\(s_1=0.1, s_2 = 0.5,\\) \\(s_3 = 0.9\\). three covariances shown following figure.  see choice \\(\\kappa(s)\\) \\(\\tau(s)\\) results model longer range small values \\(s\\) smaller variance middle domain. can also apply general function fractional.operators() construct approximation. function requires user supplies discretization non-fractional operator \\(L\\), well scaling factor \\(c>0\\) lower bound smallest eigenvalue \\(L\\). case \\(L = \\kappa(s)^2 - \\Delta\\), eigenvalues operator bounded \\(c = \\min_s \\kappa(s)^2\\). compute constant discrete operator. Another difference fractional.operators() previous functions constructing approximation, requires specifying \\(\\beta\\) instead smoothness parameter \\(\\nu\\) Matérn covariance. two parameters related \\(2\\beta = \\nu + d/2\\). Let’s make sure approximation comparing previously computed covariances. Obviously, simpler use spde.matern.operators() case, advantage fractional.operators() also can used general models one \\(L = \\kappa(s)^2 - \\nabla \\cdot (\\boldsymbol{\\mathrm{H}}(s) \\nabla)\\) matrix-valued function \\(\\boldsymbol{\\mathrm{H}}(s)\\).","code":"s <- seq(from = 0, to = 1, length.out = 501) fem <- rSPDE.fem1d(s) kappa <- 10 * (1 + 2 * s^2) tau <- 0.1 * (1 - 0.7 * s^2) op <- spde.matern.operators(   kappa = kappa, tau = tau, nu = nu,   G = fem$G, C = fem$C, d = 1, m = 1 ) v <- t(rSPDE.A1d(s, c(0.1, 0.5, 0.9))) covs <- Sigma.mult(op, v) opar <- par(mgp = c(1.3, 0.5, 0), mar = c(2, 2, 0.5, 0.5) + 0.1) plot(s, covs[, 1],   type = \"l\", ylab = \"C(s,s_i)\", xlab = \"s\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, covs[, 2], col = 2) lines(s, covs[, 3], col = 3) par(opar) c <- min(kappa)^2 L <- fem$G + fem$C %*% Diagonal(501, kappa^2) op <- fractional.operators(   L = L, beta = (nu + 1 / 2) / 2, C = fem$C,   scale.factor = c, tau = tau, m = 1 ) covs2 <- Sigma.mult(op, v) norm(covs - covs2) #> [1] 0"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"using-the-approximation","dir":"Articles","previous_headings":"A non-stationary model","what":"Using the approximation","title":"Operator-based rational approximation","text":"approximation, constructed using functions fractional.operators(), matern.operators(), spde.matern.operators(), can simulate model using simulate(). also built-support kriging prediction. illustrate , use simulation create noisy observations process. , first construct observation matrix linking FEM basis functions locations want simulate. first randomly generate observation locations construct matrix. now generate observations \\(Y_i = u(s_i) + \\varepsilon_i\\), \\(\\varepsilon_i \\sim N(0,\\sigma_e^2)\\) Gaussian measurement noise. Finally, compute kriging prediction process \\(u\\) locations s based observations. specify locations predicted, argument Aprd used. argument observation matrix links mesh locations prediction locations. process simulation, observed data, kriging prediction shown following figure.","code":"u <- simulate(op) n.obs <- 20 obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(s, obs.loc) sigma.e <- 0.3 Y <- as.vector(A %*% u + sigma.e * rnorm(n.obs)) A.krig <- rSPDE.A1d(s, s) u.krig <- predict(op, A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e) opar <- par(mgp = c(1.3, 0.5, 0), mar = c(2, 2, 0.5, 0.5) + 0.1) plot(obs.loc, Y,   ylab = \"u(s)\", xlab = \"s\",   ylim = c(min(c(min(u), min(Y))), max(c(max(u), max(Y)))),   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, u) lines(s, u.krig$mean, col = 2) par(opar)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"spatial-data-and-parameter-estimation","dir":"Articles","previous_headings":"","what":"Spatial data and parameter estimation","title":"Operator-based rational approximation","text":"functions used previous examples also work spatial models. need construct mesh domain interest compute matrices needed define operator. tasks can performed, example, using R-INLA package. Let us start defining mesh \\([0,1]\\times [0, 1]\\) compute mass stiffness matrices mesh.  can now use matrices define rational SPDE approximation degree \\(m=1\\) Matérn model . illustrate , simulate latent process standard deviation \\(\\sigma=1\\) range \\(0.1\\). choose \\(\\nu=0.5\\) model corresponds Gaussian process exponential covariance function. Now let us simulate noisy data use estimate parameters model. construct observation matrix, use R-INLA function inla.spde.make.(). sample 30 replicates latent field. first replicate simulated random field well observation locations shown following figure.  type rational approximation degree \\(m\\), corresponding likelihood function can used likelihood-based parameter estimation. Since constructed model spde.matern.operators(), can use function spde.matern.loglike() define likelihood. simplify parameter estimation, create object containing rSPDE model (assigning meaningless value 1 parameters used): can now obtain objective function minimize, negative log-likelihood, parametrized using logarithm parameter avoid constrained optimization, using rSPDE.construct.matern.loglike() function factory: can now estimate parameter using optim(). Finally, observe can use rational.order() function, check order rational approximation rSPDE object, well use rational.order<-() function assign new orders:","code":"library(INLA) m <- 100 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.create.helper(   points = loc_2d_mesh,   cutoff = 0.05,   offset = c(0.1, 0.4),   max.edge = c(0.05, 0.5) ) plot(mesh_2d, main = \"\") points(loc_2d_mesh[, 1], loc_2d_mesh[, 2]) fem_mesh_2d <- inla.mesh.fem(mesh_2d) C <- fem_mesh_2d$c0 G <- fem_mesh_2d$g1 nu <- 0.5 sigma <- 1 range <- 0.1 kappa <- sqrt(8 * nu) / range tau <- 1 / (sqrt(4 * pi) * kappa * sigma) op <- spde.matern.operators(kappa = kappa, tau = tau, nu = nu, G = G, C = C, d = 2, m = 1) n.rep <- 30 u <- simulate(op, nsim = n.rep) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 Y <- A %*% u + matrix(rnorm(m * n.rep), ncol = n.rep) * sigma.e opar <- par(mfrow = c(1, 2), mgp = c(1.2, 0.5, 0), mar = c(2, 2, 0.5, 0.5) + 0.1) proj <- inla.mesh.projector(mesh_2d, dims = c(70, 70)) image(inla.mesh.project(proj, field = as.vector(u[, 1])),   xlab = \"\", ylab = \"\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) plot(loc_2d_mesh[, 1], loc_2d_mesh[, 2],   cex = 0.2, pch = 16, xlab = \"\", ylab = \"\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) par(opar) op_obj <- matern.operators(     kappa = 1, sigma = 1, nu = 1,     G = G, C = C, d = 2, m = 1,     type = \"operator\"   ) mlik <- rSPDE.construct.matern.loglike(op_obj, Y=Y, A=A) theta0 <- c(   get.inital.values.rSPDE(mesh = mesh_2d),   log(0.1 * sqrt(var(as.vector(Y)))) )  start_time <- Sys.time() pars <- optim(theta0, mlik, method = \"L-BFGS-B\") end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(   sigma = c(sigma, exp(pars$par[1])),   kappa = c(kappa, exp(pars$par[2])),   nu = c(nu, exp(pars$par[3])),   sigma.e = c(sigma.e, exp(pars$par[4])),   row.names = c(\"True\", \"Estimate\") ) print(results) #>             sigma    kappa       nu    sigma.e #> True     1.000000 20.00000 0.500000 0.10000000 #> Estimate 5.662538 27.34414 1.029998 0.08323404  # Total time print(total_time) #> Time difference of 33.38037 secs rational.order(op_obj) #> [1] 1  rational.order(op_obj) <- 2  mlik_order2 <- rSPDE.construct.matern.loglike(op_obj, Y=Y, A=A)  start_time <- Sys.time() pars <- optim(theta0, mlik_order2, method = \"L-BFGS-B\") end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(   sigma = c(sigma, exp(pars$par[1])),   kappa = c(kappa, exp(pars$par[2])),   nu = c(nu, exp(pars$par[3])),   sigma.e = c(sigma.e, exp(pars$par[4])),   row.names = c(\"True\", \"Estimate\") ) print(results) #>             sigma    kappa       nu    sigma.e #> True     1.000000 20.00000 0.500000 0.10000000 #> Estimate 5.675028 27.14913 1.012389 0.08333184  # Total time print(total_time) #> Time difference of 40.66162 secs"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Rational approximation with the rSPDE package","text":"vignette introduce covariance-based rational SPDE approach illustrate perform statistical inference . covariance-based approach efficient alternative operator-based rational SPDE approach (Bolin Kirchner 2020)(https://www.tandfonline.com/doi/full/10.1080/10618600.2019.1665537) works one SPDE driven Gaussian white noise. refer reader (Xiong, Simas, Bolin 2022)(https://arxiv.org/abs/2209.04670) theoretical details approach. Details operator-based rational SPDE approach given Operator-based rational approximation vignette. R-INLA inlabru implementations covariance-based rational SPDE approach refer reader vignettes R-INLA implementation rational SPDE approach inlabru implementation rational SPDE approach respectively.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"covariance-based-rational-spde-approach","dir":"Articles","previous_headings":"","what":"Covariance-based rational SPDE approach","title":"Rational approximation with the rSPDE package","text":"Let us first present basic setup. want model precipitation two-dimensional random field \\(u\\) within bounded domain, location domain associates random variable describe local precipitation. SPDE approach, introduced (Lindgren, Rue, Lindström 2011)(https://rss.onlinelibrary.wiley.com/doi/full/10.1111/j.1467-9868.2011.00777.x) model \\(u\\) solution following SPDE: \\[L^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(L = -\\Delta +\\kappa^2 \\) \\(\\mathcal{W}\\) standard Gaussian white noise. , \\(\\alpha\\), \\(\\kappa\\) \\(\\tau\\) three parameters want estimate. standard SPDE approach, write, general dimension \\(d\\), \\(\\alpha = \\nu + d/2\\) assume \\(\\nu\\) fixed \\(\\alpha\\) integer. rational SPDE approach can use value \\(\\nu>0\\) also estimate data. Now let us briefly describe covariance based rational SPDE approach works statistical inference. main idea perform rational approximation directly covariance operator, given \\(L^{-\\alpha}\\), instead solution \\(u\\). end, begin obtaining approximation random field \\(u\\), solution SPDE , using finite element method (FEM): \\[u_h(\\mathbf{s}_i)=\\sum_{j=1}^{n_h} \\hat{u}_j \\varphi_j(\\mathbf{s}_i),\\] \\(\\{\\hat{u}_j\\}_{j = 1}^{n_h}\\) stochastic weights \\(\\{\\varphi_j(\\mathbf{s}_i)\\}_{j = 1}^{n_h}\\) fixed piecewise linear continuous basis functions obtained triangulation spatial domain. obtain FEM approximation operator \\(L\\), given \\(L_h\\), covariance operator \\(u_h\\) given \\(L_h^{-\\alpha}\\). Now, using rational approximation \\(L_h\\), can approximate covariance operator \\(L_h^{-\\alpha}\\) \\[L_{h,m}^{-\\alpha} = L_h^{-\\lfloor\\alpha\\rfloor} p(L_h^{-1})q(L_h^{-1})^{-1},\\] \\(\\lfloor\\alpha\\rfloor\\) denotes integer part \\(\\alpha\\), \\(m\\) order rational approximation, \\(p(L_h^{-1}) = \\sum_{=0}^m a_i L_h^{m-}\\) \\(q(L_h^{-1}) = \\sum_{j=0}^m b_j L_h^{m-}\\), \\(\\{a_i\\}_{= 0}^m\\) \\(\\{b_j\\}_{j = 0}^m\\) known coefficients obtained rational approximation function \\(x^{\\alpha - \\lfloor\\alpha\\rfloor}\\). next step perform partial fraction decomposition rational function \\(p(L_h^{-1})q(L_h^{-1})^{-1}\\), yields representation \\[L_{h,m}^{-\\alpha} =L_h^{-\\lfloor\\alpha\\rfloor} \\left(\\sum_{=1}^{m}  r_i  (L_h-p_i )^{-1} +k\\right).\\] Based operator equation, can write covariance matrix stochastic weights \\(\\hat{\\textbf{u}}\\), \\(\\hat{\\textbf{u}}=[\\hat{u}_1,...,\\hat{u}_{n_h}]^\\top\\), \\[\\mathbf{\\Sigma}_{\\hat{\\textbf{u}}} = (\\textbf{L}^{-1}\\textbf{C})^{\\lfloor\\alpha\\rfloor} \\sum_{=1}^{m}r_i(\\textbf{L}-p_i\\textbf{C})^{-1}+\\textbf{K}, \\] \\(\\textbf{C} = \\{C_{ij}\\}_{,j=1}^{n_h}\\), \\(C_{ij} = (\\varphi_i,\\varphi_j)_{L_2(\\mathcal{D})}\\), mass matrix, \\(\\textbf{L} = \\kappa^2\\textbf{C}+\\textbf{G}\\), \\(\\textbf{G} = \\{G_{ij}\\}_{,j=1}^{n_h}\\), \\(G_{ij}=(\\nabla\\varphi_i,\\nabla\\varphi_j)_{L_2(\\mathcal{D})}\\), stiffness matrix, \\[\\textbf{K}=\\left\\{     \\begin{array}{lcl}         k\\textbf{C}      &      & {\\lfloor\\alpha\\rfloor=0}\\\\         k\\textbf{L}^{-1}(\\textbf{C}\\textbf{L}^{-1})^{\\lfloor\\alpha\\rfloor-1}    &      & {\\lfloor\\alpha\\rfloor\\geq 1}\\\\     \\end{array} \\right. .\\] representation shows can express \\(\\hat{\\textbf{u}}\\) \\[\\hat{\\textbf{u}}=\\sum_{k=1}^{m+1}\\textbf{x}_k,\\] \\(\\textbf{x}_k = (x_{k,1}, \\ldots, x_{k,n_h})\\), \\[\\textbf{x}_i \\sim N(\\textbf{0},\\textbf{Q}_i^{-1}),\\] \\(\\textbf{Q}_i\\) precision matrix \\(\\textbf{x}_i\\), given \\[\\textbf{Q}_i=\\left \\{     \\begin{array}{lcl}         (\\textbf{L}-p_i\\textbf{C})(\\textbf{C}^{-1}\\textbf{L})^{\\lfloor\\alpha\\rfloor}/r_i,      &      & {= 1,...,m}\\\\          \\textbf{K}^{-1},   &      & {= m+1}\\\\     \\end{array}. \\right.\\] , , replace Matérn latent field latent vector given , precision matrix given \\[\\textbf{Q}=\\begin{bmatrix}\\textbf{Q}_1& &\\\\&\\ddots&\\\\& &\\textbf{Q}_{m+1}\\end{bmatrix}.\\] Now, assume observe \\[y_i = u_h(\\mathbf{s}_i) + \\varepsilon_i,\\quad =1,\\ldots, N,\\] \\(\\varepsilon_i\\sim N(0,\\sigma_\\varepsilon^2)\\) iid measurement noise. , \\[y_i = u_h(\\mathbf{s}_i) + \\varepsilon_i = \\sum_{j=1}^{n_h} \\hat{u}_j \\varphi_j(\\mathbf{s}_i) + \\varepsilon_i = \\sum_{k=1}^{m+1} \\sum_{j=1}^{n_h} x_{k,j} \\varphi(\\mathbf{s}_i) + \\varepsilon_i.\\] can written matrix form \\[\\textbf{y} = \\overline{\\textbf{}} \\textbf{X} + \\boldsymbol{\\varepsilon},\\] \\(\\textbf{y} = [y_1,\\ldots,y_N]^\\top, \\textbf{X} = [\\textbf{x}_1^\\top,\\ldots,\\textbf{x}_{m+1}^\\top]^\\top\\), \\(\\boldsymbol{\\varepsilon} = [\\varepsilon_1,\\ldots,\\varepsilon_N]^\\top\\), \\[\\overline{\\textbf{}}=\\begin{bmatrix}\\textbf{}&\\cdots&\\textbf{}\\end{bmatrix}_{n\\times n_h(m+1)},\\] \\[\\textbf{}=\\begin{bmatrix}\\varphi_1(s_1)&\\cdots&\\varphi_{n_h}(s_1)\\\\\\vdots&\\vdots&\\vdots\\\\\\varphi_1(s_n)&\\cdots&\\varphi_{n_h}(s_n)\\end{bmatrix}.\\] arrive following hierarchical model: \\[\\begin{align} \\textbf{y}\\mid \\textbf{X} &\\sim N(0,\\sigma_\\varepsilon\\textbf{})\\\\ \\textbf{X}&\\sim N(0,\\textbf{Q}^{-1}) \\end{align}.\\] elements, can, example, use R-INLA compute posterior distribution three parameters want estimate.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"constructing-the-approximation","dir":"Articles","previous_headings":"","what":"Constructing the approximation","title":"Rational approximation with the rSPDE package","text":"section, explain use function matern.operators() default argument type, , type=\"covariance\", constructs covariance-based rational approximation. also illustrate usage several methods functions related covariance-based rational approximation. use functions sample Gaussian fields stationary Matérn covariance function, compute log-likelihood function, spatial prediction. first step performing covariance-based rational SPDE approximation define FEM mesh. illustration purposes, rSPDE package contains simple FEM implementation models \\(\\mathbb{R}\\) use first. also illustrate spatial models can constructed FEM implementation R-INLA package used instead. using R-INLA package, also recommend usage R-INLA implementation rational SPDE approach. details, see R-INLA implementation rational SPDE approach vignette. begin loading rSPDE package: Assume want define model interval \\([0,1]\\). start defining vector mesh nodes \\(s_i\\) basis functions \\(\\varphi_i\\) centered. Based nodes, use built-function rSPDE.fem1d() assemble two matrices needed creating approximation basic Matérn model. matrices mass matrix \\(\\boldsymbol{\\mathrm{C}}\\), elements \\(C_{ij} = \\int \\varphi_j(s) \\varphi_i(s) ds\\), stiffness matrix \\(\\boldsymbol{\\mathrm{G}}\\), elements \\(G_{ij} = \\int \\nabla\\varphi_j(s) \\cdot \\nabla\\varphi_i(s) ds\\). can now use matern.operators() construct rational SPDE approximation order \\(m=2\\) Gaussian random field Matérn covariance function interval. also refer reader Operator-based rational approximation similar comparison made operator-based rational approximation. object op_cov contains matrices needed evaluating distribution stochastic weights \\(\\boldsymbol{\\mathrm{u}}\\). want evaluate \\(u_h(s)\\) locations \\(s_1,\\ldots, s_n\\), need multiply weights basis functions \\(\\varphi_i(s)\\) evaluated locations. , can construct observation matrix \\(\\boldsymbol{\\mathrm{}}\\), elements \\(A_{ij} = \\varphi_j(s_i)\\), links FEM basis functions locations. matrix can constructed using function rSPDE.A1d(). However, observed introduction vignette, decomposed stochastic weights \\(\\boldsymbol{\\mathrm{u}}\\) vector latent variables. Thus, \\(\\) matrix covariance-based rational approximation, denote \\(\\overline{}\\), actually given \\(m+1\\)-fold horizontal concatenation \\(\\) matrices, \\(m\\) order rational approximation. compute precision matrix covariance-based rational approximation one can use precision() method CBrSPDEobj object (object returned matern.operators() function default type, type=\"covariance\"): evaluate accuracy approximation, let us compute covariance function process \\(s=0.5\\) locations s compare true Matérn covariance function. covariances can calculated \\[ \\overline{\\boldsymbol{\\mathrm{}}} \\boldsymbol{\\mathrm{Q}}^{-1}\\overline{\\boldsymbol{\\mathrm{v}}}. \\] , \\(\\boldsymbol{\\mathrm{Q}}\\) precision matrix obtained covariance-based rational approximation, \\(\\boldsymbol{\\mathrm{}}\\) identity matrix since evaluating approximation nodes FEM mesh, \\(\\overline{\\boldsymbol{\\mathrm{v}}}\\) \\((m+1)\\)-fold vertical concatenation vector \\(\\boldsymbol{\\mathrm{v}}\\), \\(\\boldsymbol{\\mathrm{v}}\\) vector basis functions evaluated \\(s=0.5\\). Let us now compute true Matérn covariance function interval \\((0,1)\\), folded Matérn, see Theorem 1 explicit link Gaussian fields Gaussian Markov random fields: stochastic partial differential equation approach details. covariance function error compared Matérn covariance shown following figure.  improve approximation can increase degree polynomials, increasing \\(m\\), /increase number basis functions used FEM approximation. Let us, example, compute approximation \\(m=4\\) using mesh, well approximation increase number basis functions use \\(m=2\\) \\(m=4\\). resulting errors shown following figure.  Since error induced rational approximation decreases exponentially \\(m\\), general rarely need approximation large value \\(m\\). good size \\(\\boldsymbol{\\mathrm{Q}}\\) increases \\(m\\), makes approximation computationally costly use. illustrate , let us compute norm approximation error different \\(m\\). see error decreases fast increase \\(m\\) \\(1\\) \\(4\\), without numerical instability. advantage covariance-based rational approximation compared operator-based rational approximation. See Operator-based rational approximation details numerical instability operator-based rational approximation.","code":"library(rSPDE) s <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(s) kappa <- 20 sigma <- 2 nu <- 0.8 op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 ) Q <- precision(op_cov) v <- t(rSPDE.A1d(s, 0.5)) v_bar <- kronecker(matrix(1, nrow = 3), v) A <- Diagonal(101) A_bar <- kronecker(matrix(1, ncol = 3), A) c_cov.approx <- (A_bar) %*% solve(Q, v_bar) c.true <- folded.matern.covariance.1d(rep(0.5, length(s)), abs(s), kappa, nu, sigma) opar <- par(   mfrow = c(1, 2), mgp = c(1.3, 0.5, 0),   mar = c(2, 2, 0.5, 0.5) + 0.1 ) plot(s, c.true,   type = \"l\", ylab = \"C(|s-0.5|)\", xlab = \"s\", ylim = c(0, 5),   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, c_cov.approx, col = 2) legend(\"topright\",   bty = \"n\",   legend = c(\"Matérn\", \"Rational\"),   col = c(\"black\", \"red\"),   lty = rep(1, 2), ncol = 1,   cex = 0.8 )  plot(s, c.true - c_cov.approx,   type = \"l\", ylab = \"Error\", xlab = \"s\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) par(opar) op_cov2 <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem$G, C = fem$C, d = 1, m = 4 ) Q2 <- precision(op_cov2) v_bar2 <- kronecker(matrix(1, nrow = 5), v) A_bar2 <- kronecker(matrix(1, ncol = 5), A) c_cov.approx2 <- (A_bar2) %*% solve(Q2, v_bar2)  s2 <- seq(from = 0, to = 1, length.out = 501) fem2 <- rSPDE.fem1d(s2) op_cov <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem2$G, C = fem2$C, d = 1, m = 2 ) Q3 <- precision(op_cov) A2 <- rSPDE.A1d(s2, s) v2 <- t(rSPDE.A1d(s2, 0.5)) v2_bar <- kronecker(matrix(1, nrow = 3), v2) A2_bar <- kronecker(matrix(1, ncol = 3), A2) c_cov.approx3 <- (A2_bar) %*% solve(Q3, v2_bar)  op_cov <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem2$G, C = fem2$C, d = 1, m = 4 ) Q4 <- precision(op_cov) v2_bar2 <- kronecker(matrix(1, nrow = 5), v2) A2_bar2 <- kronecker(matrix(1, ncol = 5), A2) c_cov.approx4 <- (A2_bar2) %*% solve(Q4, v2_bar2) opar <- par(mgp = c(1.3, 0.5, 0), mar = c(2, 2, 0.5, 0.5) + 0.1) plot(s, c.true - c_cov.approx,   type = \"l\", ylab = \"Error\", xlab = \"s\", col = 1,   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, c.true - c_cov.approx2, col = 2) lines(s, c.true - c_cov.approx3, col = 3) lines(s, c.true - c_cov.approx4, col = 4) legend(\"bottomright\",   bty = \"n\",   legend = c(\"m=2 coarse mesh\", \"m=4 coarse mesh\", \"m=2 fine mesh\", \"m=4 fine mesh\"),   col = c(1, 2, 3, 4),   lty = rep(1, 2), ncol = 1,   cex = 0.8 ) par(opar) errors <- rep(0, 4) for (i in 1:4) {   op_cov <- matern.operators(     kappa = kappa, sigma = sigma, nu = nu,     G = fem2$G, C = fem2$C, d = 1, m = i   )   Q <- precision(op_cov)   v_bar <- kronecker(matrix(1, nrow = i + 1), v2)   A_bar <- kronecker(matrix(1, ncol = i + 1), A2)   c_cov.approx <- (A_bar) %*% solve(Q, v_bar)   errors[i] <- norm(c.true - c_cov.approx) } print(errors) ## [1] 0.977500618 0.086659188 0.017335545 0.008432137"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"using-the-approximation","dir":"Articles","previous_headings":"","what":"Using the approximation","title":"Rational approximation with the rSPDE package","text":"use function matern.operators(), can simulate model using simulate() method. end simply apply simulate() method object returned matern.operators() function: want replicates, simply set argument nsim desired number replicates. instance, generate two replicates model, simply :","code":"u <- simulate(op_cov) u.rep <- simulate(op_cov, nsim = 2)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"fitting-a-model","dir":"Articles","previous_headings":"Using the approximation","what":"Fitting a model","title":"Rational approximation with the rSPDE package","text":"built-support computing log-likelihood functions performing kriging prediction rSPDE package. illustrate , use simulation create noisy observations process. , first construct observation matrix linking FEM basis functions locations want simulate. first randomly generate observation locations construct matrix. now generate observations \\(Y_i = u(s_i) + \\varepsilon_i\\), \\(\\varepsilon_i \\sim N(0,\\sigma_e^2)\\) Gaussian measurement noise. assume latent process Matérn covariance \\(\\kappa=20, \\sigma=2\\) \\(\\nu=0.8\\): Let us now fit model. end first must compute loglikelihood function function parameters want estimate. define loglikelihood function parametrized using logarithm parameter avoid constrained optimization. now get suitable initial values optimization using get.inital.values.rSPDE(). add initial guess sigma.e. can also speed optimization using optimParallel() function optimParallel package. end, simply replace optim() function optimParallel() set number cores want use:","code":"set.seed(1) s <- seq(from = 0, to = 1, length.out = 501) n.obs <- 200 obs.loc <- runif(n.obs) fem <- rSPDE.fem1d(s) A <- rSPDE.A1d(s, obs.loc) kappa <- 20 sigma <- 2 nu <- 0.8 op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 ) u <- simulate(op_cov)  sigma.e <- 0.3 Y <- as.vector(A %*% u + sigma.e * rnorm(n.obs)) mlik_cov <- rSPDE.construct.matern.loglike(op_cov, Y=Y, A=A) theta0 <- c(   get.inital.values.rSPDE(mesh.range = 1, dim = 1),   log(0.1 * sqrt(var(as.vector(Y)))) )  start_time <- Sys.time() theta <- optim(theta0, mlik_cov,   method = \"L-BFGS-B\" ) end_time <- Sys.time()  time_optim <- end_time - start_time  print(data.frame(   sigma = c(sigma, exp(theta$par[1])), kappa = c(kappa, exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) ##              sigma    kappa        nu   sigma.e ## Truth     2.000000 20.00000 0.8000000 0.3000000 ## Estimates 2.476834 19.09341 0.8468107 0.3323609 # Total time print(time_optim) ## Time difference of 7.350285 secs library(optimParallel) # Preparing the parallel  # Checking if we have a limit to the number of cores chk <- Sys.getenv(\"_R_CHECK_LIMIT_CORES_\", \"\") if (nzchar(chk) && chk == \"TRUE\") {   n_cores <- 2L } else {   n_cores <- parallel::detectCores() - 1 }  cl <- makeCluster(n_cores) setDefaultCluster(cl = cl)  # Exporting the needed objects to the parallel cores # This step is not necessary for the regular optim parallel::clusterExport(cl, \"op_cov\") parallel::clusterExport(cl, \"Y\") parallel::clusterExport(cl, \"A\")  start_time <- Sys.time() theta_parallel <- optimParallel(theta0, mlik_cov) end_time <- Sys.time()  time_optim <- end_time - start_time  print(data.frame(   sigma = c(sigma, exp(theta_parallel$par[1])),   kappa = c(kappa, exp(theta_parallel$par[2])),   nu = c(nu, exp(theta_parallel$par[3])),   sigma.e = c(sigma.e, exp(theta_parallel$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) ##              sigma    kappa        nu   sigma.e ## Truth     2.000000 20.00000 0.8000000 0.3000000 ## Estimates 2.476834 19.09341 0.8468107 0.3323609 # Total time print(time_optim) ## Time difference of 5.870057 secs"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"kringing","dir":"Articles","previous_headings":"Using the approximation","what":"Kringing","title":"Rational approximation with the rSPDE package","text":"Finally, compute kriging prediction process \\(u\\) locations s based observations. specify locations predicted, argument Aprd used. argument observation matrix links mesh locations prediction locations. Let us update CBrSPDEobj object (returned matern.operators() function) fitted parameters: can now perform kringing predict() method: simulated process, observed data, kriging prediction shown following figure.","code":"A.krig <- rSPDE.A1d(s, s) sigma_est <- exp(theta$par[1]) kappa_est <- exp(theta$par[2]) nu_est <- exp(theta$par[3])  op_cov <- update(op_cov,   user_kappa = kappa_est,   user_sigma = sigma_est,   user_nu = nu_est ) u.krig <- predict(op_cov, A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e) opar <- par(mgp = c(1.3, 0.5, 0), mar = c(2, 2, 0.5, 0.5) + 0.1) plot(obs.loc, Y,   ylab = \"u(s)\", xlab = \"s\",   ylim = c(min(c(min(u), min(Y))), max(c(max(u), max(Y)))),   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, u) lines(s, u.krig$mean, col = 2) par(opar)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"fitting-a-model-with-replicates","dir":"Articles","previous_headings":"","what":"Fitting a model with replicates","title":"Rational approximation with the rSPDE package","text":"Let us illustrate simulate dataset replicates fit model data. Recall simulate latent model replicates, set nsim argument number replicates. use CBrSPDEobj object (returned matern.operators() function) previous example, namely op_cov. Now, let us generate observed values \\(Y\\): Note \\(Y\\) matrix 20 columns, column containing one replicate. Now, remaining code identical previous case. rSPDE.matern.loglike() function automatically identifies replicates fact \\(Y\\) matrix one column.","code":"set.seed(123) n.rep <- 20 u.rep <- simulate(op_cov, nsim = n.rep) sigma.e <- 0.3 Y.rep <- A %*% u.rep + sigma.e * matrix(rnorm(n.obs * n.rep), ncol = n.rep) theta0 <- c(   get.inital.values.rSPDE(mesh.range = 1, dim = 1),   log(0.1 * sqrt(var(as.vector(Y)))) )  mlik_cov <- rSPDE.construct.matern.loglike(op_cov, Y=Y.rep, A=A)  # Exporting the needed objects to the parallel cores # This step is not necessary for the regular optim parallel::clusterExport(cl, \"op_cov\") parallel::clusterExport(cl, \"Y.rep\") parallel::clusterExport(cl, \"A\")  start_time <- Sys.time() theta <- optimParallel(theta0, mlik_cov,   method = \"L-BFGS-B\" ) end_time <- Sys.time()  time_optim <- end_time - start_time  print(data.frame(   sigma = c(sigma, exp(theta$par[1])), kappa = c(kappa, exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) ##              sigma    kappa       nu   sigma.e ## Truth     2.000000 20.00000 0.800000 0.3000000 ## Estimates 2.379152 18.40182 0.810289 0.2931603 # Total time print(time_optim) ## Time difference of 4.462233 secs"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"spatial-data-and-parameter-estimation","dir":"Articles","previous_headings":"","what":"Spatial data and parameter estimation","title":"Rational approximation with the rSPDE package","text":"functions used previous examples also work spatial models. need construct mesh domain interest compute matrices needed define operator. tasks can performed, example, using R-INLA package. Let us start defining mesh \\([0,1]\\times [0, 1]\\) compute mass stiffness matrices mesh. important mention using R-INLA package recommend usage R-INLA implementation rational SPDE approach. purpose section show can estimate model without R-INLA using maximum likelihood approach instead. consider simple Gaussian linear model 30 independent replicates latent spatial field \\(u(\\mathbf{s})\\), observed \\(m\\) locations, \\(\\{\\mathbf{s}_1 , \\ldots , \\mathbf{s}_m \\}\\), replicate. \\(= 1,\\ldots,m,\\) \\[\\begin{align}  y_i &= u_1(\\mathbf{s}_i)+\\varepsilon_i,\\\\ \\vdots &= \\vdots\\\\  y_{+29m} &= u_{30}(\\mathbf{s}_i) + \\varepsilon_{+29m}, \\end{align}\\] \\(\\varepsilon_1,\\ldots,\\varepsilon_{30m}\\) iid normally distributed mean 0 standard deviation 0.1. Let us create FEM mesh:  can now use mesh define rational SPDE approximation order \\(m=2\\) Matérn model fashion one-dimensional case. now simulate latent process standard deviation \\(\\sigma=1\\) range \\(0.1\\). use \\(\\nu=0.5\\) model exponential covariance function. end create model object matern.operators() function: Now let us simulate noisy data use estimate parameters model. construct observation matrix, use R-INLA function inla.spde.make.(). Recall simulate data 30 replicates. first replicate simulated random field well observation locations shown following figure.  now use function rSPDE.matern.loglike() define likelihood. function object-based, sense obtains several quantities needs rSPDE model object. case, example, object op_cov_2d. simplify parameter estimation, create objective function minimize negative log-likelihood, parametrized using logarithm parameter avoid constrained optimization. can now estimate parameter using optimParallel():","code":"library(INLA) n_loc <- 500 loc_2d_mesh <- matrix(runif(n_loc * 2), n_loc, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   offset = c(0.1, 0.4),   max.edge = c(0.05, 0.5) ) plot(mesh_2d, main = \"\") points(loc_2d_mesh[, 1], loc_2d_mesh[, 2]) nu <- 0.5 sigma <- 1 range <- 0.1 kappa <- sqrt(8 * nu) / range d <- 2 op_cov_2d <- matern.operators(   mesh = mesh_2d,   nu = nu,   kappa = kappa,   sigma = sigma,   m = 2 ) n.rep <- 30 u <- simulate(op_cov_2d, nsim = n.rep) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 Y <- A %*% u + matrix(rnorm(n_loc * n.rep), ncol = n.rep) * sigma.e opar <- par(mfrow = c(1, 2), mgp = c(1.2, 0.5, 0), mar = c(2, 2, 0.5, 0.5) + 0.1) proj <- inla.mesh.projector(mesh_2d, dims = c(70, 70)) image(inla.mesh.project(proj, field = as.vector(u[, 1])),   xlab = \"\", ylab = \"\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) plot(loc_2d_mesh[, 1], loc_2d_mesh[, 2],   cex = 0.2, pch = 16, xlab = \"\", ylab = \"\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) par(opar) mlik_2d <- rSPDE.construct.matern.loglike(op_cov_2d, Y=Y, A=A) theta0_2d <- c(   get.inital.values.rSPDE(mesh = mesh_2d),   log(0.1 * sqrt(var(as.vector(Y)))) )  # Exporting the needed objects to the parallel cores # This step is not necessary for the regular optim parallel::clusterExport(cl, \"op_cov_2d\") parallel::clusterExport(cl, \"Y\") parallel::clusterExport(cl, \"A\")  start_time <- Sys.time() pars <- optimParallel(theta0_2d, mlik_2d) end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(   sigma = c(sigma, exp(pars$par[1])),   kappa = c(kappa, exp(pars$par[2])),   nu = c(nu, exp(pars$par[3])),   sigma.e = c(sigma.e, exp(pars$par[4])),   row.names = c(\"True\", \"Estimate\") ) print(results) ##             sigma    kappa        nu   sigma.e ## True     1.000000 20.00000 0.5000000 0.1000000 ## Estimate 1.032911 19.18672 0.4259368 0.1004302 # Total time print(total_time) ## Time difference of 14.00665 secs"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"changing-the-type-and-the-order-of-the-rational-approximation","dir":"Articles","previous_headings":"","what":"Changing the type and the order of the rational approximation","title":"Rational approximation with the rSPDE package","text":"three rational approximations available. BRASIL algorithm (Hofreither 2021)(https://doi.org/10.1007/s11075-020-01042-0), two “versions” Clenshaw-Lord Chebyshev-Pade algorithm, one lower bound zero another lower bound given (Xiong, Simas, Bolin 2022)(https://arxiv.org/abs/2209.04670). type rational approximation can chosen setting type_rational_approximation argument matern.operators function. BRASIL algorithm corresponds choice brasil, Clenshaw-Lord Chebyshev pade zero lower bound non-zero lower bounds given, respectively, choices chebfun chebfunLB. instance, can create rSPDE object chebfunLB rational approximation can check order rational approximation rational.order() function assign new order rational.order<-() function: Let us fit model using data previous example: can now estimate parameter using optimParallel(): Finally, can check type rational approximation rational.type() function assign new type using rational.type<-() function: Let us now fit model, data previous example, brasil rational approximation: can now estimate parameter using optimParallel():","code":"op_cov_2d_type <- matern.operators(   mesh = mesh_2d,   nu = nu,   kappa = kappa,   sigma = sigma,   m = 2,   type_rational_approximation = \"chebfunLB\" ) rational.order(op_cov_2d_type) ## [1] 2 rational.order(op_cov_2d_type) <- 3 mlik_2d_type <- rSPDE.construct.matern.loglike(op_cov_2d_type, Y=Y, A=A) # Exporting the needed objects to the parallel cores # This step is not necessary for the regular optim parallel::clusterExport(cl, \"op_cov_2d_type\")  start_time <- Sys.time() pars <- optimParallel(theta0_2d, mlik_2d_type) end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(   sigma = c(sigma, exp(pars$par[1])),   kappa = c(kappa, exp(pars$par[2])),   nu = c(nu, exp(pars$par[3])),   sigma.e = c(sigma.e, exp(pars$par[4])),   row.names = c(\"True\", \"Estimate\") ) print(results) ##             sigma    kappa        nu   sigma.e ## True     1.000000 20.00000 0.5000000 0.1000000 ## Estimate 1.050229 18.76927 0.3978261 0.1004293 # Total time print(total_time) ## Time difference of 13.14745 secs rational.type(op_cov_2d_type) ## [1] \"chebfunLB\" rational.type(op_cov_2d_type) <- \"brasil\" mlik_2d_type <- rSPDE.construct.matern.loglike(op_cov_2d_type, Y=Y, A=A) # Exporting the needed objects to the parallel cores # This step is not necessary for the regular optim parallel::clusterExport(cl, \"op_cov_2d_type\")  start_time <- Sys.time() pars <- optimParallel(theta0_2d, mlik_2d_type) end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(   sigma = c(sigma, exp(pars$par[1])),   kappa = c(kappa, exp(pars$par[2])),   nu = c(nu, exp(pars$par[3])),   sigma.e = c(sigma.e, exp(pars$par[4])),   row.names = c(\"True\", \"Estimate\") ) print(results) ##             sigma    kappa        nu   sigma.e ## True     1.000000 20.00000 0.5000000 0.1000000 ## Estimate 1.042359 19.04997 0.4124101 0.1004302 # Total time print(total_time) ## Time difference of 19.61924 secs"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"R-INLA implementation of the rational SPDE approach","text":"vignette present R-INLA implementation rational SPDE approach. theoretical details refer reader Rational approximation rSPDE package vignette (Xiong, Simas, Bolin 2022)(https://arxiv.org/abs/2209.04670). begin providing step--step illustration use implementation. end consider real world data set consists precipitation measurements Paraná region Brazil. initial model fitting, show change parameters model. end, also provide example replicates. important mention one can improve performance using PARDISO solver. Please, go https://www.pardiso-project.org/r-inla/#license apply license. Also, use inla.pardiso() instructions enable PARDISO sparse library.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"example-with-real-data","dir":"Articles","previous_headings":"","what":"Example with real data","title":"R-INLA implementation of the rational SPDE approach","text":"illustrate implementation rSPDE R-INLA consider dataset available R-INLA. data also used illustrate SPDE approach, see instance book Advanced Spatial Modeling Stochastic Partial Differential Equations Using R INLA also vignette Spatial Statistics using R-INLA Gaussian Markov random fields. See also (Lindgren, Rue, Lindström 2011)(https://rss.onlinelibrary.wiley.com/doi/full/10.1111/j.1467-9868.2011.00777.x) theoretical details standard SPDE approach. data consist precipitation measurements Paraná region Brazil provided Brazilian National Water Agency. data collected 616 gauge stations Paraná state, south Brazil, day 2011.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"an-rspde-model-for-precipitation","dir":"Articles","previous_headings":"Example with real data","what":"An rSPDE model for precipitation","title":"R-INLA implementation of the rational SPDE approach","text":"follow vignette Spatial Statistics using R-INLA Gaussian Markov random fields. precipitation data always positive, assume Gamma distributed. R-INLA uses following parameterization Gamma distribution, \\[\\Gamma(\\mu, \\phi): \\pi (y) = \\frac{1}{\\Gamma(\\phi)} \\left(\\frac{\\phi}{\\mu}\\right)^{\\phi} y^{\\phi - 1} \\exp\\left(-\\frac{\\phi y}{\\mu}\\right) .\\] parameterization, distribution expected value \\(E(x) = \\mu\\) variance \\(V(x) = \\mu^2/(\\phi)\\), \\(1/\\phi\\) dispersion parameter. example \\(\\mu\\) modeled using stochastic model includes covariates spatial structure, resulting latent Gaussian model precipitation measurements \\[\\begin{align} y_i\\mid \\mu(s_i), \\theta &\\sim \\Gamma(\\mu(s_i),c\\phi)\\\\ \\log (\\mu(s)) &= \\eta(s) = \\sum_k f_k(c_k(s))+u(s)\\\\ \\theta &\\sim \\pi(\\theta) \\end{align},\\] \\(y_i\\) denotes measurement taken location \\(s_i\\), \\(c_k(s)\\) covariates, \\(u(s)\\) mean-zero Gaussian Matérn field, \\(\\theta\\) vector containing parameters model, including smoothness field. , using rSPDE model also able estimate smoothness latent field.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"examining-the-data","dir":"Articles","previous_headings":"Example with real data","what":"Examining the data","title":"R-INLA implementation of the rational SPDE approach","text":"using R-INLA. install R-INLA go R-INLA Project. begin loading libraries need get data build plots. Let us load data border region data frame contains daily measurements 616 stations year 2011, well coordinates altitude information measurement stations. analyze full spatio-temporal data set, instead look total precipitation January, calculate next snippet code, extract coordinates altitudes remove locations missing values. Let us build plot precipitation observations using ggplot:  red line figure shows coast line, expect distance coast good covariate precipitation. covariate available, let us calculate observation location: Now, let us plot precipitation function possible covariates:","code":"library(gridExtra) library(ggplot2) library(lattice) library(INLA) library(splancs) library(fields) data(PRprec) data(PRborder) Y <- rowMeans(PRprec[, 3 + 1:31]) ind <- !is.na(Y) Y <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) alt <- PRprec$Altitude[ind] ggplot() +   geom_point(aes(     x = coords[, 1], y = coords[, 2],     colour = Y   ), size = 2, alpha = 1) +   scale_colour_gradientn(colours = tim.colors(100)) +   geom_path(aes(x = PRborder[, 1], y = PRborder[, 2])) +   geom_path(aes(x = PRborder[1034:1078, 1], y = PRborder[     1034:1078,     2   ]), colour = \"red\") seaDist <- apply(spDists(coords, PRborder[1034:1078, ],   longlat = TRUE ), 1, min) par(mfrow = c(2, 2)) plot(coords[, 1], Y, cex = 0.5, xlab = \"Longitude\") plot(coords[, 2], Y, cex = 0.5, xlab = \"Latitude\") plot(seaDist, Y, cex = 0.5, xlab = \"Distance to sea\") plot(alt, Y, cex = 0.5, xlab = \"Altitude\") par(mfrow = c(1, 1))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"creating-the-rspde-model","dir":"Articles","previous_headings":"Example with real data","what":"Creating the rSPDE model","title":"R-INLA implementation of the rational SPDE approach","text":"use R-INLA implementation rSPDE model need load functions: rSPDE-INLA implementation reminiscent R-INLA, usage straightforward R-INLA users. instance, create rSPDE model, one use rspde.matern() place inla.spde2.matern(). create index, one use rspde.make.index() place inla.spde.make.index(). create matrix, one use rspde.make.() place inla.spde.make.(), . main differences comparing arguments rSPDE-INLA implementation standard SPDE implementation R-INLA, nu rspde_order arguments, present rSPDE-INLA implementation. see use arguments.","code":"library(rSPDE)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"mesh","dir":"Articles","previous_headings":"Example with real data > Creating the rSPDE model","what":"Mesh","title":"R-INLA implementation of the rational SPDE approach","text":"can use R-INLA creating mesh. Let us create mesh based non-convex hull avoid adding many small triangles outside domain interest:","code":"prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2) plot(prmesh, asp = 1, main = \"\") lines(PRborder, col = 3) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"the-observation-matrix","dir":"Articles","previous_headings":"Example with real data > Creating the rSPDE model","what":"The observation matrix","title":"R-INLA implementation of the rational SPDE approach","text":"now create \\(\\) matrix, connects mesh observation locations create rSPDE model. task, mentioned earlier, need use rSPDEspecific function, whose name reminiscent R-INLA’s standard SPDE approach, namely rspde.make.() (place R-INLA’s inla.spde.make.()). reason need specific function size \\(\\) matrix depends order rational approximation. details can found introduction Rational approximation rSPDE package vignette. default order 2 covariance-based rational approximation. mentioned introduction Rational approximation rSPDE package vignette, approximation order 2 covariance-based rational approximation approximately computational cost operator-based rational approximation order 1. Recall latent process \\(u\\) solution \\[(\\kappa^2 -\\Delta)^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(\\alpha = \\nu + d/2\\). want estimate three parameters \\(\\tau,\\kappa\\) \\(\\nu\\), default option rSPDE-INLA implementation. However, also option fix smoothness parameter \\(\\nu\\) predefined value estimate \\(\\tau\\) \\(\\kappa\\). discussed later. first example assume want rational approximation order 2. end can use rspde.make.() function. Since assume order 2 want estimate smoothness, default options function, required parameters simply mesh locations:","code":"Abar <- rspde.make.A(mesh = prmesh, loc = coords)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"setting-up-the-rspde-model","dir":"Articles","previous_headings":"Example with real data > Creating the rSPDE model","what":"Setting up the rSPDE model","title":"R-INLA implementation of the rational SPDE approach","text":"set rSPDEmodel, need mesh. default assume want estimate smoothness parameter \\(\\nu\\) covariance-based rational approximation order 2. Later vignette also see options setting rSPDE models keeping smoothness parameter fixed /increasing order covariance-based rational approximation. Therefore, set model use rspde.matern() function: Note function reminiscent R-INLA’s inla.spde2.matern() function. pattern tried keep consistent package: rSPDE versions R-INLA function either replace inla inla.spde inla.spde2 rspde.","code":"rspde_model <- rspde.matern(mesh = prmesh)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"the-inla-stack","dir":"Articles","previous_headings":"Example with real data > Creating the rSPDE model","what":"The inla.stack","title":"R-INLA implementation of the rational SPDE approach","text":"Since covariates already evaluated observation locations, want apply \\(\\) matrix spatial effect fixed effects. can use inla.stack() function. difference, however, need use function rspde.make.index() (place standard inla.spde.make.index()) create index. one using default options, , estimate smoothness parameter \\(\\nu\\) rational approximation order 2, usage rspde.make.index() identical usage inla.spde.make.index(): can create stack standard manner: observation matrix \\(\\) applied spatial effect intercept identity observation matrix, denoted \\(1\\), applied covariates. means covariates unaffected observation matrix. observation matrices \\(=list(Abar,1)\\) used link corresponding elements effects-list observations. Thus model latent spatial field mesh.index intercept linked log-expectation observations, .e. \\(\\eta(s)\\), \\(\\)-matrix. covariates, hand, linked directly \\(\\eta(s)\\). stk.dat object defined implies following principal linkage model components observations \\[\\eta(s) \\sim x(s) + \\text{ Intercept} + \\text{seaDist}.\\] \\(\\eta(s)\\) used observation-likelihood, \\[y_i\\mid \\eta(s_i),\\theta \\sim \\Gamma(\\exp(\\eta (s_i)), c\\phi).\\]","code":"mesh.index <- rspde.make.index(name = \"field\", mesh = prmesh) stk.dat <- inla.stack(   data = list(y = Y), A = list(Abar, 1), tag = \"est\",   effects = list(     c(       mesh.index,       list(Intercept = 1)     ),     list(       seaDist = inla.group(seaDist)     )   ) )"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"model-fitting","dir":"Articles","previous_headings":"Example with real data","what":"Model fitting","title":"R-INLA implementation of the rational SPDE approach","text":"build model using distance sea \\(x_i\\) covariate improper CAR(1) model \\(\\beta_{ij}=1(\\sim j)\\), R-INLA calls random walk order 1. -1 added remove R’s implicit intercept, replaced explicit +Intercept created stack. fit model proceed standard SPDE approach simply call inla(). noteworthy can performance enhancement using argument inla.mode = \"experimental\". argued R-INLA’s man page, features available inla.mode=\"experimental\", need use \"classic\" mode (default mode) instead \"experimental\" whenever predictions.","code":"f.s <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model) rspde_fit <- inla(f.s,   family = \"Gamma\", data = inla.stack.data(stk.dat),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE),             inla.mode = \"experimental\" )"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"inla-results","dir":"Articles","previous_headings":"Example with real data","what":"INLA results","title":"R-INLA implementation of the rational SPDE approach","text":"can look summaries posterior distributions parameters, example fixed effects (.e. intercept) hyper-parameters (.e. dispersion gamma likelihood, precision RW1, parameters spatial field): Let \\(\\theta_1 = \\textrm{Theta1}\\), \\(\\theta_2=\\textrm{Theta2}\\) \\(\\theta_3=\\textrm{Theta3}\\). terms SPDE \\[(\\kappa^2 - \\Delta)^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(\\alpha = \\nu + d/2\\), \\[\\tau = \\exp(\\theta_1),\\quad \\kappa = \\exp(\\theta_2), \\] default \\[\\nu = 4\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] number 4 comes upper bound \\(\\nu\\), discussed later vignette. general, \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big),\\] \\(\\nu_{UB}\\) value upper bound smoothness parameter \\(\\nu\\). Another choice prior \\(\\nu\\) truncated lognormal distribution also discussed later vignette.","code":"summary(rspde_fit) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 4.09, Running = 34.5, Post = 0.0912, Total = 38.7  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 0.648 0.018      0.613    0.648      0.682 0.648   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations    13.35    0.705     11.981 ## Precision for seaDist                          10086.20 7593.545   2443.350 ## Theta1 for field                                  -1.48    0.355     -2.304 ## Theta2 for field                                   1.23    0.104      0.997 ## Theta3 for field                                  -0.76    0.189     -1.198 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.340     14.769   13.343 ## Precision for seaDist                          7999.001  30240.202 5298.668 ## Theta1 for field                                 -1.479     -0.647   -1.473 ## Theta2 for field                                  1.228      1.456    1.226 ## Theta3 for field                                 -0.758     -0.322   -0.761 ##  ## Marginal log-Likelihood:  -1263.44  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"rspde-inla-results","dir":"Articles","previous_headings":"Example with real data","what":"rSPDE-INLA results","title":"R-INLA implementation of the rational SPDE approach","text":"can obtain outputs respect parameters original scale using function rspde.result(): can also plot posterior densities:  function reminiscent inla.spde.result() function main difference summary() plot() methods implemented.","code":"result_fit <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result_fit) ##           mean       sd 0.025quant 0.5quant 0.975quant     mode ## tau   0.243355 0.088045   0.114162 0.228871    0.45600 0.202042 ## kappa 3.428950 0.354349   2.788060 3.409940    4.17826 3.372760 ## nu    1.280110 0.162199   0.979036 1.274190    1.61416 1.262110 par(mfrow = c(1, 3)) plot(result_fit, caption = c(\"tau\", \"kappa\", \"nu\"))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"predictions","dir":"Articles","previous_headings":"Example with real data","what":"Predictions","title":"R-INLA implementation of the rational SPDE approach","text":"Let us now obtain predictions (.e. kriging) expected precipitation dense grid region. begin creating grid want predictions. end, can use rspde.mesh.projector() function. function arguments function inla.mesh.projector(), difference rSPDE version also argument nu argument rspde_order. Thus, proceed fashion R-INLA’s standard SPDE implementation: lattice contains 150 × 100 locations. One can easily change resolution kriging prediction changing nxy. Let us find cells outside region interest plot estimates . Let us plot locations prediction:  Now, ways calculate kriging prediction. simplest way evaluate mean individual random effects linear predictor calculate exponential sum (since \\(\\mu(s)=\\exp(\\eta(s))\\) ). accurate way calculate prediction jointly estimation, unfortunately quite computationally expensive prediction fine grid. However, illustration, proceed option show one can . end, first, link prediction coordinates mesh nodes \\(\\) matrix Since using distance sea covariate, also calculate covariate prediction locations. now make stack prediction locations. data prediction locations, set y= NA. join stack estimation stack. joint estimation takes , therefore turn computation certain things interested , marginals random effect. also use simplified integration strategy (actually using posterior mode hyper-parameters) command control.inla = list(int.strategy = \"eb\"), .e. empirical Bayes. Since predictions, use R-INLA’s experimental mode. extract indices prediction nodes extract mean standard deviation response: Finally, plot results:","code":"nxy <- c(150, 100) projgrid <- rspde.mesh.projector(prmesh,   xlim = range(PRborder[, 1]),   ylim = range(PRborder[, 2]), dims = nxy ) xy.in <- inout(projgrid$lattice$loc, cbind(PRborder[, 1], PRborder[, 2])) coord.prd <- projgrid$lattice$loc[xy.in, ] plot(coord.prd, type = \"p\", cex = 0.1) lines(PRborder) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\") A.prd <- projgrid$proj$A[xy.in, ] seaDist.prd <- apply(spDists(coord.prd,   PRborder[1034:1078, ],   longlat = TRUE ), 1, min) ef.prd <- list(   c(mesh.index, list(Intercept = 1)),   list(     long = inla.group(coord.prd[       ,       1     ]), lat = inla.group(coord.prd[, 2]),     seaDist = inla.group(seaDist.prd)   ) ) stk.prd <- inla.stack(   data = list(y = NA),   A = list(A.prd, 1), tag = \"prd\",   effects = ef.prd ) stk.all <- inla.stack(stk.dat, stk.prd) rspde_fitprd <- inla(f.s,   family = \"Gamma\",   data = inla.stack.data(stk.all),   control.predictor = list(     A = inla.stack.A(stk.all),     compute = TRUE, link = 1   ),   control.compute = list(     return.marginals = FALSE,     return.marginals.predictor = FALSE   ),   control.inla = list(int.strategy = \"eb\") ) id.prd <- inla.stack.index(stk.all, \"prd\")$data sd.prd <- m.prd <- matrix(NA, nxy[1], nxy[2]) m.prd[xy.in] <- rspde_fitprd$summary.fitted.values$mean[id.prd] sd.prd[xy.in] <- rspde_fitprd$summary.fitted.values$sd[id.prd] # Plot the predictions grid.arrange(   levelplot(m.prd,     col.regions = tim.colors(99),     xlab = \"\", ylab = \"\", main = \"mean\",     scales = list(draw = FALSE)   ),   levelplot(sd.prd,     col.regions = topo.colors(99),     xlab = \"\", ylab = \"\", scales = list(draw = FALSE),     main = \"standard deviation\"   ) )"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"an-example-with-replicates","dir":"Articles","previous_headings":"","what":"An example with replicates","title":"R-INLA implementation of the rational SPDE approach","text":"example simulate data replicates. use example considered Rational approximation rSPDE package vignette (difference way data organized). also refer reader vignette description function matern.operators(), along methods (instance, simulate() method).","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"simulating-the-data","dir":"Articles","previous_headings":"An example with replicates","what":"Simulating the data","title":"R-INLA implementation of the rational SPDE approach","text":"Let us consider simple Gaussian linear model 30 independent replicates latent spatial field \\(x(\\mathbf{s})\\), observed \\(m\\) locations, \\(\\{\\mathbf{s}_1 , \\ldots , \\mathbf{s}_m \\}\\), replicate. \\(= 1,\\ldots,m,\\) \\[\\begin{align}  y_i &= x_1(\\mathbf{s}_i)+\\varepsilon_i,\\\\ \\vdots &= \\vdots\\\\  y_{+29m} &= x_{30}(\\mathbf{s}_i) + \\varepsilon_{+29m}, \\end{align}\\] \\(\\varepsilon_1,\\ldots,\\varepsilon_{30m}\\) iid normally distributed mean 0 standard deviation 0.1. use basis function representation \\(x(\\cdot)\\) define \\(\\) matrix linking point locations mesh. also need account fact 30 replicates locations. end, \\(\\) matrix need can generated inla.spde.make.() function. reason sampling \\(x(\\cdot)\\) directly latent vector described introduction Rational approximation rSPDE package vignette. begin creating mesh:  compute \\(\\) matrix, needed simulation, connects observation locations mesh: Notice simulated data, use \\(\\) matrix inla.spde.make.() function. now simulate latent process standard deviation \\(\\sigma=1\\) range \\(0.1\\). use \\(\\nu=0.5\\) model exponential covariance function. end create model object matern.operators() function: details function can found Rational approximation rSPDE package vignette. simulate latent process need use simulate() method operator_information object. obtain simulated data \\(y\\) connecting \\(\\) matrix adding gaussian noise. first replicate simulated random field well observation locations shown following figure.","code":"m <- 200 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   offset = c(0.1, 0.4),   max.edge = c(0.05, 0.5) ) plot(mesh_2d, main = \"\") points(loc_2d_mesh[, 1], loc_2d_mesh[, 2]) n.rep <- 30 A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh,   index = rep(1:m, times = n.rep),   repl = rep(1:n.rep, each = m) ) nu <- 0.5 sigma <- 1 range <- 0.1 kappa <- sqrt(8 * nu) / range tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi) * gamma(nu + 1))) d <- 2 operator_information <- matern.operators(   mesh = mesh_2d,   nu = nu,   kappa = kappa,   sigma = sigma,   m = 2 ) set.seed(1) u <- simulate(operator_information, nsim = n.rep) y <- as.vector(A %*% as.vector(u)) +   rnorm(m * n.rep) * 0.1 opar <- par(mfrow = c(1, 2), mgp = c(1.2, 0.5, 0),    mar = c(2, 2, 0.5, 0.5) + 0.1) proj <- inla.mesh.projector(mesh_2d, dims = c(100, 100)) image(inla.mesh.project(proj, field = as.vector(u[, 1])),   xlab = \"\", ylab = \"\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) plot(loc_2d_mesh[, 1], loc_2d_mesh[, 2],   cex = 0.2, pch = 16, xlab = \"\", ylab = \"\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) par(opar)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"fitting-the-r-inla-rspde-model","dir":"Articles","previous_headings":"An example with replicates","what":"Fitting the R-INLA rSPDE model","title":"R-INLA implementation of the rational SPDE approach","text":"Let us use rational SPDE approach fit data. begin creating \\(\\) matrix index replicates, inla.stack object. important notice since replicates provide index repl arguments rspde.make.() function, also argument n.repl rspde.make.index() function. behave identically R-INLA’s counterparts, namely, inla.spde.make.() inla.make.index(). now create model object. Finally, create formula fit. extremely important forget replicate argument building formula inla() function produce warning might fit meaningless model. can get summary: summary user’s scale:","code":"Abar.rep <- rspde.make.A(   mesh = mesh_2d, loc = loc_2d_mesh, index = rep(1:m, times = n.rep),   repl = rep(1:n.rep, each = m) ) mesh.index.rep <- rspde.make.index(   name = \"field\", mesh = mesh_2d,   n.repl = n.rep )  st.dat.rep <- inla.stack(   data = list(y = y),   A = Abar.rep,   effects = mesh.index.rep ) rspde_model.rep <- rspde.matern(mesh = mesh_2d) f.rep <-   y ~ -1 + f(field,     model = rspde_model.rep,     replicate = field.repl   ) rspde_fit.rep <-   inla(f.rep,     data = inla.stack.data(st.dat.rep),     family = \"gaussian\",     control.predictor =       list(A = inla.stack.A(st.dat.rep)),             inla.mode = \"experimental\"   ) summary(rspde_fit.rep) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.76, Running = 207, Post = 1.67, Total = 213  ## Random effects: ##   Name     Model ##     field RGeneric2 ##  ## Model hyperparameters: ##                                          mean    sd 0.025quant 0.5quant ## Precision for the Gaussian observations 91.83 4.677      83.75    91.47 ## Theta1 for field                        -3.04 0.099      -3.23    -3.04 ## Theta2 for field                         3.06 0.034       2.99     3.06 ## Theta3 for field                        -1.60 0.045      -1.69    -1.60 ##                                         0.975quant  mode ## Precision for the Gaussian observations     102.19 90.16 ## Theta1 for field                             -2.84 -3.05 ## Theta2 for field                              3.12  3.06 ## Theta3 for field                             -1.52 -1.60 ##  ## Marginal log-Likelihood:  -4400.97  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit_rep <- rspde.result(rspde_fit.rep, \"field\", rspde_model.rep) summary(result_fit_rep) ##             mean        sd 0.025quant  0.5quant 0.975quant      mode ## tau    0.0481594 0.0047997  0.0397772  0.047759   0.058562  0.046833 ## kappa 21.2811000 0.7095750 19.8889000 21.283700  22.673900 21.306300 ## nu     0.6713700 0.0251117  0.6215060  0.671698   0.720070  0.673368 result_df <- data.frame(   parameter = c(\"tau\", \"kappa\", \"nu\"),   true = c(tau, kappa, nu),   mean = c(     result_fit_rep$summary.tau$mean,     result_fit_rep$summary.kappa$mean,     result_fit_rep$summary.nu$mean   ),   mode = c(     result_fit_rep$summary.tau$mode,     result_fit_rep$summary.kappa$mode,     result_fit_rep$summary.nu$mode   ) ) print(result_df) ##   parameter        true        mean        mode ## 1       tau  0.08920621  0.04815936  0.04683297 ## 2     kappa 20.00000000 21.28112714 21.30628437 ## 3        nu  0.50000000  0.67136966  0.67336818"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"further-options-of-the-rspde-inla-implementation","dir":"Articles","previous_headings":"","what":"Further options of the rSPDE-INLA implementation","title":"R-INLA implementation of the rational SPDE approach","text":"now discuss arguments introduced R-INLA implementation rational approximation present R-INLA’s standard SPDE implementation. case provide illustrative example.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-upper-bound-for-the-smoothness-parameter","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the upper bound for the smoothness parameter","title":"R-INLA implementation of the rational SPDE approach","text":"fit rspde.matern() model need provide upper bound smoothness parameter \\(\\nu\\). reason sparsity precision matrix kept fixed R-INLA’s estimation higher value \\(\\nu\\) denser precision matrix gets. means higher value \\(\\nu\\), higher computational cost fit model. Therefore, ideally, want choose upper bound \\(\\nu\\) small possible. change value upper bound smoothness parameter, must change argument nu_upper_bound. default value nu_upper_bound 4. common choices nu_upper_bound 2 1. clear discussion smaller value nu_upper_bound faster estimation procedure . However, choose value nu_upper_bound low, “correct” value \\(\\nu\\) might belong interval \\((0,\\nu_{UB})\\), \\(\\nu_{UB}\\) value nu_upper_bound. Hence, one might forced increase nu_upper_bound estimate , , obviously increase computational cost need one estimation. Let us illustrate considering model considered precipitation Paraná region Brazil consider nu_upper_bound equal 2, generally good choice nu_upper_bound. simply use function rspde.matern() argument nu_upper_bound set 2: Since considering default rspde_order, \\(\\) matrix mesh index objects previous ones. Let us update formula fit model: Let us see summary fit: Let us compare cost previous fit, default value nu_upper_bound 4: can see fit nu_upper_bound equal 2 considerably faster. Finally, let us get result results field see estimate \\(\\nu\\):","code":"rspde_model_2 <- rspde.matern(mesh = prmesh, nu_upper_bound = 2) f.s.2 <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_2)  rspde_fit_2 <- inla(f.s.2,   family = \"Gamma\", data = inla.stack.data(stk.dat),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE),             inla.mode = \"experimental\" ) summary(rspde_fit_2) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.7, Running = 10.3, Post = 0.0621, Total = 14.1  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 0.647 0.019       0.61    0.647      0.684 0.647   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                     mean       sd 0.025quant ## Precision parameter for the Gamma observations    13.172 9.02e-01      11.47 ## Precision for seaDist                          12506.254 1.15e+04    2442.36 ## Theta1 for field                                  -1.144 6.25e-01      -2.27 ## Theta2 for field                                   1.104 3.33e-01       0.43 ## Theta3 for field                                   0.391 5.85e-01      -0.81 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.146   1.50e+01   13.101 ## Precision for seaDist                          9156.581   4.29e+04 5436.028 ## Theta1 for field                                 -1.183   1.78e-01   -1.330 ## Theta2 for field                                  1.111   1.74e+00    1.138 ## Theta3 for field                                  0.413   1.49e+00    0.492 ##  ## Marginal log-Likelihood:  -1263.71  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') # nu_upper_bound = 4 rspde_fit$cpu.used ##         Pre     Running        Post       Total  ##  4.08564305 34.52792311  0.09124804 38.70481420 # nu_upper_bound = 2 rspde_fit_2$cpu.used ##         Pre     Running        Post       Total  ##  3.69600582 10.29575014  0.06206989 14.05382586 result_fit_2 <- rspde.result(rspde_fit_2, \"field\", rspde_model_2) summary(result_fit_2) ##           mean       sd 0.025quant 0.5quant 0.975quant     mode ## tau   0.390665 0.291681   0.104260  0.30534    1.18281 0.204659 ## kappa 3.183090 1.059420   1.546810  3.03967    5.66617 2.757610 ## nu    1.180780 0.264122   0.619875  1.20438    1.62848 1.279680"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-order-of-the-rational-approximation","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the order of the rational approximation","title":"R-INLA implementation of the rational SPDE approach","text":"change order rational approximation set argument rspde_order desired value. current available possibilities 1,2,3,…, 8. higher order rational approximation, accurate results , however, higher computational cost . default rspde_order 2 generally good choice reasonably accurate. See vignette Rational approximation rSPDE package details order rational approximation comparison Matérn covariance. Let us fit model covariance-based rational approximation order 3. Since changing order rational approximation, , changing rspde_order argument, need recompute \\(\\) matrix mesh index. Therefore, proceed follows: build new model: create new \\(\\) matrix: create new index: Now remaining steps : Let us see summary: can see summary computational cost significantly increased. Let us compare cost rspde_order=3 nu_upper_bound=2 cost rspde_order=2 nu_upper_bound=4: Let us now see summary fit original scale: following figure shows posterior marginal densities three parameters:  One can check order rational approximation using rational.order() function. also allows another way change order rational order, using corresponding rational.order<-() function. rational.order() rational.order<-() functions can applied inla.rspde object, matrix index objects. check models: check matrices: check indexes: Let us now change order rspde_model object 1: Let us fit new model: summary:","code":"rspde_model_order_3 <- rspde.matern(mesh = prmesh,    rspde_order = 3,   nu_upper_bound = 2 ) Abar_3 <- rspde.make.A(mesh = prmesh, loc = coords, rspde_order = 3) mesh.index.3 <- rspde.make.index(   name = \"field\", mesh = prmesh,   rspde_order = 3 ) stk.dat.3 <- inla.stack(   data = list(y = Y), A = list(Abar_3, 1), tag = \"est\",   effects = list(     c(       mesh.index.3,       list(Intercept = 1)     ),     list(       long = inla.group(coords[, 1]),       lat = inla.group(coords[, 2]),       seaDist = inla.group(seaDist)     )   ) )  f.s.3 <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_order_3)  rspde_fit_order_3 <- inla(f.s.3,   family = \"Gamma\", data = inla.stack.data(stk.dat.3),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat.3), compute = TRUE),             inla.mode = \"experimental\" ) summary(rspde_fit_order_3) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.86, Running = 18.6, Post = 0.0863, Total = 22.6  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 0.486 0.013       0.46    0.486      0.512 0.486   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.231    0.864     11.615 ## Precision for seaDist                          9335.847 6942.089   2460.482 ## Theta1 for field                                 -1.329    0.399     -2.379 ## Theta2 for field                                  1.188    0.111      0.871 ## Theta3 for field                                  0.424    0.381     -0.699 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.200     15.022   13.134 ## Precision for seaDist                          7404.106  27783.468 4997.611 ## Theta1 for field                                 -0.890     -0.151   -1.385 ## Theta2 for field                                  1.081      1.473    1.204 ## Theta3 for field                                  0.006      1.424    0.476 ##  ## Marginal log-Likelihood:  -1262.20  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') # nu_upper_bound = 4 rspde_fit$cpu.used ##         Pre     Running        Post       Total  ##  4.08564305 34.52792311  0.09124804 38.70481420 # nu_upper_bound = 2 rspde_fit_order_3$cpu.used ##        Pre    Running       Post      Total  ##  3.8577731 18.6454580  0.0863049 22.5895360 result_fit_order_3 <- rspde.result(rspde_fit_order_3, \"field\", rspde_model_order_3) summary(result_fit_order_3) ##           mean       sd 0.025quant 0.5quant 0.975quant    mode ## tau   0.286857 0.124754   0.127972 0.259581   0.608791 0.21858 ## kappa 3.300000 0.358831   2.602420 3.297540   4.011450 3.29520 ## nu    1.202780 0.177288   0.816694 1.217440   1.506660 1.25119 par(mfrow = c(1, 3)) plot(result_fit_order_3, caption = c(\"tau\", \"kappa\", \"nu\")) rational.order(rspde_model) ## [1] 2 rational.order(rspde_model_order_3) ## [1] 3 rational.order(Abar) ## [1] 2 rational.order(Abar_3) ## [1] 3 rational.order(mesh.index) ## [1] 2 rational.order(mesh.index.3) ## [1] 3 rational.order(rspde_model) <- 1 rational.order(Abar) <- 1 rational.order(mesh.index) <- 1 f.s.1 <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model)  stk.dat.1 <- inla.stack(   data = list(y = Y), A = list(Abar, 1), tag = \"est\",   effects = list(     c(       mesh.index,       list(Intercept = 1)     ),     list(       long = inla.group(coords[, 1]),       lat = inla.group(coords[, 2]),       seaDist = inla.group(seaDist)     )   ) )  rspde_fit_order_1 <- inla(f.s.1,   family = \"Gamma\", data = inla.stack.data(stk.dat.1),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat.1), compute = TRUE),             inla.mode = \"experimental\" ) summary(rspde_fit_order_1) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 4, Running = 15.1, Post = 0.0598, Total = 19.1  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 0.972 0.028      0.918    0.972      1.027 0.972   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.040    0.543     11.985 ## Precision for seaDist                          6737.957 1589.683   4056.996 ## Theta1 for field                                 -1.188    0.445     -2.299 ## Theta2 for field                                  1.120    0.147      0.763 ## Theta3 for field                                 -0.879    0.248     -1.491 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.031     14.147   13.019 ## Precision for seaDist                          6562.542  10533.973 6239.914 ## Theta1 for field                                 -1.229     -0.087   -1.173 ## Theta2 for field                                  1.132      1.480    1.115 ## Theta3 for field                                 -0.856     -0.261   -0.887 ##  ## Marginal log-Likelihood:  -1262.73  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"estimating-models-with-fixed-smoothness","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Estimating models with fixed smoothness","title":"R-INLA implementation of the rational SPDE approach","text":"can fix smoothness, say \\(\\nu\\), model providing non-NULL positive value nu. smoothness, \\(\\nu\\), fixed, can two possibilities: \\(\\alpha = \\nu + d/2\\) integer; \\(\\alpha = \\nu + d/2\\) integer. first case, .e., \\(\\alpha\\) integer, less computational cost. Furthermore, \\(\\) matrix different \\(\\) matrix non-integer \\(\\alpha\\). \\(\\) matrix values \\(\\nu\\) \\(\\alpha\\) integer. , \\(\\) matrix cases need computed . holds index obtained rspde.make.index() function. second case \\(\\) matrix depends order rational approximation \\(\\nu\\). Therefore, matrix \\(\\) already computed rspde_order, \\(\\) matrix values \\(\\nu\\) \\(\\alpha\\) non-integer rspde_order. holds index obtained rspde.make.index() function. \\(\\nu\\) fixed, parameters returned R-INLA \\[\\kappa = \\exp(\\theta_1)\\quad\\hbox{}\\quad\\tau = \\exp(\\theta_2).\\] now provide illustrations scenarios. also noteworthy just case estimate \\(\\nu\\), can also change order rational approximation changing value rspde_order. illustrations fixed \\(\\nu\\) , consider order rational approximation 2, , default order.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"estimating-models-with-fixed-smoothness-and-non-integer-alpha","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation > Estimating models with fixed smoothness","what":"Estimating models with fixed smoothness and non-integer \\(\\alpha\\)","title":"R-INLA implementation of the rational SPDE approach","text":"Recall : \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] Thus, illustrate, let us consider fixed \\(\\nu\\) given mean \\(\\nu\\) obtained first model considered vignette, namely, fit given rspde_fit, approximately \\(\\nu = 1.21\\). Notice \\(\\nu\\), value \\(\\alpha\\) non-integer, can use \\(\\) matrix index first fitted model, also order 2. Therefore, build new model set nu 1.21: Let us now fit model: summary: Now, summary original scale:","code":"rspde_model_fix <- rspde.matern(mesh = prmesh, rspde_order = 2,   nu = 1.21 ) f.s.fix <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_fix)  rspde_fix <- inla(f.s.fix,   family = \"Gamma\", data = inla.stack.data(stk.dat),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE),,             inla.mode = \"experimental\" ) summary(rspde_fix) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.88, Running = 8.56, Post = 0.0671, Total = 12.5  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 0.648 0.017      0.614    0.648      0.682 0.648   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                   mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.23    0.906     11.534 ## Precision for seaDist                          9788.70 8061.276   2457.162 ## Theta1 for field                                 -1.34    0.335     -1.995 ## Theta2 for field                                  1.19    0.310      0.571 ##                                                0.5quant 0.975quant    mode ## Precision parameter for the Gamma observations    13.20     15.101   13.13 ## Precision for seaDist                           7451.48  31190.928 4817.44 ## Theta1 for field                                  -1.34     -0.674   -1.35 ## Theta2 for field                                   1.20      1.792    1.21 ##  ## Marginal log-Likelihood:  -1263.56  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fix <- rspde.result(rspde_fix, \"field\", rspde_model_fix) summary(result_fix) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## tau   0.276386 0.0950585   0.136917 0.260582   0.506512 0.231598 ## kappa 3.453110 1.0759600   1.780730 3.308530   5.971600 3.031490"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"estimating-models-with-fixed-smoothness-and-integer-alpha","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation > Estimating models with fixed smoothness","what":"Estimating models with fixed smoothness and integer \\(\\alpha\\)","title":"R-INLA implementation of the rational SPDE approach","text":"Since dimension \\(d=2\\), \\(\\nu>0\\), smallest value \\(\\nu\\) makes \\(\\alpha = \\nu + 1\\) integer \\(\\nu=1\\). value also close estimated mean first model fitted enclosed posterior marginal density \\(\\nu\\) first fit. Therefore, let us fit model \\(\\nu=1\\). end need compute new \\(\\) matrix: new index: create new model (remember set nu=1): remaining standard: Let us check summary: check summary user’s scale:","code":"Abar.int <- rspde.make.A(   mesh = prmesh, loc = coords,   nu = 1 ) mesh.index.int <- rspde.make.index(   name = \"field\", mesh = prmesh,   nu = 1 ) rspde_model_fix_int1 <- rspde.matern(mesh = prmesh,   nu = 1 ) stk.dat.int <- inla.stack(   data = list(y = Y), A = list(Abar.int, 1), tag = \"est\",   effects = list(     c(       mesh.index.int,       list(Intercept = 1)     ),     list(       long = inla.group(coords[, 1]),       lat = inla.group(coords[, 2]),       seaDist = inla.group(seaDist)     )   ) )  f.s.fix.int.1 <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_fix_int1)  rspde_fix_int_1 <- inla(f.s.fix.int.1,   family = \"Gamma\",   data = inla.stack.data(stk.dat.int), verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(     A = inla.stack.A(stk.dat.int),     compute = TRUE   ),             inla.mode = \"experimental\" ) summary(rspde_fix_int_1) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.91, Running = 3.25, Post = 0.049, Total = 7.21  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 1.945 0.054      1.839    1.945      2.051 1.945   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                     mean       sd 0.025quant ## Precision parameter for the Gamma observations    13.251    0.908     11.536 ## Precision for seaDist                          10563.337 9591.075   2569.101 ## Theta1 for field                                  -0.862    0.309     -1.451 ## Theta2 for field                                   1.033    0.352      0.311 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations    13.23     15.111   13.188 ## Precision for seaDist                           7709.66  35836.885 4794.393 ## Theta1 for field                                  -0.87     -0.233   -0.899 ## Theta2 for field                                   1.04      1.697    1.087 ##  ## Marginal log-Likelihood:  -1262.65  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') rspde_result_int <- rspde.result(rspde_fix_int_1, \"field\", rspde_model_fix_int1) summary(rspde_result_int) ##           mean       sd 0.025quant 0.5quant 0.975quant     mode ## tau   0.442992 0.141877   0.235703 0.418676   0.787619 0.374662 ## kappa 2.984450 1.042960   1.374400 2.845580   5.423200 2.564120"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-priors","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the priors","title":"R-INLA implementation of the rational SPDE approach","text":"begin recalling fitted rSPDE model R-INLA contains parameters \\(\\textrm{Theta1}\\), \\(\\textrm{Theta2}\\) \\(\\textrm{Theta3}\\). Let, , \\(\\theta_1 = \\textrm{Theta1}\\), \\(\\theta_2=\\textrm{Theta2}\\) \\(\\theta_3=\\textrm{Theta3}\\). terms SPDE \\[(\\kappa^2 - \\Delta)^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(\\alpha = \\nu + d/2\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-priors-of-tau-and-kappa","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation > Changing the priors","what":"Changing the priors of \\(\\tau\\) and \\(\\kappa\\)","title":"R-INLA implementation of the rational SPDE approach","text":"begin dealing \\(\\tau\\) \\(\\kappa\\). \\[\\tau = \\exp(\\theta_1),\\quad \\kappa = \\exp(\\theta_2).\\] rspde.matern() function assumes lognormal prior distribution \\(\\tau\\) \\(\\kappa\\). prior distribution obtained assuming \\(\\theta_1\\) \\(\\theta_2\\) follow normal distributions. default assume \\(\\theta_1\\) \\(\\theta_2\\) independent follow normal distributions \\(\\theta_1\\sim N(\\log(\\tau_0), 10)\\) \\(\\theta_2\\sim N(\\log(\\kappa_0), 10)\\). \\(\\kappa_0\\) suitably defined terms mesh \\(\\tau_0\\) defined terms \\(\\kappa_0\\) prior smoothness parameter. one wants define prior \\[\\theta_1 \\sim N(\\text{mean_theta_1}, \\text{sd_theta_1}),\\] one can simply set argument prior.tau = list(meanlog=mean_theta_1, sdlog=sd_theta_1). Analogously, define prior \\[\\theta_2 \\sim N(\\text{mean_theta_2}, \\text{sd_theta_2}),\\] one can set argument prior.kappa = list(meanlog=mean_theta_2, sdlog=sd_theta_2). important mention , default, initial values \\(\\tau\\) \\(\\kappa\\) \\(\\exp(\\text{mean_theta_1})\\) \\(\\exp(\\text{mean_theta_2})\\), respectively. , user change parameters, also change initial values, initial values \\(\\tau\\) \\(\\kappa\\) , respectively, \\(\\tau_0\\) \\(\\kappa_0\\). one sets prior.tau = list(meanlog=mean_theta_1), prior \\(\\theta_1\\) \\[\\theta_1 \\sim N(\\text{mean_theta_1}, 1),\\] whereas, one sets, prior.tau = list(sdlog=sd_theta_1), prior \\[\\theta_1 \\sim N(\\log(\\tau_0), \\text{sd_theta_1}).\\] Analogously, one sets prior.kappa = list(meanlog=mean_theta_2), prior \\(\\theta_2\\) \\[\\theta_2 \\sim N(\\text{mean_theta_2}, 1),\\] whereas, one sets, prior.kappa = list(sdlog=sd_theta_2), prior \\[\\theta_2 \\sim N(\\log(\\kappa_0), \\text{sd_theta_2}).\\]","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-prior-of-nu","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation > Changing the priors","what":"Changing the prior of \\(\\nu\\)","title":"R-INLA implementation of the rational SPDE approach","text":"Finally, let us consider smoothness parameter \\(\\nu\\). default, assume \\(\\nu\\) follows beta distribution interval \\((0,\\nu_{UB})\\), \\(\\nu_{UB}\\) upper bound \\(\\nu\\), mean \\(\\nu_0=\\min\\{1, \\nu_{UB}/2\\}\\) variance \\(\\frac{\\nu_0(\\nu_{UB}-\\nu_0)}{1+\\phi_0}\\), call \\(\\phi_0\\) precision parameter, whose default value \\[\\phi_0 = \\max\\Big\\{\\frac{\\nu_{UB}}{\\nu_0}, \\frac{\\nu_{UB}}{\\nu_{UB}-\\nu_0}\\Big\\} + \\phi_{inc}.\\] parameter \\(\\phi_{inc}\\) increment ensure prior beta density boundary values equal zero (boundary values defined either continuity limits). default value \\(\\phi_{inc}\\) 1. value \\(\\phi_{inc}\\) can changed changing argument nu.prec.inc rspde.matern() function. higher value \\(\\phi_{inc}\\) (, value nu.prec.inc) informative prior distribution becomes. Let us denote beta distribution support \\((0,\\nu_{UB})\\), mean \\(\\mu\\) precision parameter \\(\\phi\\) \\(\\mathcal{B}_{\\nu_{UB}}(\\mu,\\phi)\\). want \\(\\nu\\) prior \\[\\nu \\sim \\mathcal{B}_{\\nu_{UB}}(\\text{nu_1},\\text{prec_1}),\\] one simply needs set prior.nu = list(mean=nu_1, prec=prec_1). one sets prior.nu = list(mean=nu_1), \\(\\nu\\) prior \\[\\nu \\sim \\mathcal{B}_{\\nu_{UB}}(\\text{nu_1},\\phi_1),\\] \\[\\phi_1 = \\max\\Big\\{\\frac{\\nu_{UB}}{\\text{nu_1}}, \\frac{\\nu_{UB}}{\\nu_{UB}-\\text{nu_1}}\\Big\\} + \\text{nu.prec.inc}.\\] one sets prior.nu = list(prec=prec_1), \\(\\nu\\) prior \\[\\nu\\sim \\mathcal{B}_{\\nu_{UB}}(\\nu_0, \\text{prec_1}).\\] also noteworthy , terms R-INLA’s parameters, \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] important mention , default, beta prior distribution chosen smoothness parameter \\(\\nu\\), initial value \\(\\nu\\) mean prior beta distribution. , user change parameter, also change initial value, initial value \\(\\nu\\) \\(\\min\\{1,\\nu_{UB}/2\\}\\). can another possibility prior distribution \\(\\nu\\), namely, truncated lognormal distribution. truncated lognormal distribution defined following sense. assume \\(\\log(\\nu)\\) prior distribution given truncated normal distribution support \\((-\\infty,\\log(\\nu_{UB}))\\), \\(\\nu_{UB}\\) upper bound \\(\\nu\\), location parameter \\(\\mu_0 =\\log(\\nu_0)= \\log\\Big(\\min\\{1,\\nu_{UB}/2\\}\\Big)\\) scale parameter \\(\\sigma_0 = 1\\). precisely, let \\(\\Phi(\\cdot; \\mu,\\sigma)\\) stand cumulative distribution function (CDF) normal distribution mean \\(\\mu\\) standard deviation \\(\\sigma\\). , \\(\\log(\\nu)\\) cumulative distribution function given \\[F_{\\log(\\nu)}(x) = \\frac{\\Phi(x;\\mu_0,\\sigma_0)}{\\Phi(\\nu_{UB})},\\quad x\\leq \\nu_{UB},\\] \\(F_{\\log(\\nu)}(x) = 1\\) \\(x>\\nu_{UB}\\). call \\(\\mu_0\\) \\(\\sigma_0\\) log-location log-scale parameters \\(\\nu\\), respectively, say \\(\\log(\\nu)\\) follows truncated normal distribution location parameter \\(\\mu_0\\) scale parameter \\(\\sigma_0\\). also assume , terms R-INLA’s parameters, \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] change prior distribution \\(\\nu\\) truncated lognormal distribution, need set argument prior.nu.dist=\"lognormal\". change parameters prior distribution , say, log_nu_1 log_sigma_1, one can simply set prior.nu = list(loglocation=log_nu_1, logscale=sigma_1). one sets prior.nu = list(loglocation=log_nu_1), prior \\(\\theta_3\\) truncated normal normal distribution location parameter log_nu_1 scale parameter 1. Analogously, one sets, prior.nu = list(logscale=sigma_1), prior \\(\\theta_3\\) truncated normal distribution location parameter \\(\\log(\\nu_0)= \\log\\Big(\\min\\{1,\\nu_{UB}/2\\}\\Big)\\) scale parameter sigma_1. important mention , default, truncated lognormal prior distribution chosen smoothness parameter \\(\\nu\\), initial value \\(\\nu\\) exponential log-location parameter \\(\\nu\\). , user change parameter, also change initial value, initial value \\(\\nu\\) \\(\\min\\{1,\\nu_{UB}/2\\}\\). Let us consider example dataset used first model vignette change prior distribution \\(\\nu\\) beta lognormal. Let us also set nu_upper_bound 2. Since change rspde_order fixing \\(\\nu\\), can use \\(\\) matrix index first example. Therefore, update formula fit model: summary: Also, can summary user’s scale: plot posterior marginal densities","code":"rspde_model_ln <- rspde.matern(mesh = prmesh, prior.nu.dist = \"lognormal\",   nu_upper_bound = 2 ) f.s.ln <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_ln)  rspde_fit_ln <- inla(f.s.ln,   family = \"Gamma\", data = inla.stack.data(stk.dat),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE),             inla.mode = \"experimental\" ) summary(rspde_fit_ln) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.91, Running = 11.6, Post = 0.0847, Total = 15.6  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 0.646 0.017      0.612    0.646      0.681 0.646   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations    13.20 9.05e-01     11.514 ## Precision for seaDist                          11748.76 1.13e+04   1272.265 ## Theta1 for field                                  -1.62 6.50e-01     -2.844 ## Theta2 for field                                   1.24 3.16e-01      0.592 ## Theta3 for field                                   0.64 7.07e-01     -0.821 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations    13.17      15.08   13.100 ## Precision for seaDist                           8492.96   41614.49 3557.050 ## Theta1 for field                                  -1.64      -0.29   -1.726 ## Theta2 for field                                   1.25       1.84    1.283 ## Theta3 for field                                   0.67       1.95    0.781 ##  ## Marginal log-Likelihood:  -1264.23  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit_ln <- rspde.result(rspde_fit_ln, \"field\", rspde_model_ln) summary(result_fit_ln) ##           mean       sd 0.025quant 0.5quant 0.975quant     mode ## tau   0.244994 0.183571  0.0587193 0.192873   0.741141 0.126635 ## kappa 3.621670 1.136530  1.8180600 3.485440   6.239760 3.216770 ## nu    1.282330 0.299699  0.6156290 1.323860   1.749460 1.441750 par(mfrow = c(1, 3)) plot(result_fit_ln, caption = c(\"tau\", \"kappa\", \"nu\"))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-starting-values","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the starting values","title":"R-INLA implementation of the rational SPDE approach","text":"starting values used R-INLA’s optimization algorithm can changed setting arguments start.ltau, start.lkappa start.nu. start.ltau initial value \\(\\log(\\tau)\\), , logarithm \\(\\tau\\). start.lkappa inital value \\(\\log(\\kappa)\\), , logarithm \\(\\kappa\\). start.nu initial value \\(\\nu\\). Notice initial value log scale. One can change initial value one parameters. instance, let us consider example precipitation data, rspde_order=3, change initial values ones close fitted value considering default rspde_order (2): Since already computed \\(\\) matrix index rspde_order=3, update formula fit: summary:","code":"rspde_model_order_3_start <- rspde.matern(mesh = prmesh, rspde_order = 3,   nu_upper_bound = 2,   start.lkappa = result_fit$summary.log.kappa$mean,   start.ltau = result_fit$summary.log.tau$mean,   start.nu = result_fit$summary.nu$mean ) f.s.3.start <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_order_3_start)  rspde_fit_order_3_start <- inla(f.s.3.start,   family = \"Gamma\",   data = inla.stack.data(stk.dat.3),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(     A = inla.stack.A(stk.dat.3),     compute = TRUE   ),             inla.mode = \"experimental\" ) summary(rspde_fit_order_3_start) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 4.31, Running = 19.2, Post = 0.102, Total = 23.6  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 0.486 0.012      0.462    0.486      0.511 0.486   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                   mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.29    0.731     11.943 ## Precision for seaDist                          6354.49 2593.231   2669.950 ## Theta1 for field                                 -1.55    0.318     -2.292 ## Theta2 for field                                  1.26    0.085      1.068 ## Theta3 for field                                  0.63    0.337     -0.186 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.253     14.829   13.157 ## Precision for seaDist                          5894.277  12771.551 5066.568 ## Theta1 for field                                 -1.421     -0.775   -1.599 ## Theta2 for field                                  1.246      1.447    1.277 ## Theta3 for field                                  0.499      1.419    0.687 ##  ## Marginal log-Likelihood:  -1262.68  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-type-of-the-rational-approximation","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the type of the rational approximation","title":"R-INLA implementation of the rational SPDE approach","text":"three rational approximations available. BRASIL algorithm (Hofreither 2021)(https://doi.org/10.1007/s11075-020-01042-0), two “versions” Clenshaw-Lord Chebyshev-Pade algorithm, one lower bound zero another lower bound given (Xiong, Simas, Bolin 2022)(https://arxiv.org/abs/2209.04670). type rational approximation can chosen setting type.rational.approx argument rspde.matern function. BRASIL algorithm corresponds choice brasil, Clenshaw-Lord Chebyshev pade zero lower bound non-zero lower bounds given, respectively, choices chebfun chebfunLB. Let us fit model assigning brasil rational approximation. consider model order rational approximation 1: Let us get summary: Finally, similarly order rational approximation, one can check order rational.type() function, assign new type rational.type<-() function. Let us change type rational approximation model rational approximation order 3: Let us get summary:","code":"rspde_model_brasil <- rspde.matern(prmesh, rspde_order = 1,               type.rational.approx = \"brasil\")  f.s.1.brasil <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_brasil)  rspde_fit_order_1_brasil <- inla(f.s.1.brasil,   family = \"Gamma\", data = inla.stack.data(stk.dat.1),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat.1), compute = TRUE),             inla.mode = \"experimental\" ) summary(rspde_fit_order_1_brasil) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 4.09, Running = 11.6, Post = 0.0645, Total = 15.8  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 0.971 0.029      0.915    0.971      1.028 0.971   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.191    0.854     11.575 ## Precision for seaDist                          8425.923 2046.177   5256.577 ## Theta1 for field                                 -0.887    0.288     -1.537 ## Theta2 for field                                  1.008    0.133      0.719 ## Theta3 for field                                 -1.064    0.182     -1.469 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.168     14.942   13.130 ## Precision for seaDist                          8179.966  13695.681 7541.715 ## Theta1 for field                                 -0.854     -0.241   -0.917 ## Theta2 for field                                  0.999      1.299    1.023 ## Theta3 for field                                 -1.082     -0.656   -1.045 ##  ## Marginal log-Likelihood:  -1262.88  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') rational.type(rspde_model) ## [1] \"chebfun\" rational.type(rspde_model_brasil) ## [1] \"brasil\" rational.type(rspde_model_order_3) <- \"brasil\"  f.s.3 <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_order_3)  rspde_fit_order_3_brasil <- inla(f.s.3,   family = \"Gamma\", data = inla.stack.data(stk.dat.3),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat.3), compute = TRUE),             inla.mode = \"experimental\" ) summary(rspde_fit_order_3_brasil) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.85, Running = 24.3, Post = 0.076, Total = 28.2  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 0.486 0.013       0.46    0.486      0.512 0.486   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.188    0.901     11.519 ## Precision for seaDist                          9528.844 7324.100   2433.500 ## Theta1 for field                                 -1.766    0.623     -3.059 ## Theta2 for field                                  1.299    0.241      0.834 ## Theta3 for field                                  0.819    0.577     -0.304 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.151     15.069   13.065 ## Precision for seaDist                          7471.311  29029.430 4960.064 ## Theta1 for field                                 -1.755     -0.551   -1.694 ## Theta2 for field                                  1.295      1.796    1.273 ## Theta3 for field                                  0.808      2.015    0.752 ##  ## Marginal log-Likelihood:  -1262.94  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"choosing-between-the-optimized-and-non-optimized-versions","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Choosing between the optimized and non-optimized versions","title":"R-INLA implementation of the rational SPDE approach","text":"rspde.matern() function optimized version, default non-optimized version. take less time fit optimized object fit non-optimized one. However requires sparsity analysis creating model object. size data small might happen time analyze sparsity plus time fit model larger time fit non-optimized model, require sparsity analysis creating model object. also another option optimized model, sharp argument. sharp argument used optimize TRUE. sharp=TRUE time fit model less time fit model sharp=FALSE. However, sparsity analysis takes time sharp=TRUE sharp=FALSE. Let us create three model objects rspde_order=1 precipitation data compare times. begin creating \\(\\) matrix, index inla.stack object three models use: Now, let us create three models compute time took create model objects: Now, let us fit models: Finally, let us compare times: Therefore, see example one benefits using optimized version.","code":"Abar.1 <- rspde.make.A(mesh = prmesh, loc = coords, rspde_order = 1) mesh.index.1 <- rspde.make.index(name = \"field\", mesh = prmesh, rspde_order = 1) stk.dat.1 <- inla.stack(   data = list(y = Y), A = list(Abar.1, 1), tag = \"est\",   effects = list(     c(       mesh.index.1,       list(Intercept = 1)     ),     list(       long = inla.group(coords[, 1]),       lat = inla.group(coords[, 2]),       seaDist = inla.group(seaDist)     )   ) ) # Creating the optimized and sharp model start_time <- Sys.time() rspde_model_opt_sharp <- rspde.matern(mesh = prmesh,   rspde_order = 1 ) end_time <- Sys.time() time_opt_sharp <- end_time - start_time  # Creating the optimized non-sharp model start_time <- Sys.time() rspde_model_opt_notsharp <- rspde.matern(mesh = prmesh,   rspde_order = 1,   sharp = FALSE ) end_time <- Sys.time() time_opt_notsharp <- end_time - start_time  # Creating the non-optimized model start_time <- Sys.time() rspde_model_nonopt <- rspde.matern(mesh = prmesh,   rspde_order = 1,   optimize = FALSE ) end_time <- Sys.time() time_nonopt <- end_time - start_time f.s.opt.sharp <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_opt_sharp)  rspde_fit_opt_sharp <- inla(f.s.opt.sharp,   family = \"Gamma\",   data = inla.stack.data(stk.dat.1),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(     A = inla.stack.A(stk.dat.1),     compute = FALSE   ), inla.mode = \"experimental\" )  f.s.opt.notsharp <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_opt_notsharp)  rspde_fit_opt_notsharp <- inla(f.s.opt.notsharp,   family = \"Gamma\",   data = inla.stack.data(stk.dat.1),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(     A = inla.stack.A(stk.dat.1),     compute = FALSE   ),             inla.mode = \"experimental\" )  f.s.nonopt <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_nonopt)  rspde_fit_nonopt <- inla(f.s.nonopt,   family = \"Gamma\",   data = inla.stack.data(stk.dat.1),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(     A = inla.stack.A(stk.dat.1),     compute = FALSE   ),             inla.mode = \"experimental\" ) `Time to create model` <- c(time_opt_sharp, time_opt_notsharp, time_nonopt) `Time to fit the model` <- c(   rspde_fit_opt_sharp$cpu.used[[2]],   rspde_fit_opt_notsharp$cpu.used[[2]],   rspde_fit_nonopt$cpu.used[[2]] ) `Total time` <- `Time to create model` + `Time to fit the model` Model <- c(\"Opt & sharp\", \"Opt & not sharp\", \"Non-opt\") result_table <- data.frame(   Model, `Time to create model`,   `Time to fit the model`,   `Total time` ) result_table ##             Model Time.to.create.model Time.to.fit.the.model    Total.time ## 1     Opt & sharp        1.414815 secs              12.72232 14.13713 secs ## 2 Opt & not sharp        1.366362 secs              17.19297 18.55933 secs ## 3         Non-opt        1.153486 secs              26.50389 27.65738 secs"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"inlabru implementation of the rational SPDE approach","text":"vignette present inlabru implementation covariance-based rational SPDE approach. technical details covariance-based approach, see Rational approximation rSPDE package vignette (Xiong, Simas, Bolin 2022)(https://www.tandfonline.com/doi/full/10.1080/10618600.2019.1665537). begin providing step--step illustration use implementation. end consider real world data set consists precipitation measurements Paraná region Brazil. initial model fitting, show change parameters model. end, also provide example replicates. examples vignette R-INLA implementation rational SPDE approach vignette. case, important mention one can improve performance using PARDISO solver. Please, go https://www.pardiso-project.org/r-inla/#license apply license. Also, use inla.pardiso() instructions enable PARDISO sparse library.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"an-example-with-real-data","dir":"Articles","previous_headings":"","what":"An example with real data","title":"inlabru implementation of the rational SPDE approach","text":"illustrate implementation rSPDE inlabru consider dataset available R-INLA. data also used illustrate SPDE approach, see instance book Advanced Spatial Modeling Stochastic Partial Differential Equations Using R INLA also vignette Spatial Statistics using R-INLA Gaussian Markov random fields. See also (Lindgren, Rue, Lindström 2011)(https://rss.onlinelibrary.wiley.com/doi/full/10.1111/j.1467-9868.2011.00777.x) theoretical details standard SPDE approach. data consist precipitation measurements Paraná region Brazil provided Brazilian National Water Agency. data collected 616 gauge stations Paraná state, south Brazil, day 2011.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"an-rspde-model-for-precipitation","dir":"Articles","previous_headings":"An example with real data","what":"An rSPDE model for precipitation","title":"inlabru implementation of the rational SPDE approach","text":"follow vignette Spatial Statistics using R-INLA Gaussian Markov random fields. precipitation data always positive, assume Gamma distributed. R-INLA uses following parameterization Gamma distribution, \\[\\Gamma(\\mu, \\phi): \\pi (y) = \\frac{1}{\\Gamma(\\phi)} \\left(\\frac{\\phi}{\\mu}\\right)^{\\phi} y^{\\phi - 1} \\exp\\left(-\\frac{\\phi y}{\\mu}\\right) .\\] parameterization, distribution expected value \\(E(x) = \\mu\\) variance \\(V(x) = \\mu^2/\\phi\\), \\(1/\\phi\\) dispersion parameter. example \\(\\mu\\) modelled using stochastic model includes covariates spatial structure, resulting latent Gaussian model precipitation measurements \\[\\begin{align} y_i\\mid \\mu(s_i), \\theta &\\sim \\Gamma(\\mu(s_i),c\\phi)\\\\ \\log (\\mu(s)) &= \\eta(s) = \\sum_k f_k(c_k(s))+u(s)\\\\ \\theta &\\sim \\pi(\\theta) \\end{align},\\] \\(y_i\\) denotes measurement taken location \\(s_i\\), \\(c_k(s)\\) covariates, \\(u(s)\\) mean-zero Gaussian Matérn field, \\(\\theta\\) vector containing parameters model, including smoothness field. , using rSPDE model also able estimate smoothness latent field.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"examining-the-data","dir":"Articles","previous_headings":"An example with real data","what":"Examining the data","title":"inlabru implementation of the rational SPDE approach","text":"using inlabru. inlabru package available CRAN also GitHub. begin loading libraries need get data build plots. Let us load data border region data frame contains daily measurements 616 stations year 2011, well coordinates altitude information measurement stations. analyze full spatio-temporal data set, instead look total precipitation January, calculate next snippet code, extract coordinates altitudes remove locations missing values. Let us build plot precipitations:  red line figure shows coast line, expect distance coast good covariate precipitation. covariate available, let us calculate observation location: Now, let us plot precipitation function possible covariates:","code":"library(gridExtra) library(ggplot2) library(lattice) library(INLA) library(inlabru) library(splancs) library(fields) data(PRprec) data(PRborder) Y <- rowMeans(PRprec[, 3 + 1:31]) ind <- !is.na(Y) Y <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) alt <- PRprec$Altitude[ind] p <- ggplot() +   geom_point(aes(     x = coords[, 1], y = coords[, 2],     colour = Y   ), size = 2, alpha = 1) +   scale_colour_gradientn(colours = tim.colors(100)) +   geom_path(aes(x = PRborder[, 1], y = PRborder[, 2])) +   geom_path(aes(x = PRborder[1034:1078, 1], y = PRborder[     1034:1078,     2   ]), colour = \"red\") tryCatch(   {     print(p)   },   error = function(e) {     print(\"Unable to build the plot\")   } ) seaDist <- apply(spDists(coords, PRborder[1034:1078, ],   longlat = TRUE ), 1, min) par(mfrow = c(2, 2)) plot(coords[, 1], Y, cex = 0.5, xlab = \"Longitude\") plot(coords[, 2], Y, cex = 0.5, xlab = \"Latitude\") plot(seaDist, Y, cex = 0.5, xlab = \"Distance to sea\") plot(alt, Y, cex = 0.5, xlab = \"Altitude\") par(mfrow = c(1, 1))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"creating-the-rspde-model","dir":"Articles","previous_headings":"An example with real data","what":"Creating the rSPDE model","title":"inlabru implementation of the rational SPDE approach","text":"use inlabru implementation rSPDE model need load functions: create rSPDE model, one rspde.matern() function similar fashion one use inla.spde2.matern() function.","code":"library(rSPDE)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"mesh","dir":"Articles","previous_headings":"An example with real data > Creating the rSPDE model","what":"Mesh","title":"inlabru implementation of the rational SPDE approach","text":"can use R-INLA creating mesh. Let us create mesh based non-convex hull avoid adding many small triangles outside domain interest:","code":"prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2) plot(prmesh, asp = 1, main = \"\") lines(PRborder, col = 3) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"setting-up-the-data-frame","dir":"Articles","previous_headings":"An example with real data > Creating the rSPDE model","what":"Setting up the data frame","title":"inlabru implementation of the rational SPDE approach","text":"place inla.stack, can set data.frame() use inlabru. refer reader vignettes https://inlabru-org.github.io/inlabru/index.html details.","code":"prdata <- data.frame(long = coords[,1], lat = coords[,2],                          seaDist = inla.group(seaDist), y = Y) coordinates(prdata) <- c(\"long\",\"lat\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"setting-up-the-rspde-model","dir":"Articles","previous_headings":"An example with real data > Creating the rSPDE model","what":"Setting up the rSPDE model","title":"inlabru implementation of the rational SPDE approach","text":"set rSPDEmodel, need mesh. default assume want estimate smoothness parameter \\(\\nu\\) covariance-based rational approximation order 2. Later vignette also see options setting rSPDE models keeping smoothness parameter fixed /increasing order covariance-based rational approximation. Therefore, set model use rspde.matern() function: Notice function reminiscent R-INLA’s inla.spde2.matern() function. assume following linkage model components observations \\[\\eta(s) \\sim x(s) + \\text{ Intercept} + \\text{seaDist}.\\] \\(\\eta(s)\\) used observation-likelihood, \\[y_i\\mid \\eta(s_i),\\theta \\sim \\Gamma(\\exp(\\eta (s_i)), c\\phi).\\]","code":"rspde_model <- rspde.matern(mesh = prmesh)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"model-fitting","dir":"Articles","previous_headings":"An example with real data","what":"Model fitting","title":"inlabru implementation of the rational SPDE approach","text":"build model using distance sea \\(x_i\\) covariate improper CAR(1) model \\(\\beta_{ij}=1(\\sim j)\\), R-INLA calls random walk order 1. fit inlabru’s style. inlabru version 2.5.3.9002 higher can use following compact synthax: current CRAN version inlabru (version 2.5.3), one use: fit model simply use bru() function:","code":"cmp <- y ~ Intercept(1) + distSea(seaDist, model=\"rw1\") + field(coordinates, model = rspde_model) cmp <- y ~ Intercept(1) + distSea(seaDist, model=\"rw1\") + field(coordinates, model = rspde_model, mapper = bru_mapper(rspde_model)) rspde_fit <- bru(cmp, data = prdata,   family = \"Gamma\",   options = list(     inla.mode = \"experimental\",     control.inla = list(int.strategy = \"eb\"),     verbose = FALSE) )"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"inlabru-results","dir":"Articles","previous_headings":"An example with real data","what":"inlabru results","title":"inlabru implementation of the rational SPDE approach","text":"can look summaries posterior distributions parameters, example fixed effects (.e. intercept) hyper-parameters (.e. dispersion gamma likelihood, precision RW1, parameters spatial field): Let \\(\\theta_1 = \\textrm{Theta1}\\), \\(\\theta_2=\\textrm{Theta2}\\) \\(\\theta_3=\\textrm{Theta3}\\). terms SPDE \\[(\\kappa^2 - \\Delta)^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(\\alpha = \\nu + d/2\\), \\[\\tau = \\exp(\\theta_1),\\quad \\kappa = \\exp(\\theta_2), \\] default \\[\\nu = 4\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] number 4 comes upper bound \\(\\nu\\), discussed later vignette. general, \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big),\\] \\(\\nu_{UB}\\) value upper bound smoothness parameter \\(\\nu\\). Another choice prior \\(\\nu\\) truncated lognormal distribution also discussed later vignette.","code":"summary(rspde_fit) ## inlabru version: 2.5.3 ## INLA version: 22.09.15 ## Components: ##   Intercept: Model types main='linear', group='exchangeable', replicate='iid' ##   distSea: Model types main='rw1', group='exchangeable', replicate='iid' ##   field: Model types main='rgeneric', group='exchangeable', replicate='iid' ## Likelihoods: ##   Family: 'Gamma' ##     Data class: 'SpatialPointsDataFrame' ##     Predictor: y ~ . ## Time used: ##     Pre = 3.98, Running = 28, Post = 0.181, Total = 32.2  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 1.943 0.053       1.84    1.943      2.046 1.943   0 ##  ## Random effects: ##   Name     Model ##     distSea RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.277    0.913     11.524 ## Precision for distSea                          9890.412 7774.159   2281.288 ## Theta1 for field                                 -1.587    0.836     -3.310 ## Theta2 for field                                  1.202    0.293      0.614 ## Theta3 for field                                 -0.754    0.398     -1.505 ##                                                0.5quant 0.975quant    mode ## Precision parameter for the Gamma observations   13.264     15.117   13.27 ## Precision for distSea                          7715.973  30480.651 4991.01 ## Theta1 for field                                 -1.550     -0.036   -1.42 ## Theta2 for field                                  1.206      1.767    1.22 ## Theta3 for field                                 -0.767      0.056   -0.81 ##  ## Deviance Information Criterion (DIC) ...............: 2501.54 ## Deviance Information Criterion (DIC, saturated) ....: 4748.64 ## Effective number of parameters .....................: 84.97 ##  ## Watanabe-Akaike information criterion (WAIC) ...: 2504.37 ## Effective number of parameters .................: 77.44 ##  ## Marginal log-Likelihood:  -1263.98  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"rspde-inla-results","dir":"Articles","previous_headings":"An example with real data","what":"rSPDE-INLA results","title":"inlabru implementation of the rational SPDE approach","text":"can obtain outputs respect parameters original scale using function rspde.result(): can also plot posterior densities:  function reminiscent inla.spde.result() function main difference summary() plot() methods implemented.","code":"result_fit <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result_fit) ##           mean       sd 0.025quant 0.5quant 0.975quant     mode ## tau   0.283587 0.249893  0.0369028 0.212427   0.957153 0.100486 ## kappa 3.469500 1.018430  1.8578600 3.342210   5.827910 3.100130 ## nu    1.301960 0.340467  0.7294280 1.268240   2.050180 1.184150 par(mfrow = c(1, 3)) plot(result_fit, caption = c(\"tau\", \"kappa\", \"nu\"))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"predictions","dir":"Articles","previous_headings":"An example with real data","what":"Predictions","title":"inlabru implementation of the rational SPDE approach","text":"Let us now obtain predictions (.e. kriging) expected precipitation dense grid region. begin creating grid want predictions. end, can use inla.mesh.projector() function: lattice contains 150 × 100 locations. One can easily change resolution kriging prediction changing nxy. Let us find cells outside region interest plot estimates . Let us plot locations prediction:  Let us now create data.frame() coordinates: Since using distance sea covariate, also calculate covariate prediction locations. Finally, add prediction location prediction data.frame(), namely, coord.prd.df: Let us now build data frame results: Finally, plot results. First predicted mean:  , std. deviations:","code":"nxy <- c(150, 100) projgrid <- inla.mesh.projector(prmesh,   xlim = range(PRborder[, 1]),   ylim = range(PRborder[, 2]), dims = nxy ) xy.in <- inout(projgrid$lattice$loc, cbind(PRborder[, 1], PRborder[, 2])) coord.prd <- projgrid$lattice$loc[xy.in, ] plot(coord.prd, type = \"p\", cex = 0.1) lines(PRborder) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\") coord.prd.df <- data.frame(x1 = coord.prd[,1],                             x2 = coord.prd[,2]) coordinates(coord.prd.df) <- c(\"x1\", \"x2\") seaDist.prd <- apply(spDists(coord.prd,   PRborder[1034:1078, ],   longlat = TRUE ), 1, min) coord.prd.df$seaDist <- seaDist.prd pred_obs <- predict(rspde_fit, coord.prd.df,          ~exp(Intercept + field + distSea)) pred_df <- pred_obs@data pred_df <- cbind(pred_df, pred_obs@coords) p <- ggplot(pred_df, aes(x = x1, y = x2, fill = mean)) +   geom_raster() +   scale_fill_gradient(low = \"yellow\", high = \"red\") p p <- ggplot(pred_df, aes(x = x1, y = x2, fill = sd)) +   geom_raster() p"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"an-example-with-replicates","dir":"Articles","previous_headings":"","what":"An example with replicates","title":"inlabru implementation of the rational SPDE approach","text":"example simulate data replicates. use example considered Rational approximation rSPDE package vignette (difference way data organized). also refer reader vignette description function matern.operators(), along methods (instance, simulate() method).","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"simulating-the-data","dir":"Articles","previous_headings":"An example with replicates","what":"Simulating the data","title":"inlabru implementation of the rational SPDE approach","text":"Let us consider simple Gaussian linear model 30 independent replicates latent spatial field \\(x(\\mathbf{s})\\), observed \\(m\\) locations, \\(\\{\\mathbf{s}_1 , \\ldots , \\mathbf{s}_m \\}\\), replicate. \\(= 1,\\ldots,m,\\) \\[\\begin{align}  y_i &= x_1(\\mathbf{s}_i)+\\varepsilon_i,\\\\ \\vdots &= \\vdots\\\\  y_{+29m} &= x_{30}(\\mathbf{s}_i) + \\varepsilon_{+29m}, \\end{align}\\] \\(\\varepsilon_1,\\ldots,\\varepsilon_{30m}\\) iid normally distributed mean 0 standard deviation 0.1. use basis function representation \\(x(\\cdot)\\) define \\(\\) matrix linking point locations mesh. also need account fact 30 replicates locations. end, \\(\\) matrix need can generated inla.spde.make.() function. reason sampling \\(x(\\cdot)\\) directly latent vector described introduction Rational approximation rSPDE package vignette. begin creating mesh:  compute \\(\\) matrix, needed simulation, connects observation locations mesh: Notice simulated data, use \\(\\) matrix inla.spde.make.() function. now simulate latent process standard deviation \\(\\sigma=1\\) range \\(0.1\\). use \\(\\nu=0.5\\) model exponential covariance function. end create model object matern.operators() function: details function can found Rational approximation rSPDE package vignette. simulate latent process need use simulate() method operator_information object. obtain simulated data \\(y\\) connecting \\(\\) matrix adding gaussian noise. first replicate simulated random field well observation locations shown following figure.","code":"m <- 200 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   offset = c(0.1, 0.4),   max.edge = c(0.05, 0.5) ) plot(mesh_2d, main = \"\") points(loc_2d_mesh[, 1], loc_2d_mesh[, 2]) n.rep <- 30 A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh,   index = rep(1:m, times = n.rep),   repl = rep(1:n.rep, each = m) ) nu <- 0.5 sigma <- 1 range <- 0.1 kappa <- sqrt(8 * nu) / range tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi) * gamma(nu + 1))) d <- 2 operator_information <- matern.operators(   mesh = mesh_2d,   nu = nu,   kappa = kappa,   sigma = sigma,   m = 2 ) set.seed(1) u <- simulate(operator_information, nsim = n.rep) y <- as.vector(A %*% as.vector(u)) +   rnorm(m * n.rep) * 0.1 opar <- par(mfrow = c(1, 2), mgp = c(1.2, 0.5, 0),    mar = c(2, 2, 0.5, 0.5) + 0.1) proj <- inla.mesh.projector(mesh_2d, dims = c(100, 100)) image(inla.mesh.project(proj, field = as.vector(u[, 1])),   xlab = \"\", ylab = \"\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) plot(loc_2d_mesh[, 1], loc_2d_mesh[, 2],   cex = 0.2, pch = 16, xlab = \"\", ylab = \"\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) par(opar)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"fitting-the-inlabru-rspde-model","dir":"Articles","previous_headings":"An example with replicates","what":"Fitting the inlabru rSPDE model","title":"inlabru implementation of the rational SPDE approach","text":"Let us use rational SPDE approach fit data. begin creating model object. Let us now create data.frame() vector replicates indexes: Let us create component fit. extremely important forget replicate fitting model bru() function. produce warning might fit meaningless model. can get summary: summary user’s scale:","code":"rspde_model.rep <- rspde.matern(mesh = mesh_2d) rep.df <- data.frame(y = y, x1 = rep(loc_2d_mesh[,1], 30),                       x2 = rep(loc_2d_mesh[,2], 30)) coordinates(rep.df) <- c(\"x1\", \"x2\") repl <- rep(1:30, each=200) # For inlabru 2.5.3.9002 or above: cmp.rep <-   y ~ -1 + field(coordinates,     model = rspde_model.rep,     replicate = repl   )  # For inlabru 2.5.3 cmp.rep <-   y ~ -1 + field(coordinates,     model = rspde_model.rep,     replicate = repl,     mapper = bru_mapper(rspde_model.rep)   )   rspde_fit.rep <-   bru(cmp.rep,     data = rep.df,     family = \"gaussian\",     options = list(       list(inla.mode = \"experimental\")     )   ) summary(rspde_fit.rep) ## inlabru version: 2.5.3 ## INLA version: 22.09.15 ## Components: ##   field: Model types main='rgeneric', group='exchangeable', replicate='iid' ## Likelihoods: ##   Family: 'gaussian' ##     Data class: 'SpatialPointsDataFrame' ##     Predictor: y ~ . ## Time used: ##     Pre = 3.7, Running = 298, Post = 9.28, Total = 311  ## Random effects: ##   Name     Model ##     field RGeneric2 ##  ## Model hyperparameters: ##                                          mean    sd 0.025quant 0.5quant ## Precision for the Gaussian observations 90.77 4.135      81.68    91.03 ## Theta1 for field                        -2.95 0.096      -3.17    -2.95 ## Theta2 for field                         3.13 0.016       3.10     3.13 ## Theta3 for field                        -1.70 0.040      -1.77    -1.70 ##                                         0.975quant  mode ## Precision for the Gaussian observations     100.64 90.21 ## Theta1 for field                             -2.79 -2.91 ## Theta2 for field                              3.16  3.13 ## Theta3 for field                             -1.61 -1.71 ##  ## Deviance Information Criterion (DIC) ...............: -5937.44 ## Deviance Information Criterion (DIC, saturated) ....: -5963.13 ## Effective number of parameters .....................: 4400.46 ##  ## Watanabe-Akaike information criterion (WAIC) ...: -6700.54 ## Effective number of parameters .................: 2674.35 ##  ## Marginal log-Likelihood:  -4401.07  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit_rep <- rspde.result(rspde_fit.rep, \"field\", rspde_model.rep) summary(result_fit_rep) ##             mean         sd 0.025quant   0.5quant 0.975quant       mode ## tau    0.0524607 0.00492103  0.0423617  0.0527179   0.061389  0.0538517 ## kappa 22.8835000 0.36844300 22.1646000 22.8821000  23.611600 22.8807000 ## nu     0.6176790 0.02095560  0.5812400  0.6159060   0.663042  0.6114320 result_df <- data.frame(   parameter = c(\"tau\", \"kappa\", \"nu\"),   true = c(tau, kappa, nu),   mean = c(     result_fit_rep$summary.tau$mean,     result_fit_rep$summary.kappa$mean,     result_fit_rep$summary.nu$mean   ),   mode = c(     result_fit_rep$summary.tau$mode,     result_fit_rep$summary.kappa$mode,     result_fit_rep$summary.nu$mode   ) ) print(result_df) ##   parameter        true        mean        mode ## 1       tau  0.08920621  0.05246071  0.05385169 ## 2     kappa 20.00000000 22.88345226 22.88065177 ## 3        nu  0.50000000  0.61767858  0.61143178"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"further-options-of-the-inlabru-implementation","dir":"Articles","previous_headings":"","what":"Further options of the inlabru implementation","title":"inlabru implementation of the rational SPDE approach","text":"several additional options available. instance, possible change order rational approximation, upper bound smoothness parameter (may speed fit), change priors, change type rational approximation, among others. options described “options rSPDE-INLA implementation” section R-INLA implementation rational SPDE approach vignette. Observe options passed model rspde.matern() function, therefore resulting model object can directly used bru() function, identical manner examples .","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Bolin. Maintainer, author. Alexandre Simas. Author. Finn Lindgren. Contributor.","code":""},{"path":"https://davidbolin.github.io/rSPDE/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bolin D, Simas (2022). rSPDE: Rational Approximations Fractional Stochastic Partial Differential Equations. R package version 1.2.0, https://CRAN.R-project.org/package=rSPDE. Xiong Z, Simas , Bolin D (2022). “Covariance-based rational approximations fractional SPDEs computationally efficient Bayesian inferenc.” arXiv preprint arXiv:2209.04670. doi:10.48550/arXiv.2209.04670. David Bolin, Kristin Kirchner (2020), rational SPDE approach Gaussian random fields general smoothness Journal Computational Graphical Statistics, 29:2, 274-285.","code":"@Manual{,   title = {rSPDE: Rational Approximations of Fractional Stochastic Partial Differential Equations},   author = {David Bolin and Alexandre B. Simas},   year = {2022},   note = {R package version 1.2.0},   url = {https://CRAN.R-project.org/package=rSPDE}, } @Article{,   title = {Covariance-based rational approximations of fractional SPDEs for computationally efficient Bayesian inferenc},   author = {Zhen Xiong and Alexandre B. Simas and David Bolin},   journal = {arXiv preprint arXiv:2209.04670},   year = {2022},   doi = {10.48550/arXiv.2209.04670}, } @Article{,   title = {The rational {SPDE} approach for {Gaussian} random fields with general smoothness},   author = {David Bolin and Kristin Kirchner},   journal = {Journal of Computational and Graphical Statistics},   year = {2020},   volume = {29},   number = {2},   pages = {274--285},   doi = {10.1080/10618600.2019.1665537}, }"},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"the-rspde-package-","dir":"","previous_headings":"","what":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"rSPDE R package used computing rational approximations fractional SPDEs. rational approximations can used computatially efficient statistical inference. Basic statistical operations likelihood evaluations kriging predictions using fractional approximations also implemented. package also contains interface R-INLA.","code":""},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"Several popular Gaussian random field models can represented solutions stochastic partial differential equations (SPDEs) form \\[ L^{\\beta}(\\tau u) = \\mathcal{W}. \\] \\(\\mathcal{W}\\) Gaussian white noise, \\(L\\) second-order differential operator, fractional power \\(\\beta>0\\) determines smoothness \\(u\\), \\(\\tau>0\\) scales variance \\(u\\). simplest example model \\(\\mathbb {R}^d\\) \\(L = \\kappa^2 - \\Delta\\), results Gaussian random field \\(u\\) Matérn covariance function \\[ C(h) = \\dfrac{ \\sigma^2 }{ 2 ^ {\\nu-1} \\Gamma (\\nu)} (\\kappa h) ^ {\\nu} K_{\\nu} (\\kappa h). \\] \\(2 \\beta\\) integer domain \\(\\mathcal {D}\\) model defined bounded, \\(u\\) can approximated Gaussian Markov random field (GMRF) \\(\\mathbf { \\mathrm{u} }\\) via finite element method (FEM) SPDE. Specifically, approximation can written \\[ u_h (s) = \\sum _ { =1 } ^ n u_i \\varphi_i (s). \\] \\(\\{\\varphi_i\\}\\) piecewise linear basis functions defined triangulation \\(\\mathcal {D}\\) vector weights \\( \\mathbf { \\mathrm { u } } = (u_1,\\ldots,u_n)^\\top \\) normally distributed, \\(N(\\mathbf { \\mathrm{u} }, \\tilde{ \\mathbf { \\mathrm{Q} } }^{-1})\\), \\(\\tilde{ \\mathbf{ \\mathrm{Q} } }\\) sparse. See explicit link Gaussian fields Gaussian Markov random fields: stochastic partial differential equation approach details. rSPDE package provides corresponding computationally efficient approximations case \\(\\beta\\) general fractional power. main idea combine FEM approximation rational approximation fractional operator. result, one can easily inference prediction using fractional SPDE models \\[ ( \\kappa^2-\\Delta )^\\beta u = \\mathcal{ W }. \\] particular, allows bayesian inference model parameters, including fractional parameter \\(\\beta\\). illustration purposes, package contains simple FEM implementation models R. See introduction rSPDE package vignette introduction package. Rational approximation rSPDE package Operator-based rational approximation vignettes provide introductions create fit rSPDE models. introduction R-INLA implementation rSPDE models see R-INLA implementation rational SPDE approach. rSPDE documentation contains descriptions examples functions rSPDE package.","code":""},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"installation-instructions","dir":"","previous_headings":"","what":"Installation instructions","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"latest CRAN release package can installed directly CRAN install.packages(\"rSPDE\"). latest stable version (sometimes slightly recent CRAN version), can installed using command R. development version can installed using command want install package using remotes::install_github-method Windows, first need install Rtools add paths Rtools gcc Windows PATH environment variable. can done current R session using commands variables rtools gcc need changed Rtools installed directly C:, gcc’s version might need changed depending version Rtools.","code":"remotes::install_github(\"davidbolin/rspde\", ref = \"stable\") remotes::install_github(\"davidbolin/rspde\", ref = \"devel\") rtools = \"C:\\\\Rtools\\\\bin\" gcc = \"C:\\\\Rtools\\\\gcc-4.6.3\\\\bin\" Sys.setenv(PATH = paste(c(gcc, rtools, Sys.getenv(\"PATH\")), collapse = \";\"))"},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"example-with-rspde---inla","dir":"","previous_headings":"","what":"Example with rSPDE - INLA","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"illustrate rSPDE package kriging example using R-INLA interface rSPDE. data consist precipitation measurements Paraná region Brazil provided Brazilian National Water Agency. data collected 616 gauge stations Paraná state, south Brazil, day 2011. analyse full spatio-temporal data set, instead look total precipitation January details dataset commands refer reader rSPDE-INLA Vignette.","code":"library(rSPDE) library(ggplot2) library(INLA) library(fields) library(splancs) library(gridExtra) library(lattice)  #Load the data data(PRprec) data(PRborder)  #Get the precipitation in January Y <- rowMeans(PRprec[, 3 + 1:31])  #Treat the data and plot ind <- !is.na(Y) Y <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) alt <- PRprec$Altitude[ind]  ggplot() + geom_point(aes(x = coords[, 1], y = coords[, 2], colour = Y),                       size = 2,                       alpha = 1) +    scale_colour_gradientn(colours = tim.colors(100)) +    geom_path(aes(x = PRborder[, 1], y = PRborder[, 2])) +    geom_path(aes(x = PRborder[1034:1078, 1],                  y = PRborder[1034:1078, 2]), colour = \"red\") #Get distance from the sea seaDist <- apply(spDists(coords, PRborder[1034:1078, ], longlat = TRUE), 1,                   min)                   #Create the mesh prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2) plot(prmesh, asp = 1, main = \"\") lines(PRborder, col = 3) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\") #Create the observation matrix Abar <- rspde.make.A(mesh = prmesh, loc = coords)  #Create the rspde model object rspde_model <- rspde.matern(mesh = prmesh)  #Create the index and inla.stack object mesh.index <- rspde.make.index(name = \"field\", mesh = prmesh) stk.dat <- inla.stack(   data = list(y = Y), A = list(Abar, 1), tag = \"est\",    effects = list(c(mesh.index,                     list(Intercept = 1)),                   list(long = inla.group(coords[, 1]),                        lat = inla.group(coords[,2]),                       seaDist = inla.group(seaDist))))                        #Create the formula object and fit the model f.s <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +    f(field, model = rspde_model)     rspde_fit <- inla(f.s, family = \"Gamma\", data = inla.stack.data(stk.dat),              verbose = FALSE,              control.inla=list(int.strategy='eb'),             control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE))              summary(rspde_fit) #> #>  #> Call: #>    c(\"inla(formula = f.s, family = \\\"Gamma\\\", data = inla.stack.data(stk.dat), \", #>\" verbose = FALSE, control.predictor = list(A = inla.stack.A(stk.dat), \", \"  #>compute = TRUE), control.inla = list(int.strategy = \\\"eb\\\"))\" )  #> Time used: #>     Pre = 4.4, Running = 28.1, Post = 0.106, Total = 32.7  #> Fixed effects: #>            mean    sd 0.025quant 0.5quant 0.975quant  mode kld #> Intercept 0.648 0.019      0.611    0.648      0.686 0.648   0 #>  #> Random effects: #>   Name     Model #>     seaDist RW1 model #>    field RGeneric2 #>  #> Model hyperparameters: #>                                                    mean       sd 0.025quant  #> Precision parameter for the Gamma observations   13.200    0.876     11.548  #> Precision for seaDist                          9378.627 6990.227   2651.630  #> Theta1 for field                                 -1.147    0.311     -1.788  #> Theta2 for field                                  1.089    0.116      0.846  #> Theta3 for field                                 -0.899    0.179     -1.293  #>                                                0.5quant 0.975quant     mode #> Precision parameter for the Gamma observations   13.177     14.990   13.139 #> Precision for seaDist                          7372.387  27837.501 5025.442 #> Theta1 for field                                 -1.157     -0.521   -1.174 #> Theta2 for field                                  1.090      1.315    1.099 #> Theta3 for field                                 -0.898     -0.531   -0.884 #>    #> Marginal log-Likelihood:  -1261.74  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')  #Get the summary on the user's scale result_fit <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result_fit) #> #>          mean       sd 0.025quant 0.5quant 0.975quant     mode #>tau   0.332668 0.106630   0.176185 0.315581   0.595938 0.282519 #>kappa 2.988480 0.344316   2.355250 2.979790   3.711410 2.962190 #>nu    1.161300 0.145758   0.884741 1.160160   1.457410 1.159710  #Plot the posterior densities par(mfrow=c(1,3)) plot(result_fit) #Create a grid to predict nxy <- c(150, 100) projgrid <- rspde.mesh.projector(prmesh, xlim = range(PRborder[, 1]),  ylim = range(PRborder[,2]), dims = nxy) xy.in <- inout(projgrid$lattice$loc, cbind(PRborder[, 1], PRborder[, 2])) coord.prd <- projgrid$lattice$loc[xy.in, ]  #Compute A matrix and seaDist at predict locations and build the stack A.prd <- projgrid$proj$A[xy.in, ] seaDist.prd <- apply(spDists(coord.prd,      PRborder[1034:1078, ], longlat = TRUE), 1, min) ef.prd = list(c(mesh.index, list(Intercept = 1)),      list(long = inla.group(coord.prd[,      1]), lat = inla.group(coord.prd[, 2]),      seaDist = inla.group(seaDist.prd))) stk.prd <- inla.stack(data = list(y = NA),      A = list(A.prd, 1), tag = \"prd\",      effects = ef.prd) stk.all <- inla.stack(stk.dat, stk.prd)  rspde_fitprd <- inla(f.s, family = \"Gamma\",               data = inla.stack.data(stk.all),               control.predictor = list(A = inla.stack.A(stk.all),              compute = TRUE, link = 1))  id.prd <- inla.stack.index(stk.all, \"prd\")$data sd.prd <- m.prd <- matrix(NA, nxy[1], nxy[2]) m.prd[xy.in] <- rspde_fitprd$summary.fitted.values$mean[id.prd] sd.prd[xy.in] <- rspde_fitprd$summary.fitted.values$sd[id.prd]  #Plot the predictions grid.arrange(levelplot(m.prd, col.regions = tim.colors(99),               xlab = \"\", ylab = \"\", main = \"mean\",                         scales = list(draw = FALSE)),               levelplot(sd.prd, col.regions = topo.colors(99),               xlab = \"\", ylab = \"\", scales = list(draw = FALSE),                         main = \"standard deviation\"))"},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"example-with-rspde---inlabru","dir":"","previous_headings":"","what":"Example with rSPDE - inlabru","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"now illustrate rSPDE kriging example inlabru interface rSPDE. make description self-contained, use information codes example . data consist precipitation measurements Paraná region Brazil provided Brazilian National Water Agency. data collected 616 gauge stations Paraná state, south Brazil, day 2011. analyse full spatio-temporal data set, instead look total precipitation January details dataset commands refer reader rSPDE-inlabru Vignette.    Finally, plot results. First predicted mean:  , std. deviations:","code":"library(rSPDE) library(ggplot2) library(INLA) library(inlabru) library(fields) library(splancs) library(gridExtra) library(lattice)  #Load the data data(PRprec) data(PRborder)  #Get the precipitation in January Y <- rowMeans(PRprec[, 3 + 1:31])  #Treat the data and plot ind <- !is.na(Y) Y <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) alt <- PRprec$Altitude[ind]  ggplot() + geom_point(aes(x = coords[, 1], y = coords[, 2], colour = Y),                       size = 2,                       alpha = 1) +    scale_colour_gradientn(colours = tim.colors(100)) +    geom_path(aes(x = PRborder[, 1], y = PRborder[, 2])) +    geom_path(aes(x = PRborder[1034:1078, 1],                  y = PRborder[1034:1078, 2]), colour = \"red\") #Get distance from the sea seaDist <- apply(spDists(coords, PRborder[1034:1078, ], longlat = TRUE), 1,                   min)                   #Create the mesh prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2) plot(prmesh, asp = 1, main = \"\") lines(PRborder, col = 3) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\") #Create the rspde model object rspde_model <- rspde.matern(mesh = prmesh)  #Create the data.frame prdata <- data.frame(long = coords[,1], lat = coords[,2],                          seaDist = inla.group(seaDist), y = Y) coordinates(prdata) <- c(\"long\",\"lat\")                        #Create the component  # The following synthax is available for inlabru version 2.5.3.9002 and above: cmp <- y ~ Intercept(1) + distSea(seaDist, model=\"rw1\") + field(coordinates, model = rspde_model)  # For inlabru version 2.5.3 one should use: cmp <- y ~ Intercept(1) + distSea(seaDist, model=\"rw1\") + field(coordinates, model = rspde_model, mapper = bru_mapper(rspde_model))  # Fit the model    rspde_fit <- bru(cmp, family = \"Gamma\",              data = prdata,             options = list(             verbose = FALSE,              control.inla=list(int.strategy='eb'),             control.predictor = list(compute = TRUE)) )              summary(rspde_fit) #> #>  #> inlabru version: 2.5.3 #> INLA version: 22.09.15 #> Components: #>   Intercept: Model types main='linear', group='exchangeable', replicate='iid' #>   distSea: Model types main='rw1', group='exchangeable', replicate='iid' #>   field: Model types main='rgeneric', group='exchangeable', replicate='iid' #> Likelihoods: #>   Family: 'Gamma' #>     Data class: 'SpatialPointsDataFrame' #>     Predictor: y ~ . #> Time used: #>     Pre = 0.385, Running = 17.8, Post = 0.0281, Total = 18.2  #> Fixed effects: #>            mean    sd 0.025quant 0.5quant 0.975quant mode   kld #> Intercept 1.944 0.055      1.836    1.943      2.051   NA 0.006 #>  #> Random effects: #>   Name    Model #>     distSea RW1 model #>    field RGeneric2 #>  #> Model hyperparameters: #>                                                     mean       sd 0.025quant  #> Precision parameter for the Gamma observations    13.201    0.946     11.415  #> Precision for distSea                          10491.542 8262.891   2687.725  #> Theta1 for field                                  -0.982    0.499     -1.912  #> Theta2 for field                                   1.047    0.354      0.316  #> Theta3 for field                                  -0.968    0.322     -1.601 #>                                                  0.5quant 0.975quant    mode #> Precision parameter for the Gamma observations     13.175     15.142   13.14  #> Precision for distSea                            8135.913  32467.634 5357.16  #> Theta1 for field                                   -1.001      0.052   -1.08 #> Theta2 for field                                    1.060      1.708    1.11 #> Theta3 for field                                   -0.968     -0.333   -0.97 #>  #> Deviance Information Criterion (DIC) ...............: 2503.45 #> Deviance Information Criterion (DIC, saturated) ....: 4750.55 #> Effective number of parameters .....................: 83.48 #>  #> Watanabe-Akaike information criterion (WAIC) ...: 2504.40 #> Effective number of parameters .................: 74.86 #>  #> Marginal log-Likelihood:  -1263.54  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')   #Get the summary on the user's scale result_fit <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result_fit) #>      #>           mean       sd 0.025quant 0.5quant 0.975quant     mode #> tau   0.425204 0.234382   0.149134  0.36643    1.04198 0.279711 #> kappa 3.026290 1.057290   1.381990  2.89078    5.48392 2.612380 #> nu    1.118830 0.254024   0.674592  1.10071    1.66459 1.061370  #Plot the posterior densities par(mfrow=c(1,3)) plot(result_fit) #Create a grid to predict nxy <- c(150, 100) projgrid <- rspde.mesh.projector(prmesh, xlim = range(PRborder[, 1]),  ylim = range(PRborder[,2]), dims = nxy) xy.in <- inout(projgrid$lattice$loc, cbind(PRborder[, 1], PRborder[, 2])) coord.prd <- projgrid$lattice$loc[xy.in, ]  #Compute seaDist at predict locations  seaDist.prd <- apply(spDists(coord.prd,      PRborder[1034:1078, ], longlat = TRUE), 1, min)  # Build the prediction data.frame() coord.prd.df <- data.frame(x1 = coord.prd[,1],                             x2 = coord.prd[,2]) coordinates(coord.prd.df) <- c(\"x1\", \"x2\") coord.prd.df$seaDist <- seaDist.prd  # Obtain prediction at the locations pred_obs <- predict(rspde_fit, coord.prd.df,          ~exp(Intercept + field + distSea))  # Prepare the plotting data.frame() pred_df <- pred_obs@data pred_df <- cbind(pred_df, pred_obs@coords) p <- ggplot(pred_df, aes(x = x1, y = x2, fill = mean)) +   geom_raster() +   scale_fill_gradient(low = \"yellow\", high = \"red\") p p <- ggplot(pred_df, aes(x = x1, y = x2, fill = sd)) +   geom_raster() p"},{"path":"https://davidbolin.github.io/rSPDE/reference/bru_mapper.inla_rspde.html","id":null,"dir":"Reference","previous_headings":"","what":"rSPDE inlabru mapper — bru_mapper.inla_rspde","title":"rSPDE inlabru mapper — bru_mapper.inla_rspde","text":"rSPDE inlabru mapper","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/bru_mapper.inla_rspde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rSPDE inlabru mapper — bru_mapper.inla_rspde","text":"","code":"bru_mapper.inla_rspde(model, ...)  ibm_n.bru_mapper_inla_rspde(mapper, ...)  ibm_values.bru_mapper_inla_rspde(mapper, ...)  ibm_amatrix.bru_mapper_inla_rspde(mapper, input, ...)  bru_get_mapper.inla_rspde(model, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/bru_mapper.inla_rspde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rSPDE inlabru mapper — bru_mapper.inla_rspde","text":"model inla_rspde construct extract mapper ... Arguments passed methods mapper bru_mapper.inla_rspde object input values produce mapping matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/bru_mapper.inla_rspde.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"rSPDE inlabru mapper — bru_mapper.inla_rspde","text":"","code":"# \\donttest{ # devel version if (requireNamespace(\"INLA\", quietly = TRUE) &&       requireNamespace(\"inlabru\", quietly = TRUE)){ library(INLA) library(inlabru)  set.seed(123) m <- 100 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   max.edge = c(0.1, 0.5) ) sigma <- 0.01 range <- 0.2 nu <- 0.8 kappa <- sqrt(8 * nu) / range op <- matern.operators(   mesh = mesh_2d, nu = nu,   kappa = kappa, sigma = sigma, m = 2 ) u <- simulate(op) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 y <- A %*% u + rnorm(m) * sigma.e y <- as.vector(y)  data_df <- data.frame(y=y, x1 = loc_2d_mesh[,1],                        x2 = loc_2d_mesh[,2]) coordinates(data_df) <- c(\"x1\", \"x2\") rspde_model <- rspde.matern(   mesh = mesh_2d,   nu_upper_bound = 2 )  # For inlabru version 2.5.3.9002 or above: cmp <- y ~ Intercept(1) +             field(coordinates, model = rspde_model)  #For inlabru version 2.5.3: cmp <- y ~ Intercept(1) +             field(coordinates, model = rspde_model,              mapper = bru_mapper(rspde_model))  rspde_fit <- bru(cmp, data = data_df) } #> Loading required package: foreach #> Loading required package: parallel #> Loading required package: sp #> This is INLA_22.09.15 built 2022-09-15 07:04:36 UTC. #>  - See www.r-inla.org/contact-us for how to get help. #>  - To enable PARDISO sparse library; see inla.pardiso() #> Warning: Model 'rgeneric' in section 'latent' is marked as 'experimental'; changes may appear at any time. #>   Use this model with extra care!!! Further warnings are disabled. # devel.tag # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":null,"dir":"Reference","previous_headings":"","what":"The 1d folded Matern covariance function — folded.matern.covariance.1d","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"folded.matern.covariance.1d evaluates 1d folded Matern covariance function interval \\([0,L]\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"","code":"folded.matern.covariance.1d(   h,   m,   kappa,   nu,   sigma,   L = 1,   N = 10,   boundary = c(\"neumann\", \"dirichlet\", \"periodic\") )"},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"h, m Vectors arguments covariance function. kappa Range parameter. nu Shape parameter. sigma Standard deviation. L upper bound interval \\([0,L]\\). default, L=1. N truncation parameter. boundary boundary condition. possible conditions \"neumann\" (default), \"dirichlet\" \"periodic\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"matrix corresponding covariance values.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"folded.matern.covariance.1d evaluates 1d folded Matern covariance function interval \\([0,L]\\) different boundary conditions. periodic boundary conditions $$C_{\\mathcal{P}}(h,m) = \\sum_{k=-\\infty}^{\\infty} (C(h-m+2kL),$$ Neumann boundary conditions $$C_{\\mathcal{N}}(h,m) = \\sum_{k=-\\infty}^{\\infty} (C(h-m+2kL)+C(h+m+2kL)),$$ Dirichlet boundary conditions: $$C_{\\mathcal{D}}(h,m) = \\sum_{k=-\\infty}^{\\infty} (C(h-m+2kL)-C(h+m+2kL)),$$ \\(C(\\cdot)\\) Matern covariance function: $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h).$$ consider truncation: $$C_{{\\mathcal{P}},N}(h,m) = \\sum_{k=-N}^{N} C(h-m+2kL), C_{\\mathcal{N},N}(h,m) = \\sum_{k=-\\infty}^{\\infty} (C(h-m+2kL)+C(h+m+2kL)),$$ $$C_{\\mathcal{D},N}(h,m) = \\sum_{k=-N}^{N} (C(h-m+2kL)-C(h+m+2kL)).$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"","code":"x <- seq(from = 0, to = 1, length.out = 101) plot(x, folded.matern.covariance.1d(rep(0.5, length(x)), x, kappa = 10, nu = 1 / 5, sigma = 1),   type = \"l\", ylab = \"C(h)\", xlab = \"h\" )"},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":null,"dir":"Reference","previous_headings":"","what":"The 2d folded Matern covariance function — folded.matern.covariance.2d","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"folded.matern.covariance.2d evaluates 2d folded Matern covariance function interval \\([0,L]\\times [0,L]\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"","code":"folded.matern.covariance.2d(   h,   m,   kappa,   nu,   sigma,   L = 1,   N = 10,   boundary = c(\"neumann\", \"dirichlet\", \"periodic\", \"R2\") )"},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"h, m Vectors two coordinates. kappa Range parameter. nu Shape parameter. sigma Standard deviation. L upper bound square \\([0,L]\\times [0,L]\\). default, L=1. N truncation parameter. boundary boundary condition. possible conditions \"neumann\" (default), \"dirichlet\", \"periodic\" \"R2\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"correspoding covariance.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"folded.matern.covariance.2d evaluates 1d folded Matern covariance function interval \\([0,L]\\times [0,L]\\) different boundary conditions. periodic boundary conditions $$C_{\\mathcal{P}}((h_1,h_2),(m_1,m_2)) = \\sum_{k_2=-\\infty}^\\infty \\sum_{k_1=-\\infty}^{\\infty} (C(\\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\\|),$$ Neumann boundary conditions $$C_{\\mathcal{N}}((h_1,h_2),(m_1,m_2)) = \\sum_{k_2=-\\infty}^\\infty \\sum_{k_1=-\\infty}^{\\infty} (C(\\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\\|)+C(\\|(h_1-m_1+2k_1L, h_2+m_2+2k_2L)\\|)+C(\\|(h_1+m_1+2k_1L,h_2-m_2+2k_2L)\\|)+ C(\\|(h_1+m_1+2k_1L,h_2+m_2+2k_2L)\\|)),$$ Dirichlet boundary conditions: $$C_{\\mathcal{D}}((h_1,h_2),(m_1,m_2)) = \\sum_{k_2=-\\infty}^\\infty \\sum_{k_1=-\\infty}^{\\infty} (C(\\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\\|)- C(\\|(h_1-m_1+2k_1L,h_2+m_2+2k_2L)\\|)-C(\\|(h_1+m_1+2k_1L, h_2-m_2+2k_2L)\\|)+C(\\|(h_1+m_1+2k_1L,h_2+m_2+2k_2L)\\|)),$$ \\(C(\\cdot)\\) Matern covariance function: $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)} (\\kappa h)^\\nu K_\\nu(\\kappa h).$$ consider truncation \\(k_1,k_2\\) \\(-N\\) \\(N\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"","code":"h <- c(0.5, 0.5) m <- c(0.5, 0.5) folded.matern.covariance.2d(h, m, kappa = 10, nu = 1 / 5, sigma = 1) #> [1] 1.000043"},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational approximations of fractional operators — fractional.operators","title":"Rational approximations of fractional operators — fractional.operators","text":"fractional.operators used computing approximation, can used inference simulation, fractional SPDE $$L^\\beta (\\tau u(s)) = W.$$ \\(L\\) differential operator, \\(\\beta>0\\) fractional power, \\(\\tau\\) positive scalar vector scales variance solution \\(u\\), \\(W\\) white noise.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational approximations of fractional operators — fractional.operators","text":"","code":"fractional.operators(L, beta, C, scale.factor, m = 1, tau = 1)"},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rational approximations of fractional operators — fractional.operators","text":"L finite element discretization operator \\(L\\). beta positive fractional power. C mass matrix finite element discretization. scale.factor constant \\(c\\) lower bound smallest eigenvalue non-discretized operator \\(L\\). m order rational approximation, needs positive integer. default value 1. Higer values gives accurate approximation, computationally expensive use inference. Currently, largest value m implemented 4. tau constant vector scales variance solution. default value 1.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rational approximations of fractional operators — fractional.operators","text":"fractional.operators returns object class \"rSPDEobj\". object contains following quantities: Pl operator \\(P_l\\). Pr operator \\(P_r\\). C mass lumped mass matrix. Ci inverse C. m order rational approximation. beta fractional power. type String indicating type approximation. Q matrix t(Pl) %*% solve(C,Pl). type String indicating type approximation. Pl.factors List elements can used assemble \\(P_l\\). Pr.factors List elements can used assemble \\(P_r\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational approximations of fractional operators — fractional.operators","text":"approximation based rational approximation fractional operator, resulting approximate model form $$P_l u(s) = P_r W,$$ \\(P_j = p_j(L)\\) non-fractional operators defined terms polynomials \\(p_j\\) \\(j=l,r\\). order \\(p_r\\) given m order \\(p_l\\) \\(m + m_\\beta\\) \\(m_\\beta\\) integer part \\(\\beta\\) \\(\\beta>1\\) \\(m_\\beta = 1\\) otherwise. discrete approximation can written \\(u = P_r x\\) \\(x \\sim N(0,Q^{-1})\\) \\(Q = P_l^T C^{-1} P_l\\). Note matrices \\(P_r\\) \\(Q\\) may ill-conditioned \\(m>1\\). case, methods operator.operations() used operations involving matrices, since methods numerically stable.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rational approximations of fractional operators — fractional.operators","text":"","code":"# Compute rational approximation of a Gaussian process with a # Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *   (4 * pi)^(1 / 2) * gamma(nu + 1 / 2))) op <- fractional.operators(   L = fem$G + kappa^2 * fem$C, beta = (nu + 1 / 2) / 2,   C = fem$C, scale.factor = kappa^2, tau = tau )  v <- t(rSPDE.A1d(x, 0.5)) c.approx <- Sigma.mult(op, v)  # plot the result and compare with the true Matern covariance plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma),   type = \"l\", ylab = \"C(h)\",   xlab = \"h\", main = \"Matern covariance and rational approximations\" ) lines(x, c.approx, col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/get.inital.values.rSPDE.html","id":null,"dir":"Reference","previous_headings":"","what":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.inital.values.rSPDE","title":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.inital.values.rSPDE","text":"Auxiliar function obtain domain-based initial values log-likelihood optimization rSPDE models latent stationary Gaussian Matern model","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/get.inital.values.rSPDE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.inital.values.rSPDE","text":"","code":"get.inital.values.rSPDE(   mesh = NULL,   mesh.range = NULL,   dim = NULL,   include.nu = TRUE,   log.scale = TRUE,   include.tau = FALSE,   nu_upper_bound = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/get.inital.values.rSPDE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.inital.values.rSPDE","text":"mesh INLA mesh mesh.range range mesh. dim dimension domain. include.nu also provide initial guess nu? log.scale results provided log scale? include.tau tau returned instead sigma? nu_upper_bound upper bound nu considered?","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/get.inital.values.rSPDE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.inital.values.rSPDE","text":"vector form (theta_1,theta_2,theta_3) theta_1 initial guess tau, theta_2 initial guess kappa theta_3 initial guess nu.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/get.sparsity.graph.rspde.html","id":null,"dir":"Reference","previous_headings":"","what":"Sparsity graph for rSPDE models — get.sparsity.graph.rspde","title":"Sparsity graph for rSPDE models — get.sparsity.graph.rspde","text":"Creates sparsity graph rSPDE models","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/get.sparsity.graph.rspde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sparsity graph for rSPDE models — get.sparsity.graph.rspde","text":"","code":"get.sparsity.graph.rspde(   mesh = NULL,   fem_mesh_matrices = NULL,   nu,   force_non_integer = FALSE,   rspde_order = 2,   sharp = TRUE,   dim = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/get.sparsity.graph.rspde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sparsity graph for rSPDE models — get.sparsity.graph.rspde","text":"mesh INLA mesh, optional fem_mesh_matrices list containing FEM-related matrices. list contain elements C, G, G_2, G_3, etc. Optional, provided mesh provided. nu smoothness parameter force_non_integer nu treated non_integer? rspde_order order covariance-based rational SPDE approach. sharp graph correct sparsity (costs perform sparsity analysis) upper bound sparsity? dim dimension, optional. provided mesh provided.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/get.sparsity.graph.rspde.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sparsity graph for rSPDE models — get.sparsity.graph.rspde","text":"sparsity graph rSPDE models used R-INLA interface.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":null,"dir":"Reference","previous_headings":"","what":"The Matern covariance function — matern.covariance","title":"The Matern covariance function — matern.covariance","text":"matern.covariance evaluates Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h).$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Matern covariance function — matern.covariance","text":"","code":"matern.covariance(h, kappa, nu, sigma)"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Matern covariance function — matern.covariance","text":"h Distances evaluate covariance function . kappa Range parameter. nu Shape parameter. sigma Standard deviation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Matern covariance function — matern.covariance","text":"vector values C(h).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Matern covariance function — matern.covariance","text":"","code":"x <- seq(from = 0, to = 1, length.out = 101) plot(x, matern.covariance(abs(x - 0.5), kappa = 10, nu = 1 / 5, sigma = 1),   type = \"l\", ylab = \"C(h)\", xlab = \"h\" )"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter-based log-likelihood for a latent Gaussian Matern model\nusing a rational SPDE approximation — matern.loglike","title":"Parameter-based log-likelihood for a latent Gaussian Matern model\nusing a rational SPDE approximation — matern.loglike","text":"function evaluates log-likelihood function Gaussian process Matern covariance function, observed Gaussian measurement noise: \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables. latent model approximated using rational approximation fractional SPDE model corresponding Gaussian process.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameter-based log-likelihood for a latent Gaussian Matern model\nusing a rational SPDE approximation — matern.loglike","text":"","code":"matern.loglike(   kappa,   sigma,   nu,   sigma.e,   Y,   G,   C,   A,   mu = 0,   d = 2,   m = 1,   type = c(\"covariance\", \"operator\"),   pivot = TRUE )"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameter-based log-likelihood for a latent Gaussian Matern model\nusing a rational SPDE approximation — matern.loglike","text":"kappa Range parameter latent process. sigma Standard deviation latent process. nu Shape parameter latent process. sigma.e standard deviation measurement noise. Y observations, either vector matrix columns correspond independent replicates observations. G stiffness matrix finite element discretization domain. C mass matrix finite element discretization domain. matrix linking measurement locations basis FEM approximation latent model. mu Expectation vector latent field (default = 0). d dimension domain. default value 2. m order rational approximation, needs positive integer. default value 1. type type rational approximation. options \"covariance\" \"operator\". default \"covariance\". pivot pivoting used Cholesky decompositions? Default TRUE","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameter-based log-likelihood for a latent Gaussian Matern model\nusing a rational SPDE approximation — matern.loglike","text":"log-likelihood value.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parameter-based log-likelihood for a latent Gaussian Matern model\nusing a rational SPDE approximation — matern.loglike","text":"","code":"# this example illustrates how the function can be used for maximum # likelihood estimation  set.seed(123) # Sample a Gaussian Matern process on R using the covariance-based # rational approximation nu <- 0.8 kappa <- 5 sigma <- 1 sigma.e <- 0.1 n.rep <- 10 n.obs <- 100 n.x <- 51  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x)  tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))  # Compute the covariance-based rational approximation op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  # Sample the model u <- simulate(op_cov, n.rep)  # Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs * n.rep) dim(noise) <- c(n.obs, n.rep) Y <- as.matrix(A %*% u + sigma.e * noise)  # Define the negative likelihood function for optimization # using CBrSPDE.matern.loglike # Notice that we are also using sigma instead of tau, so it can be compared # to matern.loglike() mlik_cov2 <- function(theta, Y, A, C, G) {   kappa <- exp(theta[1])   sigma <- exp(theta[2])   nu <- exp(theta[3])   return(-matern.loglike(     kappa = kappa, sigma = sigma,     nu = nu, sigma.e = exp(theta[4]), Y = Y, A = A,     C = fem$C, G = fem$G, d = 1   )) }  # The parameters can now be estimated by minimizing mlik with optim # \\donttest{ # Choose some reasonable starting values depending on the size of the domain theta0 <- log(c(sqrt(8), sqrt(var(c(Y))), 0.9, 0.01))  # run estimation and display the results theta <- optim(theta0, mlik_cov2,   Y = Y, A = A, C = C, G = G,   method = \"L-BFGS-B\" )  print(data.frame(   kappa = c(kappa, exp(theta$par[1])), sigma = c(sigma, exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) #>              kappa     sigma       nu    sigma.e #> Truth     5.000000 1.0000000 0.800000 0.10000000 #> Estimates 7.675041 0.9686377 1.053539 0.09840749 # }  # this example illustrates how the function can be used for # maximum likelihood estimation when using the operator-based # rational approximation set.seed(123) # Sample a Gaussian Matern process on R using a rational approximation nu <- 0.8 kappa <- 5 sigma <- 1 sigma.e <- 0.1 n.rep <- 10 n.obs <- 100 n.x <- 51  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x)  # compute rational approximation op <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem$G, C = fem$C, d = 1,   type = \"operator\" )  # Sample the model u <- simulate(op, n.rep)  # Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs * n.rep) dim(noise) <- c(n.obs, n.rep) Y <- as.matrix(A %*% u + sigma.e * noise)  # define negative likelihood function for optimization using matern.loglike mlik <- function(theta, Y, G, C, A) {   return(-matern.loglike(exp(theta[1]), exp(theta[2]),     exp(theta[3]), exp(theta[4]),     Y = Y, G = G, C = C, A = A, d = 1,     type = \"operator\"   )) }  # The parameters can now be estimated by minimizing mlik with optim # \\donttest{ # Choose some reasonable starting values depending on the size of the domain theta0 <- log(c(sqrt(8), sqrt(var(c(Y))), 0.9, 0.01))  # run estimation and display the results theta <- optim(theta0, mlik,   Y = Y, G = fem$G, C = fem$C, A = A,   method = \"L-BFGS-B\" )  print(data.frame(   kappa = c(kappa, exp(theta$par[1])), sigma = c(sigma, exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) #>              kappa     sigma        nu    sigma.e #> Truth     5.000000 1.0000000 0.8000000 0.10000000 #> Estimates 4.063431 0.8095477 0.5906243 0.09566357 # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"matern.operators used computing rational SPDE approximation stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)} (\\kappa h)^\\nu K_\\nu(\\kappa h)$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"","code":"matern.operators(   kappa,   sigma,   nu,   G = NULL,   C = NULL,   d = NULL,   mesh = NULL,   m = 1,   type = c(\"covariance\", \"operator\"),   compute_higher_order = FALSE,   return_block_list = FALSE,   type_rational_approximation = c(\"chebfun\", \"brasil\", \"chebfunLB\") )"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"kappa Range parameter covariance function. sigma Standard deviation covariance function. nu Shape parameter covariance function. G stiffness matrix finite element discretization domain interest. need given mesh used. C mass matrix finite element discretization domain interest. need given mesh used. d dimension domain. need given mesh used. mesh optional inla mesh. d, C G must given mesh given. m order rational approximation, needs positive integer. default value 1. type type rational approximation. options \"covariance\" \"operator\". default \"covariance\". compute_higher_order Logical. higher order finite element matrices computed? return_block_list Logical. type = \"covariance\", block parts precision matrix returned separately list? type_rational_approximation type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"type \"covariance\", matern.operators returns object class \"CBrSPDEobj\". object list containing following quantities: C mass lumped mass matrix. Ci inverse C. GCi stiffness matrix G times Ci Gk stiffness matrix G along higher-order FEM-related matrices G2, G3, etc. fem_mesh_matrices list containing mass lumped mass matrix, stiffness matrix higher-order FEM-related matrices. m order rational approximation. alpha fractional power precision operator. type String indicating type approximation. d dimension domain. nu Shape parameter covariance function. kappa Range parameter covariance function tau Scale parameter covariance function. sigma Standard deviation covariance function. type String indicating type approximation. type \"operator\", matern.operators returns object class \"rSPDEobj\". object contains quantities listed output fractional.operators(), G matrix, dimension domain, well parameters covariance function.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"type \"covariance\", use covariance-based rational approximation fractional operator. SPDE approach, model \\(u\\) solution following SPDE: $$L^{\\alpha/2}(\\tau u) = \\mathcal{W},$$ \\(L  = -\\Delta +\\kappa^2 \\) \\(\\mathcal{W}\\) standard Gaussian white noise. covariance operator \\(u\\) given \\(L^{-\\alpha}\\). Now, let \\(L_h\\) finite-element approximation \\(L\\). can use rational approximation order \\(m\\) \\(L_h^{-\\alpha}\\) obtain following approximation: $$L_{h,m}^{-\\alpha} = L_h^{-m_\\alpha} p(L_h^{-1})q(L_h^{-1})^{-1},$$ \\(m_\\alpha = \\lfloor \\alpha\\rfloor\\), \\(p\\) \\(q\\) polynomials arising rational approximation. approximation construct approximate precision matrix \\(u\\). type \"operator\", approximation based rational approximation fractional operator \\((\\kappa^2 -\\Delta)^\\beta\\), \\(\\beta = (\\nu + d/2)/2\\). results approximate model form $$P_l u(s) = P_r W,$$ \\(P_j = p_j(L)\\) non-fractional operators defined terms polynomials \\(p_j\\) \\(j=l,r\\). order \\(p_r\\) given m order \\(p_l\\) \\(m + m_\\beta\\) \\(m_\\beta\\) integer part \\(\\beta\\) \\(\\beta>1\\) \\(m_\\beta = 1\\) otherwise. discrete approximation can written \\(u = P_r x\\) \\(x \\sim N(0,Q^{-1})\\) \\(Q = P_l^T C^{-1} P_l\\). Note matrices \\(P_r\\) \\(Q\\) may ill-conditioned \\(m>1\\). case, methods operator.operations() used operations involving matrices, since methods numerically stable.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"","code":"# Compute the covariance-based rational approximation of a # Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization nobs <- 101 x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  v <- t(rSPDE.A1d(x, 0.5)) # Compute the precision matrix Q <- op_cov$Q # A matrix here is the identity matrix A <- Diagonal(nobs) # We need to concatenate 3 A's since we are doing a covariance-based rational # approximation of order 2 Abar <- cbind(A, A, A) w <- rbind(v, v, v) # The approximate covariance function: c_cov.approx <- (Abar) %*% solve(Q, w) c.true <- folded.matern.covariance.1d(rep(0.5, length(x)),    abs(x), kappa, nu, sigma)  # plot the result and compare with the true Matern covariance plot(x, c.true,   type = \"l\", ylab = \"C(h)\",   xlab = \"h\", main = \"Matern covariance and rational approximations\" ) lines(x, c_cov.approx, col = 2)    # Compute the operator-based rational approximation of a Gaussian # process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 op <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem$G, C = fem$C, d = 1,   type = \"operator\" )  v <- t(rSPDE.A1d(x, 0.5)) c.approx <- Sigma.mult(op, v) c.true <- folded.matern.covariance.1d(rep(0.5, length(x)),   abs(x), kappa, nu, sigma)  # plot the result and compare with the true Matern covariance plot(x, c.true,   type = \"l\", ylab = \"C(h)\",   xlab = \"h\", main = \"Matern covariance and rational approximation\" ) lines(x, c.approx, col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":null,"dir":"Reference","previous_headings":"","what":"Operations with the Pr and Pl operators — operator.operations","title":"Operations with the Pr and Pl operators — operator.operations","text":"Functions multiplying solving \\(P_r\\) \\(P_l\\) operators well latent precision matrix \\(Q = P_l C^{-1}P_l\\) covariance matrix \\(\\Sigma = P_r Q^{-1} P_r^T\\). operations done without first assembling \\(P_r\\), \\(P_l\\) order avoid numerical problems caused ill-conditioned matrices.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Operations with the Pr and Pl operators — operator.operations","text":"","code":"Pr.mult(obj, v, transpose = FALSE)  Pr.solve(obj, v, transpose = FALSE)  Pl.mult(obj, v, transpose = FALSE)  Pl.solve(obj, v, transpose = FALSE)  Q.mult(obj, v)  Q.solve(obj, v)  Qsqrt.mult(obj, v, transpose = FALSE)  Qsqrt.solve(obj, v, transpose = FALSE)  Sigma.mult(obj, v)  Sigma.solve(obj, v)"},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Operations with the Pr and Pl operators — operator.operations","text":"obj rSPDE object v vector apply operation transpose set TRUE operation performed transposed object","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Operations with the Pr and Pl operators — operator.operations","text":"vector values operation","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Operations with the Pr and Pl operators — operator.operations","text":"Pl.mult, Pr.mult, Q.mult multiplies vector respective object. Changing mult solve function names multiplies vector inverse object. Qsqrt.mult Qsqrt.solve performs operations square-root type object \\(Q_r = C^{-1/2}P_l\\) defined \\(Q = Q_r^T Q_r\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/plot.rspde.result.html","id":null,"dir":"Reference","previous_headings":"","what":"Posterior plots for field parameters for an inla_rspde model\nfrom a rspde.result object — plot.rspde.result","title":"Posterior plots for field parameters for an inla_rspde model\nfrom a rspde.result object — plot.rspde.result","text":"Posterior plots rSPDE field parameters original scales.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/plot.rspde.result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Posterior plots for field parameters for an inla_rspde model\nfrom a rspde.result object — plot.rspde.result","text":"","code":"# S3 method for rspde.result plot(   x,   which = c(\"tau\", \"kappa\", \"nu\"),   caption = list(\"Posterior density for tau\", \"Posterior density for kappa\",     \"Posterior density for nu\"),   sub.caption = NULL,   type_plot = \"l\",   ask = prod(graphics::par(\"mfcol\")) < length(which) && grDevices::dev.interactive(),   main = \"\",   cex.oma.main = 1.25,   cex.caption = 1,   ylab = \"Density\",   xlab = \"x\",   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/plot.rspde.result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Posterior plots for field parameters for an inla_rspde model\nfrom a rspde.result object — plot.rspde.result","text":"x rspde.result object. parameters posterior plotted? caption captions appear plots; character vector list valid graphics annotations. Can set \"\" NA suppress captions. sub.caption common title-figures one. type_plot type plot drawn. default 'l'. ask logical; TRUE, user asked plot. main character; title placed plot additionally () captions. cex.oma.main controls size sub.caption figures one. cex.caption controls size caption. ylab Label y axis. xlab Label x axis. ... Additional arguments.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/plot.rspde.result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Posterior plots for field parameters for an inla_rspde model\nfrom a rspde.result object — plot.rspde.result","text":"Called side effects.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/plot.rspde.result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Posterior plots for field parameters for an inla_rspde model\nfrom a rspde.result object — plot.rspde.result","text":"","code":"# \\donttest{ # devel version if (requireNamespace(\"INLA\", quietly = TRUE)){ library(INLA)  set.seed(123)  m <- 100 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   max.edge = c(0.1, 0.5) ) sigma <- 0.01 range <- 0.2 nu <- 0.8 kappa <- sqrt(8 * nu) / range op <- matern.operators(   mesh = mesh_2d, nu = nu,   kappa = kappa, sigma = sigma, m = 2 ) u <- simulate(op) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 y <- A %*% u + rnorm(m) * sigma.e Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d) st.dat <- inla.stack(   data = list(y = as.vector(y)),   A = Abar,   effects = mesh.index ) rspde_model <- rspde.matern(   mesh = mesh_2d,   nu_upper_bound = 2 ) f <- y ~ -1 + f(field, model = rspde_model) rspde_fit <- inla(f,   data = inla.stack.data(st.dat),   family = \"gaussian\",   control.predictor =     list(A = inla.stack.A(st.dat)),            inla.mode = \"experimental\" ) result <- rspde.result(rspde_fit, \"field\", rspde_model) plot(result) }    # devel.tag # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the precision matrix of CBrSPDEobj objects — precision","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"Function get precision matrix CBrSPDEobj object","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"","code":"precision(object, ...)  # S3 method for CBrSPDEobj precision(   object,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_m = NULL,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"object covariance-based rational SPDE approximation, computed using matern.operators() ... Currently used. user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_m non-null, update order rational approximation, needs positive integer.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"precision matrix.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"","code":"# Compute the covariance-based rational approximation of a # Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi)^(1 / 2) * gamma(nu + 1 / 2))) op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  # Get the precision matrix: prec_matrix <- precision(op_cov)"},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction of a fractional SPDE using the covariance-based\nrational SPDE approximation — predict.CBrSPDEobj","title":"Prediction of a fractional SPDE using the covariance-based\nrational SPDE approximation — predict.CBrSPDEobj","text":"function used computing kriging predictions based data \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon\\) mean-zero Gaussian measurement noise \\(u(s)\\) defined fractional SPDE \\((\\kappa^2 - \\Delta)^{\\alpha/2} (\\tau u(s)) = W\\), \\(W\\) Gaussian white noise \\(\\alpha = \\nu + d/2\\), \\(d\\) dimension domain.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction of a fractional SPDE using the covariance-based\nrational SPDE approximation — predict.CBrSPDEobj","text":"","code":"# S3 method for CBrSPDEobj predict(   object,   A,   Aprd,   Y,   sigma.e,   mu = 0,   compute.variances = FALSE,   pivot = TRUE,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction of a fractional SPDE using the covariance-based\nrational SPDE approximation — predict.CBrSPDEobj","text":"object covariance-based rational SPDE approximation, computed using matern.operators() matrix linking measurement locations basis FEM approximation latent model. Aprd matrix linking prediction locations basis FEM approximation latent model. Y vector observed data, can also matrix columns observations independent replicates \\(u\\). sigma.e standard deviation Gaussian measurement noise. Put zero model measurement noise. mu Expectation vector latent field (default = 0). compute.variances Set also TRUE compute kriging variances. pivot pivoting used Cholesky decompositions? ... arguments passed methods.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction of a fractional SPDE using the covariance-based\nrational SPDE approximation — predict.CBrSPDEobj","text":"list elements mean kriging predictor (posterior mean u|Y). variance posterior variances (computed).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction of a fractional SPDE using the covariance-based\nrational SPDE approximation — predict.CBrSPDEobj","text":"","code":"set.seed(123) # Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8 sigma.e <- 0.3  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *        (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))  # Compute the covariance-based rational approximation op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  # Sample the model u <- simulate(op_cov)  # Create some data obs.loc <- runif(n = 10, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) Y <- as.vector(A %*% u + sigma.e * rnorm(10))  # compute kriging predictions at the FEM grid A.krig <- rSPDE.A1d(x, x) u.krig <- predict(op_cov,   A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e,   compute.variances = TRUE )  plot(obs.loc, Y,   ylab = \"u(x)\", xlab = \"x\", main = \"Data and prediction\",   ylim = c(     min(u.krig$mean - 2 * sqrt(u.krig$variance)),     max(u.krig$mean + 2 * sqrt(u.krig$variance))   ) ) lines(x, u.krig$mean) lines(x, u.krig$mean + 2 * sqrt(u.krig$variance), col = 2) lines(x, u.krig$mean - 2 * sqrt(u.krig$variance), col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"function used computing kriging predictions based data \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon\\) mean-zero Gaussian measurement noise \\(u(s)\\) defined fractional SPDE \\(L^\\beta u(s) = W\\), \\(W\\) Gaussian white noise.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"","code":"# S3 method for rSPDEobj predict(object, A, Aprd, Y, sigma.e, compute.variances = FALSE, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"object rational SPDE approximation, computed using fractional.operators(), matern.operators(), spde.matern.operators(). matrix linking measurement locations basis FEM approximation latent model. Aprd matrix linking prediction locations basis FEM approximation latent model. Y vector observed data, can also matrix columns observations independent replicates \\(u\\). sigma.e standard deviation Gaussian measurement noise. Put zero model measurement noise. compute.variances Set also TRUE compute kriging variances. ... arguments passed methods.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"list elements mean kriging predictor (posterior mean u|Y). variance posterior variances (computed).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"","code":"# Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8 sigma.e <- 0.3  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation op <- matern.operators(   kappa = kappa, sigma = sigma,   nu = nu, G = fem$G, C = fem$C, d = 1 )  # Sample the model u <- simulate(op)  # Create some data obs.loc <- runif(n = 10, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) Y <- as.vector(A %*% u + sigma.e * rnorm(10))  # compute kriging predictions at the FEM grid A.krig <- rSPDE.A1d(x, x) u.krig <- predict(op,   A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e,   compute.variances = TRUE )  plot(obs.loc, Y,   ylab = \"u(x)\", xlab = \"x\", main = \"Data and prediction\",   ylim = c(     min(u.krig$mean - 2 * sqrt(u.krig$variance)),     max(u.krig$mean + 2 * sqrt(u.krig$variance))   ) ) lines(x, u.krig$mean) lines(x, u.krig$mean + 2 * sqrt(u.krig$variance), col = 2) lines(x, u.krig$mean - 2 * sqrt(u.krig$variance), col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":null,"dir":"Reference","previous_headings":"","what":"Observation matrix for finite element discretization on R — rSPDE.A1d","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"finite element discretization R can written \\(u(s) = \\sum_i^n u_i \\varphi_i(s)\\) \\(\\varphi_i(s)\\) piecewise linear \"hat function\" centered location \\(x_i\\). function computes \\(m\\times n\\) matrix \\(\\) links basis function expansion specified locations \\(s = (s_1,\\ldots, s_m)\\) domain \\(A_ij = \\varphi_j(s_i)\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"","code":"rSPDE.A1d(x, loc)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"x locations nodes FEM discretization. loc locations \\((s_1,\\ldots, s_m)\\)","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"sparse matrix .","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"David Bolin davidbolin@gmail.com","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"","code":"# create mass and stiffness matrices for a FEM discretization on [0,1] x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # create the observation matrix for some locations in the domain obs.loc <- runif(n = 10, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.construct.matern.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor of Matern loglikelihood functions. — rSPDE.construct.matern.loglike","title":"Constructor of Matern loglikelihood functions. — rSPDE.construct.matern.loglike","text":"function returns log-likelihood function Gaussian process Matern covariance function, observed Gaussian measurement noise: \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables. latent model approximated using rational approximation fractional SPDE model corresponding Gaussian process.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.construct.matern.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor of Matern loglikelihood functions. — rSPDE.construct.matern.loglike","text":"","code":"rSPDE.construct.matern.loglike(   object,   Y,   A,   sigma.e = NULL,   mu = 0,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_m = NULL,   log_scale = TRUE,   return_negative_likelihood = TRUE,   pivot = TRUE )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.construct.matern.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor of Matern loglikelihood functions. — rSPDE.construct.matern.loglike","text":"object rational SPDE approximation, computed using matern.operators() Y observations, either vector matrix columns correspond independent replicates observations. observation matrix links measurement location finite element basis. sigma.e non-null, standard deviation measurement noise kept fixed returned likelihood. mu Expectation vector latent field (default = 0). user_nu non-null, shape parameter kept fixed returned likelihood. user_kappa non-null, range parameter kept fixed returned likelihood. user_sigma non-null, standard deviation kept fixed returned likelihood. user_m non-null, update order rational approximation, needs positive integer. log_scale parameters evaluated log-scale? return_negative_likelihood Return minus likelihood turn maximization minimization? pivot pivoting used Cholesky decompositions? Default TRUE","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.construct.matern.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructor of Matern loglikelihood functions. — rSPDE.construct.matern.loglike","text":"log-likelihood function. parameters returned function given order sigma, kappa, nu, sigma.e, whenever available.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.construct.matern.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor of Matern loglikelihood functions. — rSPDE.construct.matern.loglike","text":"","code":"# this example illustrates how the function can be used for maximum # likelihood estimation  set.seed(123) # Sample a Gaussian Matern process on R using a rational approximation nu <- 0.8 kappa <- 5 sigma <- 1 sigma.e <- 0.1 n.rep <- 10 n.obs <- 100 n.x <- 51  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x)  tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))  # Compute the covariance-based rational approximation op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  # Sample the model u <- simulate(op_cov, n.rep)  # Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs * n.rep) dim(noise) <- c(n.obs, n.rep) Y <- as.matrix(A %*% u + sigma.e * noise)  # Define the negative likelihood function for optimization # using CBrSPDE.matern.loglike  # Notice that we are also using sigma instead of tau, so it can be compared # to matern.loglike() loglike <- rSPDE.construct.matern.loglike(op_cov, Y, A)   # The parameters can now be estimated by minimizing mlik with optim # \\donttest{ # Choose some reasonable starting values depending on the size of the domain theta0 <- log(c(sqrt(8), 1 / sqrt(var(c(Y))), 0.9, 0.01))  # run estimation and display the results theta <- optim(theta0, loglike,   method = \"L-BFGS-B\" )  print(data.frame(   kappa = c(kappa, exp(theta$par[1])), sigma = c(sigma, exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) #>               kappa   sigma        nu    sigma.e #> Truth     5.0000000 1.00000 0.8000000 0.10000000 #> Estimates 0.9609751 6.04131 0.8684799 0.09867137 # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite element calculations for problems on R — rSPDE.fem1d","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"function computes mass stiffness matrices FEM approximation R, assuming Neumann boundary conditions. matrices needed discretizing operators rational approximations.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"","code":"rSPDE.fem1d(x)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"x Locations nodes FEM approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"function returns list following elements G stiffness matrix. C mass matrix.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"David Bolin davidbolin@gmail.com","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"","code":"# create mass and stiffness matrices for a FEM discretization on [0,1] x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational approximations of fractional SPDEs. — rSPDE","title":"Rational approximations of fractional SPDEs. — rSPDE","text":"rSPDE used approximating fractional elliptic SPDEs $$L^\\beta (\\tau u(s)) = W,$$ \\(L\\) differential operator \\(\\beta>0\\) general fractional power.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational approximations of fractional SPDEs. — rSPDE","text":"approximation based rational approximation fractional operator, allows computationally efficient inference simulation. main functions computing rational approximation objects : fractional.operators()works general rational operators matern.operators() works random fields stationary Matern covariance functions spde.matern.operators() works random fields defined solutions possibly non-stationary Matern-type SPDE model. rspde.matern() R-INLA implementation covariance-based rational approximation random fields stationary Matern covariance functions Basic statistical operations likelihood evaluations (see [rSPDE.loglike], [rSPDE.matern.loglike]) kriging predictions (see [predict.rSPDEobj], [predict.CBrSPDEobj]) using rational approximations also implemented. illustration purposes, package contains simple FEM implementation models R. spatial models, FEM implementation R-INLA package recommended. detailed introduction package, see rSPDE Vignettes.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","title":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","text":"function evaluates log-likelihood function fractional SPDE model \\(L^\\beta u(s) = W\\) observed Gaussian measurement noise: \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables \\(x(s) = \\mu(s) + u(s)\\), \\(\\mu(s)\\) expectation vector latent field.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","text":"","code":"rSPDE.loglike(obj, Y, A, sigma.e, mu = 0)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","text":"obj rational SPDE approximation, computed using fractional.operators(), matern.operators(), spde.matern.operators(). Y observations, either vector matrix columns correspond independent replicates observations. observation matrix links measurement location finite element basis. sigma.e standard deviation measurement noise. mu Expectation vector latent field (default = 0).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","text":"log-likelihood value.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","text":"example shows function can used evaluate likelihood latent Matern model. Se matern.loglike() example can used maximum likelihood estimation.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","text":"","code":"# Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8 sigma.e <- 0.3  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation op <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem$G, C = fem$C, d = 1,   type = \"operator\" )  # Sample the model u <- simulate(op)  # Create some data obs.loc <- runif(n = 10, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) Y <- as.vector(A %*% u + sigma.e * rnorm(10))  # compute log-likelihood of the data lik1 <- rSPDE.loglike(op, Y, A, sigma.e) cat(lik1) #> -11.64524"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Object-based log-likelihood function for latent Gaussian fractional\nSPDE model using the rational approximations — rSPDE.matern.loglike","title":"Object-based log-likelihood function for latent Gaussian fractional\nSPDE model using the rational approximations — rSPDE.matern.loglike","text":"function evaluates log-likelihood function Gaussian process Matern covariance function, observed Gaussian measurement noise: \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables. latent model approximated using rational approximation fractional SPDE model corresponding Gaussian process.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Object-based log-likelihood function for latent Gaussian fractional\nSPDE model using the rational approximations — rSPDE.matern.loglike","text":"","code":"rSPDE.matern.loglike(   object,   Y,   A,   sigma.e,   mu = 0,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_m = NULL,   pivot = TRUE )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Object-based log-likelihood function for latent Gaussian fractional\nSPDE model using the rational approximations — rSPDE.matern.loglike","text":"object rational SPDE approximation, computed using matern.operators() Y observations, either vector matrix columns correspond independent replicates observations. observation matrix links measurement location finite element basis. sigma.e standard deviation measurement noise. mu Expectation vector latent field (default = 0). user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_m non-null, update order rational approximation, needs positive integer. pivot pivoting used Cholesky decompositions? Default TRUE","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Object-based log-likelihood function for latent Gaussian fractional\nSPDE model using the rational approximations — rSPDE.matern.loglike","text":"log-likelihood value.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Object-based log-likelihood function for latent Gaussian fractional\nSPDE model using the rational approximations — rSPDE.matern.loglike","text":"","code":"# this example illustrates how the function can be used for maximum # likelihood estimation  set.seed(123) # Sample a Gaussian Matern process on R using a rational approximation nu <- 0.8 kappa <- 5 sigma <- 1 sigma.e <- 0.1 n.rep <- 10 n.obs <- 100 n.x <- 51  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x)  tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))  # Compute the covariance-based rational approximation op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  # Sample the model u <- simulate(op_cov, n.rep)  # Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs * n.rep) dim(noise) <- c(n.obs, n.rep) Y <- as.matrix(A %*% u + sigma.e * noise)  # Define the negative likelihood function for optimization # using CBrSPDE.matern.loglike  # Notice that we are also using sigma instead of tau, so it can be compared # to matern.loglike() mlik_cov <- function(theta, Y, A, op_cov) {   kappa <- exp(theta[1])   sigma <- exp(theta[2])   nu <- exp(theta[3])   return(-rSPDE.matern.loglike(     object = op_cov, Y = Y,     A = A, user_kappa = kappa, user_sigma = sigma,     user_nu = nu, sigma.e = exp(theta[4])   )) }  # The parameters can now be estimated by minimizing mlik with optim # \\donttest{ # Choose some reasonable starting values depending on the size of the domain theta0 <- log(c(sqrt(8), 1 / sqrt(var(c(Y))), 0.9, 0.01))  # run estimation and display the results theta <- optim(theta0, mlik_cov,   Y = Y, A = A, op_cov = op_cov,   method = \"L-BFGS-B\" )  print(data.frame(   kappa = c(kappa, exp(theta$par[1])), sigma = c(sigma, exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) #>              kappa     sigma        nu   sigma.e #> Truth     5.000000 1.0000000 0.8000000 0.1000000 #> Estimates 6.041191 0.9609707 0.8684637 0.0986706 # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order-set.html","id":null,"dir":"Reference","previous_headings":"","what":"Changing the order of the rational approximation — rational.order<-","title":"Changing the order of the rational approximation — rational.order<-","text":"Changing order rational approximation","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order-set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Changing the order of the rational approximation — rational.order<-","text":"","code":"rational.order(x) <- value"},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order-set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Changing the order of the rational approximation — rational.order<-","text":"x CBrSPDE rpsde.inla object value order rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order-set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Changing the order of the rational approximation — rational.order<-","text":"object class new order rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the order of rational approximation. — rational.order","title":"Get the order of rational approximation. — rational.order","text":"Get order rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the order of rational approximation. — rational.order","text":"","code":"rational.order(object)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the order of rational approximation. — rational.order","text":"object CBrSPDEobj object inla_rspde object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the order of rational approximation. — rational.order","text":"order rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type-set.html","id":null,"dir":"Reference","previous_headings":"","what":"Changing the type of the rational approximation — rational.type<-","title":"Changing the type of the rational approximation — rational.type<-","text":"Changing type rational approximation","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type-set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Changing the type of the rational approximation — rational.type<-","text":"","code":"rational.type(x) <- value"},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type-set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Changing the type of the rational approximation — rational.type<-","text":"x CBrSPDE rpsde.inla object value type rational approximation. current options \"chebfun\", \"brasil\" \"chebfunLB\"","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type-set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Changing the type of the rational approximation — rational.type<-","text":"object class new rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type.html","id":null,"dir":"Reference","previous_headings":"","what":"Get type of rational approximation. — rational.type","title":"Get type of rational approximation. — rational.type","text":"Get type rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get type of rational approximation. — rational.type","text":"","code":"rational.type(object)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get type of rational approximation. — rational.type","text":"object CBrSPDEobj object inla_rspde object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get type of rational approximation. — rational.type","text":"type rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":null,"dir":"Reference","previous_headings":"","what":"Warnings free loading of add-on packages — require.nowarnings","title":"Warnings free loading of add-on packages — require.nowarnings","text":"Turn warnings require(), allow clean completion examples require unavailable Suggested packages.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Warnings free loading of add-on packages — require.nowarnings","text":"","code":"require.nowarnings(package, lib.loc = NULL, character.only = FALSE)"},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Warnings free loading of add-on packages — require.nowarnings","text":"package name package, given character string. lib.loc character vector describing location R library trees search , NULL.  default value NULL corresponds libraries currently known .libPaths(). Non-existent library trees silently ignored. character.logical indicating whether package can assumed character string.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Warnings free loading of add-on packages — require.nowarnings","text":"require.nowarnings returns (invisibly) TRUE succeeds, otherwise FALSE","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Warnings free loading of add-on packages — require.nowarnings","text":"require(package) acts require(package, quietly = TRUE) warnings turned . particular, warning error given package unavailable. cases use requireNamespace(package, quietly = TRUE) instead, produce warnings.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Warnings free loading of add-on packages — require.nowarnings","text":"","code":"## This should produce no output: if (require.nowarnings(nonexistent)) {   message(\"Package loaded successfully\") }"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":null,"dir":"Reference","previous_headings":"","what":"Observation/prediction matrices for rSPDE models. — rspde.make.A","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"Constructs observation/prediction weight matrices rSPDE models based inla.mesh inla.mesh.1d objects.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"","code":"rspde.make.A(   mesh = NULL,   loc = NULL,   A = NULL,   dim = NULL,   rspde_order = 2,   nu = NULL,   index = NULL,   group = NULL,   repl = 1L,   n.group = NULL,   n.repl = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"mesh inla.mesh inla.mesh.1d object. loc Locations, needed INLA mesh provided matrix standard SPDE approach, matrix returned inla.spde.make.. provided mesh provided. dim dimension. provided mesh provided. rspde_order order covariance-based rational SPDE approach. nu NULL, model assume nu estimated. nu fixed, provide value nu. index observation/prediction value, index loc. Default seq_len(nrow(.loc)). group observation/prediction value, index group model. repl observation/prediction value, replicate index. n.group size group model. n.repl total number replicates.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"\\(\\) matrix rSPDE models.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"","code":"# \\donttest{ # devel version if (requireNamespace(\"INLA\", quietly = TRUE)){ library(INLA)  set.seed(123) loc <- matrix(runif(100 * 2) * 100, 100, 2) mesh <- inla.mesh.2d(   loc = loc,   cutoff = 50,   max.edge = c(50, 500) ) A <- rspde.make.A(mesh, loc = loc, rspde_order = 3) } # devel.tag # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":null,"dir":"Reference","previous_headings":"","what":"rSPDE model index vector generation — rspde.make.index","title":"rSPDE model index vector generation — rspde.make.index","text":"Generates list named index vectors rSPDE model.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rSPDE model index vector generation — rspde.make.index","text":"","code":"rspde.make.index(   name,   n.spde = NULL,   n.group = 1,   n.repl = 1,   mesh = NULL,   rspde_order = 2,   nu = NULL,   dim = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rSPDE model index vector generation — rspde.make.index","text":"name character string base name effect. n.spde number basis functions mesh model. n.group size group model. n.repl total number replicates. mesh inla.mesh inla.mesh.1d object. rspde_order order rational approximation nu NULL, model assume nu estimated. nu fixed, provide value nu. dim dimension domain. provided mesh provided.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"rSPDE model index vector generation — rspde.make.index","text":"list named index vectors. name Indices vector latent variables name.group 'group' indices name.repl Indices replicates","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"rSPDE model index vector generation — rspde.make.index","text":"","code":"# \\donttest{ # devel version if (requireNamespace(\"INLA\", quietly = TRUE)){ library(INLA)  set.seed(123)  m <- 100 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   max.edge = c(0.1, 0.5) ) sigma <- 0.01 range <- 0.2 nu <- 0.8 kappa <- sqrt(8 * nu) / range op <- matern.operators(   mesh = mesh_2d, nu = nu,   kappa = kappa, sigma = sigma, m = 2 ) u <- simulate(op) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 y <- A %*% u + rnorm(m) * sigma.e Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d) st.dat <- inla.stack(   data = list(y = as.vector(y)),   A = Abar,   effects = mesh.index ) rspde_model <- rspde.matern(   mesh = mesh_2d,   nu_upper_bound = 2 ) f <- y ~ -1 + f(field, model = rspde_model) rspde_fit <- inla(f,   data = inla.stack.data(st.dat),   family = \"gaussian\",   control.predictor =     list(A = inla.stack.A(st.dat)),            inla.mode = \"experimental\" ) result <- rspde.result(rspde_fit, \"field\", rspde_model) plot(result) }    # devel.tag # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":null,"dir":"Reference","previous_headings":"","what":"Matern rSPDE model object for INLA — rspde.matern","title":"Matern rSPDE model object for INLA — rspde.matern","text":"Creates INLA object stationary Matern model general smoothness parameter.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matern rSPDE model object for INLA — rspde.matern","text":"","code":"rspde.matern(   mesh,   nu_upper_bound = 4,   rspde_order = 2,   nu = NULL,   sharp = TRUE,   debug = FALSE,   optimize = TRUE,   prior.kappa = NULL,   prior.nu = NULL,   prior.tau = NULL,   start.lkappa = NULL,   start.nu = NULL,   start.ltau = NULL,   prior.nu.dist = c(\"beta\", \"lognormal\"),   nu.prec.inc = 1,   type.rational.approx = c(\"chebfun\", \"brasil\", \"chebfunLB\") )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matern rSPDE model object for INLA — rspde.matern","text":"mesh mesh build model. inla.mesh inla.mesh.1d object. nu_upper_bound Upper bound smoothness parameter. rspde_order order covariance-based rational SPDE approach. nu nu set parameter, nu kept fixed estimated. nu NULL, estimated. sharp sparsity graph correct sparsity (costs perform sparsity analysis) upper bound sparsity? TRUE, graph correct sparsity. debug INLA debug argument. optimize model optimized? case sparsities matrices analyzed. prior.kappa list containing elements meanlog sdlog, , mean standard deviation log scale. prior.nu list containing elements mean prec beta distribution, loglocation logscale truncated lognormal distribution. loglocation stands location parameter truncated lognormal distribution log scale. prec stands precision beta distribution. logscale stands scale truncated lognormal distribution log scale. Check details . prior.tau list containing elements meanlog sdlog, , mean standard deviation log scale. start.lkappa Starting value log kappa. start.nu Starting value nu. start.ltau Starting value log tau. prior.nu.dist distribution smoothness parameter. current options \"beta\" \"lognormal\". default \"beta\". nu.prec.inc Amount increase precision beta prior distribution. Check details . type.rational.approx type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matern rSPDE model object for INLA — rspde.matern","text":"INLA model.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matern rSPDE model object for INLA — rspde.matern","text":"function constructs stationary Matern rSPDE model used INLA interface. parameters range parameter \\(\\kappa\\), smoothness parameter \\(\\nu\\) variance rescaling parameter \\(\\tau\\). model, upper bound smoothness parameter \\(\\nu\\) given. given nu_upper_bound argument. important notice larger value nu_upper_bound higher computational cost fit model. , generally best initially fit model small value nu_upper_bound increase really needed (instance, estimated smoothness parameter close nu_upper_bound). following parameterization used: $$\\log(\\tau) = \\theta_1,$$ $$\\log(\\kappa) = \\theta_2$$ \\(\\theta_3\\) can beta prior truncated lognormal prior distribution. case, prior distribution support interval \\((0,\\nu_{UB})\\), \\(\\nu_{UB}\\) nu_upper_bound. , following parameterization considered: $$\\log\\Big(\\frac{\\nu}{\\nu_{UB}-\\nu}\\Big) = \\theta_3.$$ default, optimized version model considered. optimized version generally much faster larger datasets, however takes time build model sparsity graph analyzed. However, small datasets, possible time taken analyze sparsity plus fitting model larger time taken fit unoptimized model. , small dataset might convenient set optimize=FALSE. way use optimized version reduce cost sparsity analysis set sharp FALSE. However, increase cost fitting model. Therefore, one usually benefit setting sharp argument FALSE fitting model large datasets. Finally, considering beta prior, beta distribution parameterized terms mean, say \\(\\mu\\) precision parameter \\(\\phi\\), variance beta distribution given \\(\\mu(\\nu_{UB}-\\mu)/(1+\\phi)\\). mean beta prior determined prior.nu$mean, whereas precision parameter determined prior.nu$prec. prior.nu$prec NULL (default case), precision parameter taken $$\\phi = \\max\\Big\\{\\frac{\\nu_{UB}}{\\mu}, \\frac{\\nu_{UB}}{\\nu_{UB}-\\mu}\\Big\\} + \\textrm{nu.prec.inc},$$ \\(\\mu\\) prior mean smoothness parameter. choice precision parameter ensure prior beta density boundary values equal zero (boundary values defined either continuity limits). Hence, higher value nu.prec.inc informative prior .","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matern rSPDE model object for INLA — rspde.matern","text":"","code":"# \\donttest{ # devel version if (requireNamespace(\"INLA\", quietly = TRUE)){ library(INLA)  # Organizing the data data(PRprec) data(PRborder)  Y <- rowMeans(PRprec[, 3 + 1:31]) ind <- !is.na(Y) Y <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) alt <- PRprec$Altitude[ind]  seaDist <- apply(   spDists(coords, PRborder[1034:1078, ], longlat = TRUE),   1, min )  # Creating INLA mesh prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(80, 80)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.6, 1.2), cutoff = 0.3)  # Building the A matrix Abar <- rspde.make.A(mesh = prmesh, loc = coords)  # Building the index mesh.index <- rspde.make.index(name = \"field\", mesh = prmesh)  # Creating the model rspde_model <- rspde.matern(mesh = prmesh)  # INLA stack stk.dat <- inla.stack(   data = list(y = Y), A = list(Abar, 1), tag = \"est\",   effects = list(     c(       mesh.index,       list(Intercept = 1)     ),     list(       long = inla.group(coords[, 1]),       lat = inla.group(coords[, 2]),       seaDist = inla.group(seaDist)     )   ) )  # INLA formula f.s <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model)  # Fitting the model rspde_fit <- inla(f.s,   family = \"Gamma\", data = inla.stack.data(stk.dat),   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat)),            inla.mode = \"experimental\" )  # The result summary(rspde_fit) } #>  #> Call: #>    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  #>    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  #>    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  #>    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  #>    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  #>    = control.compute, \", \" control.predictor = control.predictor,  #>    control.family = control.family, \", \" control.inla = control.inla,  #>    control.fixed = control.fixed, \", \" control.mode = control.mode,  #>    control.expert = control.expert, \", \" control.hazard = control.hazard,  #>    control.lincomb = control.lincomb, \", \" control.update =  #>    control.update, control.lp.scale = control.lp.scale, \", \"  #>    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  #>    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  #>    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  #>    working.directory = working.directory, \", \" silent = silent, inla.mode  #>    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  #>    .parent.frame)\")  #> Time used: #>     Pre = 4.04, Running = 15.4, Post = 0.0547, Total = 19.5  #> Fixed effects: #>            mean    sd 0.025quant 0.5quant 0.975quant  mode kld #> Intercept 0.648 0.015      0.618    0.648      0.679 0.648   0 #>  #> Random effects: #>   Name\t  Model #>     seaDist RW1 model #>    field RGeneric2 #>  #> Model hyperparameters: #>                                                   mean       sd 0.025quant #> Precision parameter for the Gamma observations   13.82    0.926     12.112 #> Precision for seaDist                          8551.74 5565.771   1912.459 #> Theta1 for field                                 -1.52    0.655     -2.816 #> Theta2 for field                                  1.47    0.330      0.834 #> Theta3 for field                                 -1.03    0.401     -1.820 #>                                                0.5quant 0.975quant    mode #> Precision parameter for the Gamma observations    13.78     15.760   13.69 #> Precision for seaDist                           7247.43  22886.273 4859.46 #> Theta1 for field                                  -1.51     -0.239   -1.50 #> Theta2 for field                                   1.47      2.132    1.45 #> Theta3 for field                                  -1.03     -0.243   -1.02 #>  #> Marginal log-Likelihood:  -1257.19  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') #>  # devel.tag # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Precision matrix of the covariance-based rational approximation of\nstationary Gaussian Matern random fields — rspde.matern.precision","title":"Precision matrix of the covariance-based rational approximation of\nstationary Gaussian Matern random fields — rspde.matern.precision","text":"rspde.matern.precision used computing precision matrix covariance-based rational SPDE approximation stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^(\\nu-1)\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h)$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Precision matrix of the covariance-based rational approximation of\nstationary Gaussian Matern random fields — rspde.matern.precision","text":"","code":"rspde.matern.precision(   kappa,   nu,   tau = NULL,   sigma = NULL,   rspde_order,   dim,   fem_mesh_matrices,   only_fractional = FALSE,   return_block_list = FALSE,   type_rational_approx = \"chebfun\" )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Precision matrix of the covariance-based rational approximation of\nstationary Gaussian Matern random fields — rspde.matern.precision","text":"kappa Range parameter covariance function. nu Shape parameter covariance function. tau Scale parameter covariance function. sigma provided, tau provided. sigma Standard deviation covariance function. tau provided, sigma provided. rspde_order order rational approximation dim dimension domain fem_mesh_matrices list containing FEM-related matrices. list contain elements c0, g1, g2, g3, etc. only_fractional Logical. fractional-order part precision matrix returned? return_block_list Logical. type = \"covariance\", block parts precision matrix returned separately list? type_rational_approx type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Precision matrix of the covariance-based rational approximation of\nstationary Gaussian Matern random fields — rspde.matern.precision","text":"precision matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Precision matrix of the covariance-based rational approximation of\nstationary Gaussian Matern random fields — rspde.matern.precision","text":"","code":"set.seed(123) nobs <- 101 x <- seq(from = 0, to = 1, length.out = nobs) fem <- rSPDE.fem1d(x) kappa <- 40 sigma <- 1 d <- 1 nu <- 2.6 tau <- sqrt(gamma(nu) / (kappa^(2 * nu) * (4 * pi)^(d / 2) * gamma(nu + d / 2))) op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu, kappa = kappa, sigma = sigma,   d = 1, m = 2, compute_higher_order = TRUE ) v <- t(rSPDE.A1d(x, 0.5)) c.true <- matern.covariance(abs(x - 0.5), kappa, nu, sigma) Q <- rspde.matern.precision(   kappa = kappa, nu = nu, tau = tau, rspde_order = 2, d = 1,   fem_mesh_matrices = op_cov$fem_mesh_matrices ) A <- Diagonal(nobs) Abar <- cbind(A, A, A) w <- rbind(v, v, v) c.approx_cov <- (Abar) %*% solve(Q, w)  # plot the result and compare with the true Matern covariance plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma),   type = \"l\", ylab = \"C(h)\",   xlab = \"h\", main = \"Matern covariance and rational approximations\" ) lines(x, c.approx_cov, col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":null,"dir":"Reference","previous_headings":"","what":"Precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer","title":"Precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer","text":"rspde.matern.precision.integer.opt used computing precision matrix stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^(\\nu-1)\\Gamma(\\nu)} (\\kappa h)^\\nu K_\\nu(\\kappa h)$$, \\(\\alpha = \\nu + d/2\\) natural number.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer","text":"","code":"rspde.matern.precision.integer(   kappa,   nu,   tau = NULL,   sigma = NULL,   dim,   fem_mesh_matrices )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer","text":"kappa Range parameter covariance function. nu Shape parameter covariance function. tau Scale parameter covariance function. sigma Standard deviation covariance function. tau provided, sigma provided. dim dimension domain fem_mesh_matrices list containing FEM-related matrices. list contain elements c0, g1, g2, g3, etc.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer","text":"precision matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer","text":"","code":"set.seed(123) nobs <- 101 x <- seq(from = 0, to = 1, length.out = nobs) fem <- rSPDE.fem1d(x) kappa <- 40 sigma <- 1 d <- 1 nu <- 0.5 tau <- sqrt(gamma(nu) / (kappa^(2 * nu) * (4 * pi)^(d / 2) * gamma(nu + d / 2))) op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu, kappa = kappa, sigma = sigma,   d = 1, m = 2 ) v <- t(rSPDE.A1d(x, 0.5)) c.true <- matern.covariance(abs(x - 0.5), kappa, nu, sigma) Q <- rspde.matern.precision.integer(   kappa = kappa, nu = nu, tau = tau, d = 1,   fem_mesh_matrices = op_cov$fem_mesh_matrices ) A <- Diagonal(nobs) c.approx_cov <- A %*% solve(Q, v)  # plot the result and compare with the true Matern covariance plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma),   type = \"l\", ylab = \"C(h)\",   xlab = \"h\", main = \"Matern covariance and rational approximations\" ) lines(x, c.approx_cov, col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.opt.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimized precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer.opt","title":"Optimized precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer.opt","text":"rspde.matern.precision.integer.opt used computing optimized version precision matrix stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h),$$ \\(\\alpha = \\nu + d/2\\) natural number.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.opt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimized precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer.opt","text":"","code":"rspde.matern.precision.integer.opt(   kappa,   nu,   tau,   d,   fem_matrices,   graph = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.opt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimized precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer.opt","text":"kappa Range parameter covariance function. nu Shape parameter covariance function. tau Scale parameter covariance function. d dimension domain fem_matrices list containing FEM-related matrices. list contain elements C, G, G_2, G_3, etc. graph sparsity graph matrices. NULL, vector elements returned, non-NULL, sparse matrix returned.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.opt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimized precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer.opt","text":"precision matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.opt.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimized precision matrix of the covariance-based rational\napproximation — rspde.matern.precision.opt","title":"Optimized precision matrix of the covariance-based rational\napproximation — rspde.matern.precision.opt","text":"rspde.matern.precision used computing optimized version precision matrix covariance-based rational SPDE approximation stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h).$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.opt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimized precision matrix of the covariance-based rational\napproximation — rspde.matern.precision.opt","text":"","code":"rspde.matern.precision.opt(   kappa,   nu,   tau,   rspde_order,   dim,   fem_matrices,   graph = NULL,   sharp,   type_rational_approx )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.opt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimized precision matrix of the covariance-based rational\napproximation — rspde.matern.precision.opt","text":"kappa Range parameter covariance function. nu Shape parameter covariance function. tau Scale parameter covariance function. rspde_order order rational approximation dim dimension domain fem_matrices list containing FEM-related matrices. list contain elements C, G, G_2, G_3, etc. graph sparsity graph matrices. NULL, vector elements returned, non-NULL, sparse matrix returned. sharp sparsity graph correct sparsity (costs perform sparsity analysis) upper bound sparsity? type_rational_approx type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.opt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimized precision matrix of the covariance-based rational\napproximation — rspde.matern.precision.opt","text":"precision matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a lattice projection to/from an inla.mesh for\nrSPDE objects — rspde.mesh.project","title":"Calculate a lattice projection to/from an inla.mesh for\nrSPDE objects — rspde.mesh.project","text":"Calculate lattice projection /inla.mesh rSPDE objects","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a lattice projection to/from an inla.mesh for\nrSPDE objects — rspde.mesh.project","text":"","code":"rspde.mesh.project(...)  rspde.mesh.projector(   mesh,   nu = NULL,   rspde_order = 2,   loc = NULL,   lattice = NULL,   xlim = NULL,   ylim = NULL,   dims = c(100, 100),   projection = NULL,   ... )  # S3 method for inla.mesh rspde.mesh.project(   mesh,   loc = NULL,   field = NULL,   rspde_order = 2,   nu = NULL,   ... )  # S3 method for rspde.mesh.projector rspde.mesh.project(projector, field, ...)  # S3 method for inla.mesh.1d rspde.mesh.project(mesh, loc, field = NULL, rspde_order = 2, nu = NULL, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a lattice projection to/from an inla.mesh for\nrSPDE objects — rspde.mesh.project","text":"... Additional parameters. mesh inla.mesh inla.mesh.1d object. nu smoothness parameter. NULL, assumed nu estimated. rspde_order order rational approximation. loc Projection locations. Can matrix SpatialPoints SpatialPointsDataFrame object. lattice inla.mesh.lattice object. xlim X-axis limits lattice. R2 meshes, defaults covering domain. ylim Y-axis limits lattice. R2 meshes, defaults covering domain. dims Lattice dimensions. projection One c(\"default\", \"longlat\", \"longsinlat\", \"mollweide\"). field Basis function weights, one per mesh basis function, describing function evaluated projection locations. projector rspde.mesh.projector object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a lattice projection to/from an inla.mesh for\nrSPDE objects — rspde.mesh.project","text":"list projection information rspde.mesh.project. rspde.mesh.projector(mesh, ...), rspde.mesh.projector object. rspde.mesh.project(projector, field, ...), field projected mesh onto locations given projector object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate a lattice projection to/from an inla.mesh for\nrSPDE objects — rspde.mesh.project","text":"function built upon inla.mesh.project inla.mesh.projector functions INLA.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Precision matrices for inla_rspde objects — rspde.precision","title":"Precision matrices for inla_rspde objects — rspde.precision","text":"Precision matrices rSPDE models Calculates precision matrix given parameter values based inla_rspde model object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Precision matrices for inla_rspde objects — rspde.precision","text":"","code":"rspde.precision(rspde, theta, optimized = FALSE)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Precision matrices for inla_rspde objects — rspde.precision","text":"rspde inla_rspde object. theta parameter vector. See details rspde.matern() see parameterizations. optimized Logical indicating elements (x slot) precision matrix returned.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Precision matrices for inla_rspde objects — rspde.precision","text":"sparse precision matrix.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.precision.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Precision matrices for inla_rspde objects — rspde.precision","text":"","code":"# \\donttest{ # devel version if (requireNamespace(\"INLA\", quietly = TRUE)){ library(INLA)  set.seed(1) n <- 10  coords <- cbind(long = sample(1:n), lat = sample(1:n))  mesh <- inla.mesh.2d(coords, max.edge = c(20, 40)) rspde_model_int <- rspde.matern(mesh = mesh, nu = 1)  prec_int <- rspde.precision(rspde_model_int, theta = log(c(1, 3)))  rspde_model <- rspde.matern(mesh) prec <- rspde.precision(rspde_model, theta = log(c(1, 3, 1.2))) } #> as(<dgCMatrix>, \"dgTMatrix\") is deprecated since Matrix 1.5-0; do as(., \"TsparseMatrix\") instead # devel.tag # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":null,"dir":"Reference","previous_headings":"","what":"rSPDE result extraction from INLA estimation results — rspde.result","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"Extract field parameter values distributions rspde effect inla result object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"","code":"rspde.result(inla, name, rspde, compute.summary = TRUE)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"inla inla object obtained call inla(). name character string name rSPDE effect inla formula. rspde inla_rspde object used effect inla formula. compute.summary summary computed?","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"Returns list containing: marginals.kappa Marginal densities kappa marginals.log.kappa Marginal densities log(kappa) marginals.log.tau Marginal densities log(tau) marginals.tau Marginal densities tau marginals.values Marginal densities field values summary.log.kappa Summary statistics log(kappa) summary.log.tau Summary statistics log(tau) summary.values Summary statistics field values nu estimated, list also contain marginals.nu Marginal densities nu nu estimated beta prior used, list also contain marginals.logit.nu Marginal densities logit(nu) summary.logit.nu Marginal densities logit(nu) nu estimated truncated lognormal prior used, list also contain marginals.log.nu Marginal densities log(nu) summary.log.nu Marginal densities log(nu) compute.summary TRUE, list also contain summary.kappa Summary statistics kappa summary.tau Summary statistics tau nu estimated compute.summary TRUE, list also contain summary.nu Summary statistics nu","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"","code":"# \\donttest{ # devel version if (requireNamespace(\"INLA\", quietly = TRUE)){ library(INLA)  set.seed(123)  m <- 100 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   max.edge = c(0.1, 0.5) ) sigma <- 0.01 range <- 0.2 nu <- 0.8 kappa <- sqrt(8 * nu) / range op <- matern.operators(   mesh = mesh_2d, nu = nu,   kappa = kappa, sigma = sigma, m = 2 ) u <- simulate(op) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 y <- A %*% u + rnorm(m) * sigma.e Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d) st.dat <- inla.stack(   data = list(y = as.vector(y)),   A = Abar,   effects = mesh.index ) rspde_model <- rspde.matern(   mesh = mesh_2d,   nu_upper_bound = 2 ) f <- y ~ -1 + f(field, model = rspde_model) rspde_fit <- inla(f,   data = inla.stack.data(st.dat),   family = \"gaussian\",   control.predictor =     list(A = inla.stack.A(st.dat)),            inla.mode = \"experimental\" ) result <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result) plot(result) }    # devel.tag # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation of a fractional SPDE using the\ncovariance-based rational SPDE approximation — simulate.CBrSPDEobj","title":"Simulation of a fractional SPDE using the\ncovariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"function samples Gaussian random field based using covariance-based rational SPDE approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation of a fractional SPDE using the\ncovariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"","code":"# S3 method for CBrSPDEobj simulate(   object,   nsim = 1,   seed = NULL,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_m = NULL,   pivot = TRUE,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation of a fractional SPDE using the\ncovariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"object covariance-based rational SPDE approximation, computed using matern.operators() nsim number simulations. seed object specifying random number generator initialized (‘seeded’). user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_m non-null, update order rational approximation, needs positive integer. pivot pivoting used Cholesky decompositions? Default TRUE ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation of a fractional SPDE using the\ncovariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"matrix n samples columns.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation of a fractional SPDE using the\ncovariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"","code":"# Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi)^(1 / 2) * gamma(nu + 1 / 2))) op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  # Sample the model and plot the result Y <- simulate(op_cov) plot(x, Y, type = \"l\", ylab = \"u(x)\", xlab = \"x\")"},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate.rSPDEobj","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate.rSPDEobj","text":"function samples Gaussian random field based pre-computed rational SPDE approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate.rSPDEobj","text":"","code":"# S3 method for rSPDEobj simulate(object, nsim = 1, seed = NULL, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate.rSPDEobj","text":"object rational SPDE approximation, computed using fractional.operators(), matern.operators(), spde.matern.operators(). nsim number simulations. seed object specifying random number generator initialized (‘seeded’). ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate.rSPDEobj","text":"matrix n samples columns.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate.rSPDEobj","text":"","code":"# Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation op <- matern.operators(   kappa = kappa, sigma = sigma,   nu = nu, G = fem$G, C = fem$C, d = 1 )  # Sample the model and plot the result Y <- simulate(op) plot(x, Y, type = \"l\", ylab = \"u(x)\", xlab = \"x\")"},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","text":"function evaluates log-likelihood function observations Gaussian process defined solution SPDE $$(\\kappa(s) - \\Delta)^\\beta (\\tau(s)u(s)) = W.$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","text":"","code":"spde.matern.loglike(kappa, tau, nu, sigma.e, Y, G, C, A, d = 2, m = 1)"},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","text":"kappa Vector , possibly spatially varying, range parameter evaluated locations mesh used finite element discretization SPDE. tau Vector , possibly spatially varying, precision parameter evaluated locations mesh used finite element discretization SPDE. nu Shape parameter covariance function, related \\(\\beta\\) equation \\(\\beta = (\\nu + d/2)/2\\). sigma.e standard deviation measurement noise. Y observations, either vector matrix columns correspond independent replicates observations. G stiffness matrix finite element discretization domain. C mass matrix finite element discretization domain. matrix linking measurement locations basis FEM approximation latent model. d dimension domain. default value 2. m order rational approximation, needs positive integer. default value 1.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","text":"log-likelihood value.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","text":"observations assumed generated \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables. latent model approximated using rational approximation fractional SPDE model.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","text":"","code":"# this example illustrates how the function can be used for maximum # likelihood estimation set.seed(123) # Sample a Gaussian Matern process on R using a rational approximation sigma.e <- 0.1 n.rep <- 10 n.obs <- 100 n.x <- 51  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x)  tau <- rep(0.5, n.x) nu <- 0.8 kappa <- rep(1, n.x)  # compute rational approximation op <- spde.matern.operators(   kappa = kappa, tau = tau, nu = nu,   G = fem$G, C = fem$C, d = 1 )  # Sample the model u <- simulate(op, n.rep)  # Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs * n.rep) dim(noise) <- c(n.obs, n.rep) Y <- as.matrix(A %*% u + sigma.e * noise)  # define negative likelihood function for optimization using matern.loglike mlik <- function(theta, Y, G, C, A) {   return(-spde.matern.loglike(rep(exp(theta[1]), n.x),     rep(exp(theta[2]), n.x),     exp(theta[3]), exp(theta[4]),     Y = Y, G = G, C = C, A = A, d = 1   )) }  #' #The parameters can now be estimated by minimizing mlik with optim # \\donttest{ # Choose some reasonable starting values depending on the size of the domain theta0 <- log(c(sqrt(8), 1 / sqrt(var(c(Y))), 0.9, 0.01))  # run estimation and display the results theta <- optim(theta0, mlik, Y = Y, G = fem$G, C = fem$C, A = A)  print(data.frame(   kappa = c(kappa[1], exp(theta$par[1])), tau = c(tau[1], exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) #>              kappa       tau        nu   sigma.e #> Truth     1.000000 0.5000000 0.8000000 0.1000000 #> Estimates 1.254077 0.5437648 0.7929743 0.0987481 # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"spde.matern.operators used computing rational SPDE approximation Gaussian random fields \\(R^d\\) defined solution SPDE $$(\\kappa(s) - \\Delta)^\\beta (\\tau(s)u(s)) = W.$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"","code":"spde.matern.operators(kappa, tau, nu, G, C, d, m = 1)"},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"kappa Vector , possibly spatially varying, range parameter evaluated locations mesh used finite element discretization SPDE. tau Vector , possibly spatially varying, precision parameter evaluated locations mesh used finite element discretization SPDE. nu Shape parameter covariance function, related \\(\\beta\\) equation \\(\\beta = (\\nu + d/2)/2\\). G stiffness matrix finite element discretization domain interest. C mass matrix finite element discretization domain interest. d dimension domain. m order rational approximation, needs positive integer. default value 1.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"spde.matern.operators returns object class \"rSPDEobj. object contains quantities listed output fractional.operators() well smoothness parameter \\(\\nu\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"approximation based rational approximation fractional operator \\((\\kappa(s)^2 -\\Delta)^\\beta\\), \\(\\beta = (\\nu + d/2)/2\\). results approximate model form $$P_l u(s) = P_r W,$$ \\(P_j = p_j(L)\\) non-fractional operators defined terms polynomials \\(p_j\\) \\(j=l,r\\). order \\(p_r\\) given m order \\(p_l\\) \\(m + m_\\beta\\) \\(m_\\beta\\) integer part \\(\\beta\\) \\(\\beta>1\\) \\(m_\\beta = 1\\) otherwise. discrete approximation can written \\(u = P_r x\\) \\(x \\sim N(0,Q^{-1})\\) \\(Q = P_l^T C^{-1} P_l\\). Note matrices \\(P_r\\) \\(Q\\) may ill-conditioned \\(m>1\\). case, metehods operator.operations() used operations involving matrices, since methods numerically stable.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"","code":"# Sample non-stationary Matern field on R tau <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # define a non-stationary range parameter kappa <- seq(from = 2, to = 20, length.out = length(x))  # compute rational approximation op <- spde.matern.operators(   kappa = kappa, tau = tau, nu = nu,   G = fem$G, C = fem$C, d = 1 )  # sample the field u <- simulate(op)  # plot the sample plot(x, u, type = \"l\", ylab = \"u(s)\", xlab = \"s\")"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise CBrSPDE objects — summary.CBrSPDEobj","title":"Summarise CBrSPDE objects — summary.CBrSPDEobj","text":"Summary method class \"CBrSPDEobj\"","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise CBrSPDE objects — summary.CBrSPDEobj","text":"","code":"# S3 method for CBrSPDEobj summary(object, ...)  # S3 method for summary.CBrSPDEobj print(x, ...)  # S3 method for CBrSPDEobj print(x, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise CBrSPDE objects — summary.CBrSPDEobj","text":"object object class \"CBrSPDEobj\", usually, result call matern.operators(). ... arguments passed methods. x object class \"summary.CBrSPDEobj\", usually, result call summary.CBrSPDEobj().","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise CBrSPDE objects — summary.CBrSPDEobj","text":"","code":"# Compute the covariance-based rational approximation of a # Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi)^(1 / 2) * gamma(nu + 1 / 2))) op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  op_cov #> Type of approximation:  Covariance-Based Matern SPDE approximation  #> Type of rational approximation:  chebfun  #> Parameters of covariance function: kappa =  10 , sigma =  1 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise rSPDE objects — summary.rSPDEobj","title":"Summarise rSPDE objects — summary.rSPDEobj","text":"Summary method class \"rSPDEobj\"","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise rSPDE objects — summary.rSPDEobj","text":"","code":"# S3 method for rSPDEobj summary(object, ...)  # S3 method for summary.rSPDEobj print(x, ...)  # S3 method for rSPDEobj print(x, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise rSPDE objects — summary.rSPDEobj","text":"object object class \"rSPDEobj\", usually, result call fractional.operators(), matern.operators(), spde.matern.operators(). ... arguments passed methods. x object class \"summary.rSPDEobj\", usually, result call summary.rSPDEobj().","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde.result.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde.result object — summary.rspde.result","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde.result object — summary.rspde.result","text":"Summary posteriors rSPDE field parameters original scales.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde.result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde.result object — summary.rspde.result","text":"","code":"# S3 method for rspde.result summary(object, digits = 6, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde.result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde.result object — summary.rspde.result","text":"object rspde.result object. digits integer, used number formatting signif() ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde.result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde.result object — summary.rspde.result","text":"Returns data.frame containing summary.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde.result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde.result object — summary.rspde.result","text":"","code":"# \\donttest{ # devel version if (requireNamespace(\"INLA\", quietly = TRUE)){ library(INLA)  set.seed(123)  m <- 100 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   max.edge = c(0.1, 0.5) ) sigma <- 0.01 range <- 0.2 nu <- 0.8 kappa <- sqrt(8 * nu) / range op <- matern.operators(   mesh = mesh_2d, nu = nu,   kappa = kappa, sigma = sigma, m = 2 ) u <- simulate(op) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 y <- A %*% u + rnorm(m) * sigma.e Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d) st.dat <- inla.stack(   data = list(y = as.vector(y)),   A = Abar,   effects = mesh.index ) rspde_model <- rspde.matern(   mesh = mesh_2d,   nu_upper_bound = 2 ) f <- y ~ -1 + f(field, model = rspde_model) rspde_fit <- inla(f,   data = inla.stack.data(st.dat),   family = \"gaussian\",   control.predictor =     list(A = inla.stack.A(st.dat)),            inla.mode = \"experimental\" ) result <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result) } #>              mean          sd  0.025quant    0.5quant  0.975quant        mode #> tau    0.00245448  0.00535423 3.97026e-07 7.52119e-04   0.0157284 4.12817e-06 #> kappa 56.49840000 26.89400000 1.82968e+01 5.19359e+01 121.6140000 4.28549e+01 #> nu     1.92608000  0.02625360 1.86902e+00 1.92851e+00   1.9703800 1.93385e+00 # devel.tag # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"Function change parameters CBrSPDEobj object","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"","code":"# S3 method for CBrSPDEobj update(   object,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_m = NULL,   compute_higher_order = object$higher_order,   type_rational_approximation = object$type_rational_approximation,   return_block_list = object$return_block_list,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"object covariance-based rational SPDE approximation, computed using matern.operators() user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_m non-null, update order rational approximation, needs positive integer. compute_higher_order Logical. higher order finite element matrices computed? type_rational_approximation type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\". return_block_list Logical. type = \"covariance\", block parts precision matrix returned separately list? ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"returns object class \"CBrSPDEobj. object contains quantities listed output matern.operators().","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"","code":"# Compute the covariance-based rational approximation of a # Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 ) op_cov #> Type of approximation:  Covariance-Based Matern SPDE approximation  #> Type of rational approximation:  chebfun  #> Parameters of covariance function: kappa =  10 , sigma =  1 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101   # Update the range parameter of the model: op_cov <- update(op_cov, user_kappa = 20) op_cov #> Type of approximation:  Covariance-Based Matern SPDE approximation  #> Type of rational approximation:  chebfun  #> Parameters of covariance function: kappa =  20 , sigma =  1 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101"},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Update parameters of rSPDEobj objects — update.rSPDEobj","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"Function change parameters rSPDEobj object","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"","code":"# S3 method for rSPDEobj update(   object,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_m = NULL,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"object operator-based rational SPDE approximation, computed using matern.operators() type=\"operator\" user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_m non-null, update order rational approximation, needs positive integer. ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"returns object class \"rSPDEobj. object contains quantities listed output matern.operators().","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"","code":"# Compute the operator-based rational approximation of a # Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 op <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2, type = \"operator\" ) op #> Type of approximation:  Matern approximation  #> Parametres of covariance function: kappa =  10 , sigma =  1 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101   # Update the range parameter of the model: op <- update(op, user_kappa = 20) op #> Type of approximation:  Matern approximation  #> Parametres of covariance function: kappa =  20 , sigma =  1 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-120","dir":"Changelog","previous_headings":"","what":"rSPDE 1.2.0","title":"rSPDE 1.2.0","text":"Added inlabru interface Added “rational.order” “rational.type” functions Added BRASIL rational approximation Improved covariance-based operator objects Improved log-likelihood computation Created 2d folded Matern different boundary conditions. Implemented different boundary conditions 1d folded Matern.","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-111","dir":"Changelog","previous_headings":"","what":"rSPDE 1.1.1","title":"rSPDE 1.1.1","text":"CRAN release: 2022-01-14 Adjusts donttest examples CRAN.","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-110","dir":"Changelog","previous_headings":"","what":"rSPDE 1.1.0","title":"rSPDE 1.1.0","text":"Minor typos vignettes man pages corrected. examples changed improve numerical stability.","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-100","dir":"Changelog","previous_headings":"","what":"rSPDE 1.0.0","title":"rSPDE 1.0.0","text":"CRAN release: 2021-12-13 Implementation covariance-based rational approximation stationary Matérn models. R-INLA implementation rational SPDE approach Added introduction rSPDE vignette previous vignette updated became operator-based rational approximation vignette. Added vignette R-INLA implementation SPDE approach Added vignette present rational approximation using rSPDE package Backward compatibility maintained.","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-063","dir":"Changelog","previous_headings":"","what":"rSPDE 0.6.3","title":"rSPDE 0.6.3","text":"CRAN release: 2021-10-14 Change inline citations Vignette avoid problems CRAN","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-062","dir":"Changelog","previous_headings":"","what":"rSPDE 0.6.2","title":"rSPDE 0.6.2","text":"CRAN release: 2021-02-23","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-061","dir":"Changelog","previous_headings":"","what":"rSPDE 0.6.1","title":"rSPDE 0.6.1","text":"Add rgdal suggested package","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-050","dir":"Changelog","previous_headings":"","what":"rSPDE 0.5.0","title":"rSPDE 0.5.0","text":"Remove dependency INLA Vignette CRAN Update citation","code":""}]
