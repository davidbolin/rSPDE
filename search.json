[{"path":"https://davidbolin.github.io/rSPDE/articles/build_source.html","id":"building-from-source","dir":"Articles","previous_headings":"","what":"Building from source","title":"Building the rSPDE package from source on Mac and Linux","text":"build rSPDE source need obtain GitHub version. dependencies (see install ), can install rSPDE package source running following command R:","code":"remotes::install_github(\"davidbolin/rspde\", ref = \"devel\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/build_source.html","id":"dependencies-on-linux","dir":"Articles","previous_headings":"","what":"Dependencies on Linux","title":"Building the rSPDE package from source on Mac and Linux","text":"rSPDE package depends Eigen C++ library. install Eigen Ubuntu, run: install Eigen Arch-Linux Manjaro, run: install Eigen Red Hat, Fedor CentOS, run: install Eigen OpenSuse, run:","code":"sudo apt install libeigen3-dev sudo pacman -S eigen3 sudo yum install eigen3-devel sudo zypper install eigen3-devel"},{"path":"https://davidbolin.github.io/rSPDE/articles/build_source.html","id":"dependencies-on-mac","dir":"Articles","previous_headings":"","what":"Dependencies on Mac","title":"Building the rSPDE package from source on Mac and Linux","text":"can install Eigen MacOS Homebrew. install Homebrew, run: install Eigen using Homebrew, run:","code":"/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" brew install eigen"},{"path":"https://davidbolin.github.io/rSPDE/articles/build_source.html","id":"adjusting-the-makefile","dir":"Articles","previous_headings":"","what":"Adjusting the Makefile","title":"Building the rSPDE package from source on Mac and Linux","text":"experience trouble installing rSPDE package, might need adjust Makefile. , need rSPDE source files locally computer. end, can, instance, close rSPDE repository running following command terminal: can also download source files. Now, let us discuss Makefile. Makefile following base form:","code":"git clone https://github.com/davidbolin/rSPDE.git toInclude = ${R_LIBRARY_DIR}/INLA/include/  obj = cgeneric_mvnormdens.o cgeneric_aux_nonstat.o cgeneric_aux_nonstat_fixed.o \\       cgeneric_rspde_stat_frac_model.o cgeneric_rspde_nonstat_general.o \\       cgeneric_rspde_stat_general.o cgeneric_rspde_stat_parsim_gen.o \\       cgeneric_rspde_stat_parsim_fixed.o cgeneric_rspde_stat_int.o \\       cgeneric_rspde_nonstat_gen_fixed.o cgeneric_rspde_nonstat_int.o \\       cgeneric_aux_nonstat_int.o  all : rSPDE.so  CC = clang CXX = clang++  EIGEN_MAC = /usr/local/include/eigen3/ EIGEN_LINUX = /usr/include/eigen3/  flags = -O2 -Wall -Wextra -fpic  %.o: %.c     $(CC) $(flags) -Iinclude -I$(toInclude)  -c $^ -o $@  %.o: %.cpp     $(CXX) $(flags)  -I$(toInclude) -I$(EIGEN_MAC) -I$(EIGEN_LINUX) -c $^ -o $@  rSPDE.so: $(obj)     $(CXX) -shared *.o -o ../inst/shared/rspde_cgeneric_models.so -lblas -llapack  clean :     rm -f *.o  .PHONY: all clean"},{"path":"https://davidbolin.github.io/rSPDE/articles/build_source.html","id":"adjusts-on-linux","dir":"Articles","previous_headings":"Adjusting the Makefile","what":"Adjusts on Linux","title":"Building the rSPDE package from source on Mac and Linux","text":"linux, recommend use gcc-12 g++-12 compilers. end, one must install gcc g++, change following lines Makefile: One also confirm location Eigen library. default location /usr/include/eigen3/ already set Makefile. Eigen installed different location, need update Makefile changing EIGEN_LINUX variable: install gcc g++ Ubuntu, run install gcc g++ Arch-Linux Manjaro, run: install gcc g++ Red Hat, Fedor CentOS, run: install gcc g++ OpenSuse, run:","code":"CC = gcc CXX = g++ EIGEN_LINUX = /correct_path/ sudo apt install gcc g++ sudo pacman -S gcc g++ sudo yum install gcc g++ sudo zypper install gcc g++"},{"path":"https://davidbolin.github.io/rSPDE/articles/build_source.html","id":"adjusts-on-mac","dir":"Articles","previous_headings":"Adjusting the Makefile","what":"Adjusts on Mac","title":"Building the rSPDE package from source on Mac and Linux","text":"Mac, especially intel processors, found stable compiler clang clang++. Thus, one must following lines Makefile: One also confirm location Eigen library. default location /usr/local already set Makefile. installed Eigen using Homebrew, can check location Eigen installation using following command: can, , update EIGEN_MAC variable Makefile correct path.","code":"CC = clang CXX = clang++ brew --prefix eigen"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"An introduction to the rSPDE package","text":"vignette provide brief introduction rSPDE package. main approach constructing rational approximations covariance-based rational SPDE approach Xiong, Simas, Bolin (2022). package contains three main “families” functions implement approach: interface R-INLA; interface inlabru; stand-alone implementation approach. illustrate different functions, begin using package generate simple data set, analyzed using different approaches. details family functions given following additional vignettes: R-INLA implementation rational SPDE approach inlabru implementation rational SPDE approach Rational approximation rSPDE package rSPDE package also separate group functions performing operator-based rational approximations introduced Bolin Kirchner (2020). especially useful performing rational approximations fractional SPDE models non-Gaussian noise. example approximation suitable one -called type-G Lévy noises. refer reader Wallin Bolin (2015), Bolin (2013) Asar et al. (2020) examples models driven type-G Lévy noises. also refer reader ngme package one can fit models. explore functions performing operator-based rational approximation vignette: Operator-based rational approximation rSPDE package","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"a-toy-data-set","dir":"Articles","previous_headings":"","what":"A toy data set","title":"An introduction to the rSPDE package","text":"begin generating toy data set. illustration, simulate data set two-dimensional spatial domain. end, need construct mesh domain interest compute matrices needed define operator. use R-INLA package create mesh obtain matrices interest. begin defining mesh \\([0,1]\\times [0, 1]\\):  now use matern.operators() function construct rational SPDE approximation order \\(m=2\\) Gaussian random field Matérn covariance function \\([0,1]\\times [0, 1]\\). choose \\(\\nu=0.5\\) corresponds exponential covariance. also set \\(\\sigma=1\\) range \\(0.2\\). can now use simulate function simulate realization field \\(u\\): Let us now consider simple Gaussian linear model spatial field \\(u(\\mathbf{s})\\) observed \\(m\\) locations, \\(\\{\\mathbf{s}_1 , \\ldots , \\mathbf{s}_m \\}\\) Gaussian measurement noise. \\(= 1,\\ldots,m,\\) \\[ \\begin{align} y_i &= u(\\mathbf{s}_i)+\\varepsilon_i\\\\ \\end{align}, \\] \\(\\varepsilon_1,\\ldots,\\varepsilon_{m}\\) iid normally distributed mean 0 standard deviation 0.1. generate data set y model, first draw observation locations random domain use R-INLA function inla.spde.make.() construct observation matrix can used evaluate simulated field \\(u\\) observation locations. simply add measurment noise. generated data can seen following image.  simulated random field shown following figure.","code":"library(INLA) n_loc <- 2000 loc_2d_mesh <- matrix(runif(n_loc * 2), n_loc, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   max.edge = c(0.1, 0.5) ) plot(mesh_2d, main = \"\") library(rSPDE) sigma <- 1 range <- 0.2 nu <- 0.5 kappa <- sqrt(8 * nu) / range op <- matern.operators(   mesh = mesh_2d, nu = nu,   kappa = kappa, sigma = sigma, m = 2 ) tau <- op$tau u <- simulate(op) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 y <- A %*% u + rnorm(n_loc) * sigma.e library(ggplot2) library(viridis) #> Loading required package: viridisLite df <- data.frame(x1 = as.double(loc_2d_mesh[, 1]),   x2 = as.double(loc_2d_mesh[, 2]), y = as.double(y)) ggplot(df, aes(x = x1, y = x2, col = y)) +   geom_point() +   scale_color_viridis() proj <- inla.mesh.projector(mesh_2d, dims = c(100, 100)) field <- inla.mesh.project(proj, field = as.vector(u)) field.df <- data.frame(x1 = proj$lattice$loc[,1],                         x2 = proj$lattice$loc[,2],                          y = as.vector(field)) ggplot(field.df, aes(x = x1, y = x2, fill = y)) +   geom_raster() + xlim(0,1) + ylim(0,1) +    scale_fill_viridis()"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"fitting-the-model-with-r-inla-implementation-of-the-rational-spde-approach","dir":"Articles","previous_headings":"","what":"Fitting the model with R-INLA implementation of the rational SPDE approach","title":"An introduction to the rSPDE package","text":"now fit model toy data set using R-INLA implementation rational SPDE approach. details implementation can found R-INLA implementation rational SPDE approach. begin creating \\(\\) matrix, index, inla.stack object. now create model object. need set upper bound smoothness parameter \\(\\nu\\). default value \\(4\\). increase upper bound \\(\\nu\\) also increase computational cost, decrease upper bound also decrease computatoinal cost. example set nu.upper.bound=2. See R-INLA implementation rational SPDE approach details. Finally, create formula fit model data: can get summary fit: get summary fit random field , can following:","code":"Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d)  st.dat <- inla.stack(   data = list(y = as.vector(y)),   A = Abar,   effects = mesh.index ) rspde_model <- rspde.matern(   mesh = mesh_2d,   nu.upper.bound = 2,   parameterization = \"spde\" ) f <-   y ~ -1 + f(field, model = rspde_model) rspde_fit <-   inla(f,     data = inla.stack.data(st.dat),     family = \"gaussian\",     control.predictor =       list(A = inla.stack.A(st.dat))   ) summary(rspde_fit) #>  #> Call: #>    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  #>    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  #>    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  #>    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  #>    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  #>    = control.compute, \", \" control.predictor = control.predictor,  #>    control.family = control.family, \", \" control.inla = control.inla,  #>    control.fixed = control.fixed, \", \" control.mode = control.mode,  #>    control.expert = control.expert, \", \" control.hazard = control.hazard,  #>    control.lincomb = control.lincomb, \", \" control.update =  #>    control.update, control.lp.scale = control.lp.scale, \", \"  #>    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  #>    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  #>    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  #>    working.directory = working.directory, \", \" silent = silent, inla.mode  #>    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  #>    .parent.frame)\")  #> Time used: #>     Pre = 3.7, Running = 2.02, Post = 0.104, Total = 5.82  #> Random effects: #>   Name     Model #>     field CGeneric #>  #> Model hyperparameters: #>                                           mean    sd 0.025quant 0.5quant #> Precision for the Gaussian observations 99.768 2.206     94.730   99.965 #> Theta1 for field                        -3.623 0.181     -4.830   -3.996 #> Theta2 for field                         2.691 0.048      2.410    2.787 #> Theta3 for field                        -0.171 0.097     -0.776    0.036 #>                                         0.975quant   mode #> Precision for the Gaussian observations     103.18 101.25 #> Theta1 for field                             -3.31  -3.57 #> Theta2 for field                              3.00   2.68 #> Theta3 for field                              0.47  -0.20 #>  #> Marginal log-Likelihood:  1028.89  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result_fit) #>             mean         sd 0.025quant  0.5quant 0.975quant       mode #> tau    0.0271027 0.00392077   0.015769  0.027549  0.0331627  0.0277476 #> kappa 14.7492000 0.73365200  13.963700 14.604200 17.0269000 14.4956000 #> nu     0.9139220 0.04654150   0.858958  0.905555  1.0530400  0.8986180 tau <- op$tau result_df <- data.frame(   parameter = c(\"tau\", \"kappa\", \"nu\"),   true = c(tau, kappa, nu), mean = c(     result_fit$summary.tau$mean,     result_fit$summary.kappa$mean,     result_fit$summary.nu$mean   ),   mode = c(     result_fit$summary.tau$mode,     result_fit$summary.kappa$mode,     result_fit$summary.nu$mode   ) ) print(result_df) #>   parameter       true        mean        mode #> 1       tau  0.1261566  0.02710266  0.02774755 #> 2     kappa 10.0000000 14.74920397 14.49557020 #> 3        nu  0.5000000  0.91392247  0.89861812"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"kriging-with-r-inla-implementation-of-the-rational-spde-approach","dir":"Articles","previous_headings":"","what":"Kriging with R-INLA implementation of the rational SPDE approach","title":"An introduction to the rSPDE package","text":"Let us now obtain predictions (.e., kriging) latent field dense grid region. begin creating grid locations want compute predictions. end, can use rspde.mesh.projector() function. function arguments function inla.mesh.projector() difference rSPDE version also argument nu argument rspde.order. Thus, proceed fashion R-INLA’s standard SPDE implementation: lattice contains 100 × 100 locations (default) shown following figure:  Let us now calculate predictions jointly estimation. end, first, begin linking prediction coordinates mesh nodes \\(\\) matrix now make stack prediction locations. data prediction locations, set y= NA. join stack estimation stack. joint estimation takes , therefore turn computation certain things interested , marginals random effect. also use simplified integration strategy (actually using posterior mode hyper-parameters) command control.inla = list(int.strategy = \"eb\"), .e. empirical Bayes: extract indices prediction nodes extract mean standard deviation response: Finally, plot results. First mean:  , marginal standard deviations:","code":"projgrid <- rspde.mesh.projector(mesh_2d,   xlim = c(0, 1),   ylim = c(0, 1) ) coord.prd <- projgrid$lattice$loc plot(coord.prd, type = \"p\", cex = 0.1) A.prd <- projgrid$proj$A ef.prd <- list(c(mesh.index)) st.prd <- inla.stack(   data = list(y = NA),   A = list(A.prd), tag = \"prd\",   effects = ef.prd ) st.all <- inla.stack(st.dat, st.prd) rspde_fitprd <- inla(f,   family = \"Gaussian\",   data = inla.stack.data(st.all),   control.predictor = list(     A = inla.stack.A(st.all),     compute = TRUE, link = 1   ),   control.compute = list(     return.marginals = FALSE,     return.marginals.predictor = FALSE   ),   control.inla = list(int.strategy = \"eb\") ) id.prd <- inla.stack.index(st.all, \"prd\")$data m.prd <- matrix(rspde_fitprd$summary.fitted.values$mean[id.prd], 100, 100) sd.prd <- matrix(rspde_fitprd$summary.fitted.values$sd[id.prd], 100, 100) field.pred.df <- data.frame(x1 = projgrid$lattice$loc[,1],                         x2 = projgrid$lattice$loc[,2],                          y = as.vector(m.prd)) ggplot(field.pred.df, aes(x = x1, y = x2, fill = y)) +   geom_raster() + xlim(0,1) + ylim(0,1) +    scale_fill_viridis() #> Warning: Removed 396 rows containing missing values (`geom_raster()`). field.pred.sd.df <- data.frame(x1 = proj$lattice$loc[,1],                         x2 = proj$lattice$loc[,2],                          sd = as.vector(sd.prd)) ggplot(field.pred.sd.df, aes(x = x1, y = x2, fill = sd)) +   geom_raster() + xlim(0,1) + ylim(0,1) +    geom_raster() +   scale_fill_viridis() #> Warning: Removed 6156 rows containing missing values (`geom_raster()`). #> Removed 6156 rows containing missing values (`geom_raster()`)."},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"fitting-the-model-with-inlabru-implementation-of-the-rational-spde-approach","dir":"Articles","previous_headings":"","what":"Fitting the model with inlabru implementation of the rational SPDE approach","title":"An introduction to the rSPDE package","text":"now fit model toy data set using inlabru implementation rational SPDE approach. details implementation can found inlabru implementation rational SPDE approach. begin loading inlabru package: creation model object R-INLA’s case: advantage inlabru need form stack manually, can simply collect required data data.frame(): Finally, create component fit: stage, can get summary fit just R-INLA case: also obtain summary field :","code":"library(inlabru) rspde_model <- rspde.matern(   mesh = mesh_2d,   nu.upper.bound = 2,   parameterization = \"spde\" ) toy_df <- data.frame(coord1 = loc_2d_mesh[,1],                      coord2 = loc_2d_mesh[,2],                      y = as.vector(y)) coordinates(toy_df) <- c(\"coord1\", \"coord2\") cmp <-   y ~ -1 + field(coordinates, model = rspde_model)  rspde_bru_fit <-   bru(cmp,       data=toy_df,     options=list(     family = \"gaussian\")   ) summary(rspde_bru_fit) #> inlabru version: 2.7.0 #> INLA version: 23.02.04 #> Components: #> field: main = cgeneric(coordinates) #> Likelihoods: #>   Family: 'gaussian' #>     Data class: 'SpatialPointsDataFrame' #>     Predictor: y ~ . #> Time used: #>     Pre = 3.4, Running = 1.63, Post = 0.236, Total = 5.27  #> Random effects: #>   Name     Model #>     field CGeneric #>  #> Model hyperparameters: #>                                           mean    sd 0.025quant 0.5quant #> Precision for the Gaussian observations 99.758 2.200     94.729   99.955 #> Theta1 for field                        -3.622 0.179     -4.831   -3.997 #> Theta2 for field                         2.691 0.047      2.410    2.787 #> Theta3 for field                        -0.172 0.095     -0.777    0.036 #>                                         0.975quant   mode #> Precision for the Gaussian observations    103.156 101.24 #> Theta1 for field                            -3.314  -3.57 #> Theta2 for field                             2.995   2.68 #> Theta3 for field                             0.471  -0.20 #>  #> Deviance Information Criterion (DIC) ...............: -3277.56 #> Deviance Information Criterion (DIC, saturated) ....: 2290.76 #> Effective number of parameters .....................: 290.90 #>  #> Watanabe-Akaike information criterion (WAIC) ...: -3267.90 #> Effective number of parameters .................: 261.17 #>  #> Marginal log-Likelihood:  1028.89  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit <- rspde.result(rspde_bru_fit, \"field\", rspde_model) summary(result_fit) #>             mean         sd 0.025quant   0.5quant 0.975quant       mode #> tau    0.0271144 0.00387916  0.0160032  0.0275473  0.0331284  0.0277332 #> kappa 14.7459000 0.72401100 13.9679000 14.6046000 16.9732000 14.4977000 #> nu     0.9137020 0.04595470  0.8592130  0.9055530  1.0489300  0.8987300 tau <- op$tau result_df <- data.frame(   parameter = c(\"tau\", \"kappa\", \"nu\"),   true = c(tau, kappa, nu), mean = c(     result_fit$summary.tau$mean,     result_fit$summary.kappa$mean,     result_fit$summary.nu$mean   ),   mode = c(     result_fit$summary.tau$mode,     result_fit$summary.kappa$mode,     result_fit$summary.nu$mode   ) ) print(result_df) #>   parameter       true        mean        mode #> 1       tau  0.1261566  0.02711436  0.02773316 #> 2     kappa 10.0000000 14.74586226 14.49769209 #> 3        nu  0.5000000  0.91370189  0.89873018"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"kriging-with-inlabru-implementation-of-the-rational-spde-approach","dir":"Articles","previous_headings":"","what":"Kriging with inlabru implementation of the rational SPDE approach","title":"An introduction to the rSPDE package","text":"Let us now obtain predictions (.e., kriging) latent field dense grid region. begin creating grid locations want evaluate predictions. begin creating regular grid extract coorinates: Let us now compute predictions. advantage inlabru can fitting model data: following figure shows mean predictions:  following figure shows marginal standard deviations predictions:  alternative simple approach use pixels() function:","code":"pred_coords <- data.frame(x1 = projgrid$lattice$loc[,1],                           x2 = projgrid$lattice$loc[,2]) coordinates(pred_coords) <- c(\"x1\", \"x2\") field_pred <- predict(rspde_bru_fit, pred_coords, ~field) field_pred_df <- field_pred@data field_pred_df <- cbind(field_pred_df, field_pred@coords) ggplot(field_pred_df, aes(x = x1, y = x2, fill = mean)) +   geom_raster() + xlim(0,1) + ylim(0,1) +    scale_fill_viridis() ggplot(field_pred_df, aes(x = x1, y = x2, fill = sd)) +   geom_raster() + xlim(0,1) + ylim(0,1) +    scale_fill_viridis() pxl <- pixels(mesh_2d)  field_pred <- predict(rspde_bru_fit, pxl, ~field)  ggplot() + gg(field_pred) +   scale_fill_viridis() + xlim(0,1) + ylim(0,1)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"fitting-the-model-with-rspde","dir":"Articles","previous_headings":"","what":"Fitting the model with rSPDE","title":"An introduction to the rSPDE package","text":"now fit model toy data set without using R-INLA inlabru. end use rational approximation functions rSPDE package. details can found vignette Rational approximation rSPDE package. use function rSPDE.construct.matern.loglike() define likelihood. function object-based, sense obtains several quantities needs rSPDE model object. Notice already created rSPDE model object simulate data. , , use model object. Recall rSPDE model object created op. also already \\(\\) matrix connecting observation locations mesh, simply called . simplify parameter estimation, rSPDE.construct.matern.loglike() function factory returns negative log-likelihood function, parametrized using logarithm parameter avoid constrained optimization: can now estimate parameter using optimParallel() (one can also use optim()):","code":"mlik <- rSPDE.construct.matern.loglike(object = op, Y=y, A=A) library(optimParallel) # Preparing the parallel  # Checking if we have a limit to the number of cores chk <- Sys.getenv(\"_R_CHECK_LIMIT_CORES_\", \"\") if (nzchar(chk) && chk == \"TRUE\") {   n_cores <- 2L } else {   n_cores <- parallel::detectCores() - 1 }  cl <- makeCluster(n_cores) setDefaultCluster(cl = cl)  # Exporting the needed objects to the parallel cores # This step is not necessary for the regular optim parallel::clusterExport(cl, \"op\") parallel::clusterExport(cl, \"y\") parallel::clusterExport(cl, \"A\")  # Fitting the model theta0 <- c(get.initial.values.rSPDE(mesh = mesh_2d,              parameterization = \"spde\"),             log(0.1 * sqrt(var(as.vector(y)))) )  start_time <- Sys.time() pars <- optimParallel(theta0, mlik) end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(   tau = c(tau, exp(pars$par[1])),   kappa = c(kappa, exp(pars$par[2])),   nu = c(nu, exp(pars$par[3])),   sigma.e = c(sigma.e, exp(pars$par[4])),   row.names = c(\"True\", \"Estimate\") ) print(results) #>                 tau    kappa        nu    sigma.e #> True     0.12615663 10.00000 0.5000000 0.10000000 #> Estimate 0.03464169 13.62671 0.8512278 0.09915336 # Total time print(total_time) #> Time difference of 2.038324 secs"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"kriging-with-rspde","dir":"Articles","previous_headings":"","what":"Kriging with rSPDE","title":"An introduction to the rSPDE package","text":"now kriging dense grid R-INLA-based rational SPDE approach, now using rSPDE functions. end use predict method rSPDE model object. Observe need \\(\\) matrix connecting mesh prediction locations. Let us now create \\(\\) matrix prediction locations used previous case (using R-INLA implementation): now use predict() method rSPDE model object argument compute.variances set TRUE can plot standard deviations. Let us also update values rSPDE model object fitted ones, also save estimated value sigma.e. Finally, plot results. First mean:  , standard deviations:","code":"predgrid <- inla.mesh.projector(mesh_2d,   xlim = c(0, 1),   ylim = c(0, 1) ) A.prd2 <- predgrid$proj$A sigma.e.est <- exp(pars$par[4]) op.prd <- update(op,   user_tau = exp(pars$par[1]),   user_kappa = exp(pars$par[2]),   user_nu = exp(pars$par[3]) )  pred.rspde <- predict(op.prd,   A = A, Aprd = A.prd2, Y = y,   sigma.e = sigma.e.est,   compute.variances = TRUE ) field.pred2.df <- data.frame(x1 = predgrid$lattice$loc[,1],                              x2 = predgrid$lattice$loc[,2],                              y = as.vector(pred.rspde$mean)) ggplot(field.pred2.df, aes(x = x1, y = x2, fill = y)) +   geom_raster() + xlim(0,1) + ylim(0,1) +    scale_fill_viridis() #> Warning: Removed 396 rows containing missing values (`geom_raster()`). field.pred2.sd.df <-field.pred2.df <- data.frame(x1 = predgrid$lattice$loc[,1],                              x2 = predgrid$lattice$loc[,2],                              sd = as.vector(sqrt(pred.rspde$variance))) ggplot(field.pred2.sd.df, aes(x = x1, y = x2, fill = sd)) +   geom_raster() +   scale_fill_viridis()"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Operator-based rational approximation","text":"Several popular Gaussian random field models can represented solutions stochastic partial differential equations (SPDEs) form \\[ L^{\\beta} (\\tau u) = \\mathcal{W}. \\] \\(\\mathcal{W}\\) Gaussian white noise, \\(L\\) second-order differential operator, fractional power \\(\\beta>0\\) determines smoothness \\(u\\), \\(\\tau>0\\) scales variance \\(u\\). \\(2\\beta\\) integer domain \\(\\mathcal{D}\\) model defined bounded, \\(u\\) can approximated Gaussian Markov random field (GMRF) \\(\\boldsymbol{\\mathrm{u}}\\) via finite element method (FEM) SPDE. Specifically, approximation can written \\[ u_h(s) = \\sum_{=1}^n u_i \\varphi_i(s). \\] \\(\\{\\varphi_i\\}\\) piecewise linear basis functions defined triangulation \\(\\mathcal{D}\\) vector weights \\(\\boldsymbol{\\mathrm{u}} = (u_1,\\ldots,u_n)^T\\) normally distributed, \\(N(\\boldsymbol{\\mathrm{u}},\\tilde{\\boldsymbol{\\mathrm{Q}}}^{-1})\\), \\(\\tilde{\\boldsymbol{\\mathrm{Q}}}\\) sparse. See Lindgren, Rue, Lindström (2011) details. vignette focus operator-based rational approximation. approach, introduced Bolin Kirchner (2020), results approximation original SPDE form \\(P_l x = P_r \\mathcal{W}\\), \\(P_l\\) \\(P_r\\) non-fractional operators defined terms polynomials \\(p_l\\) \\(p_r\\). order \\(p_r\\) given \\(m\\) order \\(p_l\\) \\(m + m_{\\beta}\\) \\(m_{\\beta}\\) integer part \\(\\beta\\) \\(\\beta>1\\) \\(m_{\\beta} = 1\\) otherwise. combination rational approximation operator FEM discretization yields approximation \\(u_h\\) \\(u\\) basis expansion form . difference non-fractional case vector stochastic weights now \\(\\boldsymbol{\\mathrm{u}} \\sim N(\\boldsymbol{\\mathrm{0}},\\boldsymbol{\\mathrm{P}}_r\\boldsymbol{\\mathrm{Q}}^{-1}\\boldsymbol{\\mathrm{P}}_r^T)\\) \\(\\boldsymbol{\\mathrm{Q}}\\) \\(\\boldsymbol{\\mathrm{P}}_r\\) sparse matrices. Alternatively, \\(\\boldsymbol{\\mathrm{u}}\\) can represented \\(\\boldsymbol{\\mathrm{u}} = \\boldsymbol{\\mathrm{P}}_r \\boldsymbol{\\mathrm{x}}\\) \\(\\boldsymbol{\\mathrm{x}} \\sim N(\\boldsymbol{\\mathrm{0}},\\boldsymbol{\\mathrm{Q}}^{-1})\\), means discrete approximation latent GMRF. can used computationally efficient inference simulation. See Bolin Kirchner (2020) details.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"using-the-package-to-perform-operator-based-rational-approximations","dir":"Articles","previous_headings":"","what":"Using the package to perform operator-based rational approximations","title":"Operator-based rational approximation","text":"main purpose rSPDE package provide functions creating rational approximation. vignette focus operator-based rational approximation, means assembling matrices \\(\\boldsymbol{\\mathrm{Q}}\\) \\(\\boldsymbol{\\mathrm{P}}_r\\). three functions computing rational approximation. general function fractional.operators(), works wide class models general differential operator \\(L\\). stationary Matérn case, \\(L = \\kappa^2 - \\Delta\\), function matern.operators() provides simplified model specification. generalized non-stationary Matérn model, defined SPDE \\[ (\\kappa(s)^2 - \\Delta)^\\beta (\\tau(s)u(s)) = \\mathcal{W}, \\] function spde.matern.operators() can used. alternative covariance-based rational approximation, refer reader Rational approximation rSPDE package vignette. worth noting covariance-based rational approximation applies fractional SPDE models Gaussian noise, whereas operator-based rational approximation can used general models models driven type-G Lévy noise considered Wallin Bolin (2015), Bolin (2013), Asar et al. (2020). approximation constructed, can included manually statistical models just non-fractional case. package built-functions basic use approximation, simulate() can applied simulation field. also functions likelihood evaluation kriging prediction geostatistical models Gaussian measurement noise. following sections, illustrate usage functions.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"constructing-the-approximation","dir":"Articles","previous_headings":"Using the package to perform operator-based rational approximations","what":"Constructing the approximation","title":"Operator-based rational approximation","text":"section, explain different main functions can used constructing rational approximation. first step constructing rational SPDE approximation define FEM mesh. section, use simple FEM implementation rSPDE package models defined interval. Assume want define model interval \\([0,1]\\). start defining vector mesh nodes \\(s_i\\) basis functions \\(\\varphi_i\\) centered. Based nodes, use built-function rSPDE.fem1d() assemble two matrices needed creating approximation basic Matérn model. matrices mass matrix \\(\\boldsymbol{\\mathrm{C}}\\), elements \\(C_{ij} = \\int \\varphi_j(s) \\varphi_i(s) ds\\), stiffness matrix \\(\\boldsymbol{\\mathrm{G}}\\), elements \\(G_{ij} = \\int \\nabla\\varphi_j(s) \\cdot \\nabla\\varphi_i(s) ds\\). can now use matern.operators() construct rational SPDE approximation degree \\(m=1\\) Gaussian random field Matérn covariance function interval. Since using operator-based approximation, must set type \"operator\". object op contains matrices needed evaluating distribution stochastic weights \\(\\boldsymbol{\\mathrm{u}}\\). want evaluate \\(u_h(s)\\) locations \\(s_1,\\ldots, s_n\\), need multiply weights basis functions \\(\\varphi_i(s)\\) evaluated locations. , can construct observation matrix \\(\\boldsymbol{\\mathrm{}}\\) elements \\(A_{ij} = \\varphi_j(s_i)\\), links FEM basis functions locations. matrix can constructed using function rSPDE.A1d(). evaluate accuracy approximation, let us compute covariance function process \\(s=0.5\\) locations s compare true covariance function, folded Matérn covariance, see Theorem 1 explicit link Gaussian fields Gaussian Markov random fields: stochastic partial differential equation approach. covariances can calculated \\[ \\boldsymbol{\\mathrm{}} \\boldsymbol{\\mathrm{P}}_r \\boldsymbol{\\mathrm{Q}}^{-1}\\boldsymbol{\\mathrm{P}}_r^T\\boldsymbol{\\mathrm{v}}. \\] \\(\\boldsymbol{\\mathrm{}}\\) identity matrix since evaluating approximation nodes FEM mesh \\(\\boldsymbol{\\mathrm{v}}\\) vector basis functions evaluated \\(s=0.5\\). covariance function error compared Matérn covariance shown following figure.  improve approximation can increase degree polynomials, increasing \\(m\\), /increase number basis functions used FEM approximation. Let us, example, compute approximation \\(m=2\\) using mesh, well approximation increase number basis functions use \\(m=1\\) \\(m=2\\). resulting errors shown following figure.  Since error induced rational approximation decreases exponentially \\(m\\), rarely need approximation large value \\(m\\). good number non-zero elements \\(\\boldsymbol{\\mathrm{P}}_r\\) \\(\\boldsymbol{\\mathrm{Q}}\\) increases \\(m\\), makes approximation computationally costly use. , condition numbers \\(\\boldsymbol{\\mathrm{P}}_r\\) \\(\\boldsymbol{\\mathrm{Q}}\\) increase \\(m\\), can cause numerical problems working matrices. illustrate , let us compute norm approximation error different \\(m\\). see error decreases increasing \\(m\\) \\(1\\) \\(2\\), large \\(m=3\\) \\(m=4\\). reason approximation bad, numerical accuracy product \\(\\boldsymbol{\\mathrm{P}}_r\\boldsymbol{\\mathrm{Q}}^{-1}\\boldsymbol{\\mathrm{P}}_rv\\) low due large condition numbers matrices. important note alternative covariance-based rational approximation numerically stable. main reason relies decomposition field \\(u\\) sum random fields, removes need computing higher order finite element matrices large values \\(m\\). See Rational approximation rSPDE package vignette details. handle issue operator-based rational approximation, package contains functions performing operations \\(\\boldsymbol{\\mathrm{P}}_rv\\) \\(\\boldsymbol{\\mathrm{P}}_r^{-1}v\\) takes advantage structure \\(\\boldsymbol{\\mathrm{P}}_r\\) avoid numerical instabilities. complete list function can seen typing ?operator.operations. One functions Sigma.mult(), performs multiplication \\(\\boldsymbol{\\mathrm{P}}_r\\boldsymbol{\\mathrm{Q}}^{-1}\\boldsymbol{\\mathrm{P}}_rv\\) numerically stable way. Let us use function compute errors approximations see indeed get better approximations \\(m\\) increases.","code":"s <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(s) kappa <- 20 sigma <- 2 nu <- 0.8 op <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem$G, C = fem$C, d = 1, m = 1,   type = \"operator\" ) v <- t(rSPDE.A1d(s, 0.5)) c.approx <- op$Pr %*% solve(op$Q, op$Pr %*% v) c.true <- folded.matern.covariance.1d(rep(0.5, length(s)), abs(s), kappa, nu, sigma) opar <- par(   mfrow = c(1, 2), mgp = c(1.3, 0.5, 0),   mar = c(2, 2, 0.5, 0.5) + 0.1 ) plot(s, c.true,   type = \"l\", ylab = \"C(|s-0.5|)\", xlab = \"s\", ylim = c(0, 5),   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, c.approx, col = 2) legend(\"topright\",   bty = \"n\",   legend = c(\"Matérn\", \"m=1 rSPDE\"),   col = c(\"black\", \"red\"),   lty = rep(1, 2), ncol = 1,   cex = 0.8 )  plot(s, c.true - c.approx,   type = \"l\", ylab = \"Error\", xlab = \"s\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) par(opar) op2 <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem$G, C = fem$C, d = 1, m = 2,   type = \"operator\" ) c.approx2 <- op2$Pr %*% solve(op2$Q, op2$Pr %*% v)  s2 <- seq(from = 0, to = 1, length.out = 501) fem2 <- rSPDE.fem1d(s2) op <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem2$G, C = fem2$C, d = 1, m = 1,   type = \"operator\" ) A <- rSPDE.A1d(s2, s) v <- t(rSPDE.A1d(s2, 0.5)) c.approx3 <- A %*% op$Pr %*% solve(op$Q, op$Pr %*% v) op <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem2$G, C = fem2$C, d = 1, m = 2,   type = \"operator\" ) c.approx4 <- A %*% op$Pr %*% solve(op$Q, op$Pr %*% v) opar <- par(mgp = c(1.3, 0.5, 0), mar = c(2, 2, 0.5, 0.5) + 0.1) plot(s, c.true - c.approx,   type = \"l\", ylab = \"Error\", xlab = \"s\", col = 1,   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, c.true - c.approx2, col = 2) lines(s, c.true - c.approx3, col = 3) lines(s, c.true - c.approx4, col = 4) legend(\"bottomright\",   bty = \"n\",   legend = c(\"m=1 coarse mesh\", \"m=2 coarse mesh\",   \"m=1 fine mesh\", \"m=2 fine mesh\"),   col = c(1, 2, 3, 4),   lty = rep(1, 2), ncol = 1,   cex = 0.8 ) par(opar) errors <- rep(0, 4) for (i in 1:4) {   op <- matern.operators(     kappa = kappa, sigma = sigma, nu = nu,     G = fem2$G, C = fem2$C, d = 1, m = i,     type = \"operator\"   )   c.app <- A %*% op$Pr %*% solve(op$Q, op$Pr %*% v)   errors[i] <- norm(c.true - c.app) } print(errors) #> [1]  1.012017  0.114015 51.947037 54.648301 errors2 <- rep(0, 4) for (i in 1:4) {   op <- matern.operators(     kappa = kappa, sigma = sigma, nu = nu,     G = fem2$G, C = fem2$C, d = 1, m = i,     type = \"operator\"   )   c.app <- A %*% Sigma.mult(op, v)   errors2[i] <- norm(c.true - c.app) } print(errors2) #> [1] 1.01201540 0.10479953 0.02474815 0.01788324"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"a-non-stationary-model","dir":"Articles","previous_headings":"","what":"A non-stationary model","title":"Operator-based rational approximation","text":"Let us now examine non-stationary model \\((\\kappa(s)^2 - \\Delta)^\\beta (\\tau(s)u(s)) = \\mathcal{W}\\) \\(\\kappa(s) = 10(1+2s^2)\\) \\(\\tau(s) = 0.1(1 - 0.7s^2)\\). can use spde.matern.operators() create rational approximation \\(m=1\\) follows. Let us compute covariance function \\(C(s,s_i)\\) non-stationary model locations \\(s_1=0.1, s_2 = 0.5,\\) \\(s_3 = 0.9\\). three covariances shown following figure.  see choice \\(\\kappa(s)\\) \\(\\tau(s)\\) results model longer range small values \\(s\\) smaller variance middle domain. can also apply general function fractional.operators() construct approximation. function requires user supplies discretization non-fractional operator \\(L\\), well scaling factor \\(c>0\\) lower bound smallest eigenvalue \\(L\\). case \\(L = \\kappa(s)^2 - \\Delta\\), eigenvalues operator bounded \\(c = \\min_s \\kappa(s)^2\\). compute constant discrete operator. Another difference fractional.operators() previous functions constructing approximation, requires specifying \\(\\beta\\) instead smoothness parameter \\(\\nu\\) Matérn covariance. two parameters related \\(2\\beta = \\nu + d/2\\). Let’s make sure approximation comparing previously computed covariances. Obviously, simpler use spde.matern.operators() case, advantage fractional.operators() also can used general models one \\(L = \\kappa(s)^2 - \\nabla \\cdot (\\boldsymbol{\\mathrm{H}}(s) \\nabla)\\) matrix-valued function \\(\\boldsymbol{\\mathrm{H}}(s)\\).","code":"s <- seq(from = 0, to = 1, length.out = 501) fem <- rSPDE.fem1d(s) kappa <- 10 * (1 + 2 * s^2) tau <- 0.1 * (1 - 0.7 * s^2) op <- spde.matern.operators(   kappa = kappa, tau = tau, nu = nu,   G = fem$G, C = fem$C, d = 1, m = 1,   type = \"operator\" ) v <- t(rSPDE.A1d(s, c(0.1, 0.5, 0.9))) covs <- Sigma.mult(op, v) opar <- par(mgp = c(1.3, 0.5, 0), mar = c(2, 2, 0.5, 0.5) + 0.1) plot(s, covs[, 1],   type = \"l\", ylab = \"C(s,s_i)\", xlab = \"s\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, covs[, 2], col = 2) lines(s, covs[, 3], col = 3) par(opar) c <- min(kappa)^2 L <- fem$G + fem$C %*% Diagonal(501, kappa^2) op <- fractional.operators(   L = L, beta = (nu + 1 / 2) / 2, C = fem$C,   scale.factor = c, tau = tau, m = 1 ) covs2 <- Sigma.mult(op, v) norm(covs - covs2) #> [1] 0"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"using-the-approximation","dir":"Articles","previous_headings":"A non-stationary model","what":"Using the approximation","title":"Operator-based rational approximation","text":"approximation, constructed using functions fractional.operators(), matern.operators(), spde.matern.operators(), can simulate model using simulate(). also built-support kriging prediction. illustrate , use simulation create noisy observations process. , first construct observation matrix linking FEM basis functions locations want simulate. first randomly generate observation locations construct matrix. now generate observations \\(Y_i = u(s_i) + \\varepsilon_i\\), \\(\\varepsilon_i \\sim N(0,\\sigma_e^2)\\) Gaussian measurement noise. Finally, compute kriging prediction process \\(u\\) locations s based observations. specify locations predicted, argument Aprd used. argument observation matrix links mesh locations prediction locations. process simulation, observed data, kriging prediction shown following figure.","code":"u <- simulate(op) n.obs <- 20 obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(s, obs.loc) sigma.e <- 0.3 Y <- as.vector(A %*% u + sigma.e * rnorm(n.obs)) A.krig <- rSPDE.A1d(s, s) u.krig <- predict(op, A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e) opar <- par(mgp = c(1.3, 0.5, 0), mar = c(2, 2, 0.5, 0.5) + 0.1) plot(obs.loc, Y,   ylab = \"u(s)\", xlab = \"s\",   ylim = c(min(c(min(u), min(Y))), max(c(max(u), max(Y)))),   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, u) lines(s, u.krig$mean, col = 2) par(opar)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"spatial-data-and-parameter-estimation","dir":"Articles","previous_headings":"","what":"Spatial data and parameter estimation","title":"Operator-based rational approximation","text":"functions used previous examples also work spatial models. need construct mesh domain interest compute matrices needed define operator. tasks can performed, example, using R-INLA package. Let us start defining mesh \\([0,1]\\times [0, 1]\\) compute mass stiffness matrices mesh.  can now use matrices define rational SPDE approximation degree \\(m=1\\) Matérn model . illustrate , simulate latent process standard deviation \\(\\sigma=1\\) range \\(0.1\\). choose \\(\\nu=0.5\\) model corresponds Gaussian process exponential covariance function. Now let us simulate noisy data use estimate parameters model. construct observation matrix, use R-INLA function inla.spde.make.(). sample 30 replicates latent field. first replicate simulated random field well observation locations shown following figure.  type rational approximation degree \\(m\\), corresponding likelihood function can used likelihood-based parameter estimation. Since constructed model spde.matern.operators(), can use function spde.matern.loglike() define likelihood. simplify parameter estimation, create object containing rSPDE model (assigning meaningless value 1 parameters used): can now obtain objective function minimize, negative log-likelihood, parametrized using logarithm parameter avoid constrained optimization, using rSPDE.construct.matern.loglike() function factory: can now estimate parameter using optim(). Finally, observe can use rational.order() function, check order rational approximation rSPDE object, well use rational.order<-() function assign new orders:","code":"library(INLA) m <- 100 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.create.helper(   points = loc_2d_mesh,   cutoff = 0.05,   offset = c(0.1, 0.4),   max.edge = c(0.05, 0.5) ) plot(mesh_2d, main = \"\") points(loc_2d_mesh[, 1], loc_2d_mesh[, 2]) fem_mesh_2d <- inla.mesh.fem(mesh_2d) C <- fem_mesh_2d$c0 G <- fem_mesh_2d$g1 nu <- 0.5 sigma <- 1 range <- 0.1 kappa <- sqrt(8 * nu) / range tau <- 1 / (sqrt(4 * pi) * kappa * sigma) op <- spde.matern.operators(kappa = kappa, tau = tau, nu = nu, G = G, C = C, d = 2, m = 1) n.rep <- 30 u <- simulate(op, nsim = n.rep) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 Y <- A %*% u + matrix(rnorm(m * n.rep), ncol = n.rep) * sigma.e library(viridis) library(ggplot2) proj <- inla.mesh.projector(mesh_2d, dims = c(70, 70))  df_field <- data.frame(x = proj$lattice$loc[,1],                         y = proj$lattice$loc[,2],                         field = as.vector(inla.mesh.project(proj,                          field = as.vector(u[, 1]))),                         type = \"field\")  df_loc <- data.frame(x = loc_2d_mesh[, 1],                       y = loc_2d_mesh[, 2],                       field = as.vector(Y[,1]),                       type = \"locations\") df_plot <- rbind(df_field, df_loc)  ggplot(df_plot) + aes(x = x, y = y, fill = field) +         facet_wrap(~type) + xlim(0,1) + ylim(0,1) +          geom_raster(data = df_field) +         geom_point(data = df_loc, aes(colour = field),         show.legend = FALSE) +          scale_fill_viridis() + scale_colour_viridis() op_obj <- matern.operators(     kappa = 1, sigma = 1, nu = 1,     G = G, C = C, d = 2, m = 1,     type = \"operator\"   ) tau <- op_obj$tau mlik <- rSPDE.construct.matern.loglike(op_obj, Y=Y, A=A) theta0 <- c(   get.initial.values.rSPDE(mesh = mesh_2d,   parameterization = \"spde\"),   log(0.1 * sqrt(var(as.vector(Y)))) )  start_time <- Sys.time() pars <- optim(theta0, mlik, method = \"L-BFGS-B\") end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(   tau = c(tau, exp(pars$par[1])),   kappa = c(kappa, exp(pars$par[2])),   nu = c(nu, exp(pars$par[3])),   sigma.e = c(sigma.e, exp(pars$par[4])),   row.names = c(\"True\", \"Estimate\") ) print(results) #>                 tau    kappa        nu   sigma.e #> True     0.28209479 20.00000 0.5000000 0.1000000 #> Estimate 0.01279315 18.77851 0.5363754 0.1054252  # Total time print(total_time) #> Time difference of 9.295677 secs rational.order(op_obj) #> [1] 1  rational.order(op_obj) <- 2  mlik_order2 <- rSPDE.construct.matern.loglike(op_obj, Y=Y, A=A)  start_time <- Sys.time() pars <- optim(theta0, mlik_order2, method = \"L-BFGS-B\") end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(   tau = c(tau, exp(pars$par[1])),   kappa = c(kappa, exp(pars$par[2])),   nu = c(nu, exp(pars$par[3])),   sigma.e = c(sigma.e, exp(pars$par[4])),   row.names = c(\"True\", \"Estimate\") ) print(results) #>                  tau    kappa        nu   sigma.e #> True     0.282094792 20.00000 0.5000000 0.1000000 #> Estimate 0.009460178 19.53185 0.6182789 0.1054156  # Total time print(total_time) #> Time difference of 23.885 secs"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Rational approximation with the rSPDE package","text":"vignette introduce covariance-based rational SPDE approach illustrate perform statistical inference . covariance-based approach efficient alternative operator-based rational SPDE approach Bolin Kirchner (2020) works one SPDE driven Gaussian white noise. refer reader Xiong, Simas, Bolin (2022) theoretical details approach. Details operator-based rational SPDE approach given Operator-based rational approximation vignette. R-INLA inlabru implementations covariance-based rational SPDE approach refer reader vignettes R-INLA implementation rational SPDE approach inlabru implementation rational SPDE approach respectively.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"covariance-based-rational-spde-approach","dir":"Articles","previous_headings":"","what":"Covariance-based rational SPDE approach","title":"Rational approximation with the rSPDE package","text":"Let us first present basic setup. want model precipitation two-dimensional random field \\(u\\) within bounded domain, location domain associates random variable describe local precipitation. SPDE approach, introduced Lindgren, Rue, Lindström (2011) model \\(u\\) solution following SPDE: \\[L^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(L = -\\Delta +\\kappa^2 \\) \\(\\mathcal{W}\\) standard Gaussian white noise. , \\(\\alpha\\), \\(\\kappa\\) \\(\\tau\\) three parameters want estimate. standard SPDE approach, write, general dimension \\(d\\), \\(\\alpha = \\nu + d/2\\) assume \\(\\nu\\) fixed \\(\\alpha\\) integer. rational SPDE approach can use value \\(\\nu>0\\) also estimate data. Now let us briefly describe covariance based rational SPDE approach works statistical inference. main idea perform rational approximation directly covariance operator, given \\(L^{-\\alpha}\\), instead solution \\(u\\). end, begin obtaining approximation random field \\(u\\), solution SPDE , using finite element method (FEM): \\[u_h(\\mathbf{s}_i)=\\sum_{j=1}^{n_h} \\hat{u}_j \\varphi_j(\\mathbf{s}_i),\\] \\(\\{\\hat{u}_j\\}_{j = 1}^{n_h}\\) stochastic weights \\(\\{\\varphi_j(\\mathbf{s}_i)\\}_{j = 1}^{n_h}\\) fixed piecewise linear continuous basis functions obtained triangulation spatial domain. obtain FEM approximation operator \\(L\\), given \\(L_h\\), covariance operator \\(u_h\\) given \\(L_h^{-\\alpha}\\). Now, using rational approximation \\(L_h\\), can approximate covariance operator \\(L_h^{-\\alpha}\\) \\[L_{h,m}^{-\\alpha} = L_h^{-\\lfloor\\alpha\\rfloor} p(L_h^{-1})q(L_h^{-1})^{-1},\\] \\(\\lfloor\\alpha\\rfloor\\) denotes integer part \\(\\alpha\\), \\(m\\) order rational approximation, \\(p(L_h^{-1}) = \\sum_{=0}^m a_i L_h^{m-}\\) \\(q(L_h^{-1}) = \\sum_{j=0}^m b_j L_h^{m-}\\), \\(\\{a_i\\}_{= 0}^m\\) \\(\\{b_j\\}_{j = 0}^m\\) known coefficients obtained rational approximation function \\(x^{\\alpha - \\lfloor\\alpha\\rfloor}\\). next step perform partial fraction decomposition rational function \\(p(L_h^{-1})q(L_h^{-1})^{-1}\\), yields representation \\[L_{h,m}^{-\\alpha} =L_h^{-\\lfloor\\alpha\\rfloor} \\left(\\sum_{=1}^{m}  r_i  (L_h-p_i )^{-1} +k\\right).\\] Based operator equation, can write covariance matrix stochastic weights \\(\\hat{\\textbf{u}}\\), \\(\\hat{\\textbf{u}}=[\\hat{u}_1,...,\\hat{u}_{n_h}]^\\top\\), \\[\\mathbf{\\Sigma}_{\\hat{\\textbf{u}}} = (\\textbf{L}^{-1}\\textbf{C})^{\\lfloor\\alpha\\rfloor} \\sum_{=1}^{m}r_i(\\textbf{L}-p_i\\textbf{C})^{-1}+\\textbf{K}, \\] \\(\\textbf{C} = \\{C_{ij}\\}_{,j=1}^{n_h}\\), \\(C_{ij} = (\\varphi_i,\\varphi_j)_{L_2(\\mathcal{D})}\\), mass matrix, \\(\\textbf{L} = \\kappa^2\\textbf{C}+\\textbf{G}\\), \\(\\textbf{G} = \\{G_{ij}\\}_{,j=1}^{n_h}\\), \\(G_{ij}=(\\nabla\\varphi_i,\\nabla\\varphi_j)_{L_2(\\mathcal{D})}\\), stiffness matrix, \\[\\textbf{K}=\\left\\{     \\begin{array}{lcl}         k\\textbf{C}      &      & {\\lfloor\\alpha\\rfloor=0}\\\\         k\\textbf{L}^{-1}(\\textbf{C}\\textbf{L}^{-1})^{\\lfloor\\alpha\\rfloor-1}    &      & {\\lfloor\\alpha\\rfloor\\geq 1}\\\\     \\end{array} \\right. .\\] representation shows can express \\(\\hat{\\textbf{u}}\\) \\[\\hat{\\textbf{u}}=\\sum_{k=1}^{m+1}\\textbf{x}_k,\\] \\(\\textbf{x}_k = (x_{k,1}, \\ldots, x_{k,n_h})\\), \\[\\textbf{x}_i \\sim N(\\textbf{0},\\textbf{Q}_i^{-1}),\\] \\(\\textbf{Q}_i\\) precision matrix \\(\\textbf{x}_i\\), given \\[\\textbf{Q}_i=\\left \\{     \\begin{array}{lcl}         (\\textbf{L}-p_i\\textbf{C})(\\textbf{C}^{-1}\\textbf{L})^{\\lfloor\\alpha\\rfloor}/r_i,      &      & {= 1,...,m}\\\\          \\textbf{K}^{-1},   &      & {= m+1}\\\\     \\end{array}. \\right.\\] , , replace Matérn latent field latent vector given , precision matrix given \\[\\textbf{Q}=\\begin{bmatrix}\\textbf{Q}_1& &\\\\&\\ddots&\\\\& &\\textbf{Q}_{m+1}\\end{bmatrix}.\\] Now, assume observe \\[y_i = u_h(\\mathbf{s}_i) + \\varepsilon_i,\\quad =1,\\ldots, N,\\] \\(\\varepsilon_i\\sim N(0,\\sigma_\\varepsilon^2)\\) iid measurement noise. , \\[y_i = u_h(\\mathbf{s}_i) + \\varepsilon_i = \\sum_{j=1}^{n_h} \\hat{u}_j \\varphi_j(\\mathbf{s}_i) + \\varepsilon_i = \\sum_{k=1}^{m+1} \\sum_{j=1}^{n_h} x_{k,j} \\varphi(\\mathbf{s}_i) + \\varepsilon_i.\\] can written matrix form \\[\\textbf{y} = \\overline{\\textbf{}} \\textbf{X} + \\boldsymbol{\\varepsilon},\\] \\(\\textbf{y} = [y_1,\\ldots,y_N]^\\top, \\textbf{X} = [\\textbf{x}_1^\\top,\\ldots,\\textbf{x}_{m+1}^\\top]^\\top\\), \\(\\boldsymbol{\\varepsilon} = [\\varepsilon_1,\\ldots,\\varepsilon_N]^\\top\\), \\[\\overline{\\textbf{}}=\\begin{bmatrix}\\textbf{}&\\cdots&\\textbf{}\\end{bmatrix}_{n\\times n_h(m+1)},\\] \\[\\textbf{}=\\begin{bmatrix}\\varphi_1(s_1)&\\cdots&\\varphi_{n_h}(s_1)\\\\\\vdots&\\vdots&\\vdots\\\\\\varphi_1(s_n)&\\cdots&\\varphi_{n_h}(s_n)\\end{bmatrix}.\\] arrive following hierarchical model: \\[\\begin{align} \\textbf{y}\\mid \\textbf{X} &\\sim N(0,\\sigma_\\varepsilon\\textbf{})\\\\ \\textbf{X}&\\sim N(0,\\textbf{Q}^{-1}) \\end{align}.\\] elements, can, example, use R-INLA compute posterior distribution three parameters want estimate.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"constructing-the-approximation","dir":"Articles","previous_headings":"","what":"Constructing the approximation","title":"Rational approximation with the rSPDE package","text":"section, explain use function matern.operators() default argument type, , type=\"covariance\", constructs covariance-based rational approximation. also illustrate usage several methods functions related covariance-based rational approximation. use functions sample Gaussian fields stationary Matérn covariance function, compute log-likelihood function, spatial prediction. first step performing covariance-based rational SPDE approximation define FEM mesh. illustration purposes, rSPDE package contains simple FEM implementation models \\(\\mathbb{R}\\) use first. also illustrate spatial models can constructed FEM implementation R-INLA package used instead. using R-INLA package, also recommend usage R-INLA implementation rational SPDE approach. details, see R-INLA implementation rational SPDE approach vignette. begin loading rSPDE package: Assume want define model interval \\([0,1]\\). start defining vector mesh nodes \\(s_i\\) basis functions \\(\\varphi_i\\) centered. Based nodes, use built-function rSPDE.fem1d() assemble two matrices needed creating approximation basic Matérn model. matrices mass matrix \\(\\boldsymbol{\\mathrm{C}}\\), elements \\(C_{ij} = \\int \\varphi_j(s) \\varphi_i(s) ds\\), stiffness matrix \\(\\boldsymbol{\\mathrm{G}}\\), elements \\(G_{ij} = \\int \\nabla\\varphi_j(s) \\cdot \\nabla\\varphi_i(s) ds\\). can now use matern.operators() construct rational SPDE approximation order \\(m=2\\) Gaussian random field Matérn covariance function interval. also refer reader Operator-based rational approximation similar comparison made operator-based rational approximation. object op_cov contains matrices needed evaluating distribution stochastic weights \\(\\boldsymbol{\\mathrm{u}}\\). want evaluate \\(u_h(s)\\) locations \\(s_1,\\ldots, s_n\\), need multiply weights basis functions \\(\\varphi_i(s)\\) evaluated locations. , can construct observation matrix \\(\\boldsymbol{\\mathrm{}}\\), elements \\(A_{ij} = \\varphi_j(s_i)\\), links FEM basis functions locations. matrix can constructed using function rSPDE.A1d(). However, observed introduction vignette, decomposed stochastic weights \\(\\boldsymbol{\\mathrm{u}}\\) vector latent variables. Thus, \\(\\) matrix covariance-based rational approximation, denote \\(\\overline{}\\), actually given \\(m+1\\)-fold horizontal concatenation \\(\\) matrices, \\(m\\) order rational approximation. compute precision matrix covariance-based rational approximation one can use precision() method CBrSPDEobj object (object returned matern.operators() function default type, type=\"covariance\"): evaluate accuracy approximation, let us compute covariance function process \\(s=0.5\\) locations s compare true Matérn covariance function. covariances can calculated \\[ \\overline{\\boldsymbol{\\mathrm{}}} \\boldsymbol{\\mathrm{Q}}^{-1}\\overline{\\boldsymbol{\\mathrm{v}}}. \\] , \\(\\boldsymbol{\\mathrm{Q}}\\) precision matrix obtained covariance-based rational approximation, \\(\\boldsymbol{\\mathrm{}}\\) identity matrix since evaluating approximation nodes FEM mesh, \\(\\overline{\\boldsymbol{\\mathrm{v}}}\\) \\((m+1)\\)-fold vertical concatenation vector \\(\\boldsymbol{\\mathrm{v}}\\), \\(\\boldsymbol{\\mathrm{v}}\\) vector basis functions evaluated \\(s=0.5\\). Let us now compute true Matérn covariance function interval \\((0,1)\\), folded Matérn, see Theorem 1 explicit link Gaussian fields Gaussian Markov random fields: stochastic partial differential equation approach details. covariance function error compared Matérn covariance shown following figure.  improve approximation can increase degree polynomials, increasing \\(m\\), /increase number basis functions used FEM approximation. Let us, example, compute approximation \\(m=4\\) using mesh, well approximation increase number basis functions use \\(m=2\\) \\(m=4\\). resulting errors shown following figure.  Since error induced rational approximation decreases exponentially \\(m\\), general rarely need approximation large value \\(m\\). good size \\(\\boldsymbol{\\mathrm{Q}}\\) increases \\(m\\), makes approximation computationally costly use. illustrate , let us compute norm approximation error different \\(m\\). see error decreases fast increase \\(m\\) \\(1\\) \\(4\\), without numerical instability. advantage covariance-based rational approximation compared operator-based rational approximation. See Operator-based rational approximation details numerical instability operator-based rational approximation.","code":"library(rSPDE) s <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(s) kappa <- 20 sigma <- 2 nu <- 0.8 op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 ) Q <- precision(op_cov) v <- t(rSPDE.A1d(s, 0.5)) v_bar <- kronecker(matrix(1, nrow = 3), v) A <- Diagonal(101) A_bar <- kronecker(matrix(1, ncol = 3), A) c_cov.approx <- (A_bar) %*% solve(Q, v_bar) c.true <- folded.matern.covariance.1d(rep(0.5, length(s)), abs(s), kappa, nu, sigma) opar <- par(   mfrow = c(1, 2), mgp = c(1.3, 0.5, 0),   mar = c(2, 2, 0.5, 0.5) + 0.1 ) plot(s, c.true,   type = \"l\", ylab = \"C(|s-0.5|)\", xlab = \"s\", ylim = c(0, 5),   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, c_cov.approx, col = 2) legend(\"topright\",   bty = \"n\",   legend = c(\"Matérn\", \"Rational\"),   col = c(\"black\", \"red\"),   lty = rep(1, 2), ncol = 1,   cex = 0.8 )  plot(s, c.true - c_cov.approx,   type = \"l\", ylab = \"Error\", xlab = \"s\",   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) par(opar) op_cov2 <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem$G, C = fem$C, d = 1, m = 4 ) Q2 <- precision(op_cov2) v_bar2 <- kronecker(matrix(1, nrow = 5), v) A_bar2 <- kronecker(matrix(1, ncol = 5), A) c_cov.approx2 <- (A_bar2) %*% solve(Q2, v_bar2)  s2 <- seq(from = 0, to = 1, length.out = 501) fem2 <- rSPDE.fem1d(s2) op_cov <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem2$G, C = fem2$C, d = 1, m = 2 ) Q3 <- precision(op_cov) A2 <- rSPDE.A1d(s2, s) v2 <- t(rSPDE.A1d(s2, 0.5)) v2_bar <- kronecker(matrix(1, nrow = 3), v2) A2_bar <- kronecker(matrix(1, ncol = 3), A2) c_cov.approx3 <- (A2_bar) %*% solve(Q3, v2_bar)  op_cov <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem2$G, C = fem2$C, d = 1, m = 4 ) Q4 <- precision(op_cov) v2_bar2 <- kronecker(matrix(1, nrow = 5), v2) A2_bar2 <- kronecker(matrix(1, ncol = 5), A2) c_cov.approx4 <- (A2_bar2) %*% solve(Q4, v2_bar2) opar <- par(mgp = c(1.3, 0.5, 0), mar = c(2, 2, 0.5, 0.5) + 0.1) plot(s, c.true - c_cov.approx,   type = \"l\", ylab = \"Error\", xlab = \"s\", col = 1,   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, c.true - c_cov.approx2, col = 2) lines(s, c.true - c_cov.approx3, col = 3) lines(s, c.true - c_cov.approx4, col = 4) legend(\"bottomright\",   bty = \"n\",   legend = c(\"m=2 coarse mesh\", \"m=4 coarse mesh\", \"m=2 fine mesh\", \"m=4 fine mesh\"),   col = c(1, 2, 3, 4),   lty = rep(1, 2), ncol = 1,   cex = 0.8 ) par(opar) errors <- rep(0, 4) for (i in 1:4) {   op_cov <- matern.operators(     kappa = kappa, sigma = sigma, nu = nu,     G = fem2$G, C = fem2$C, d = 1, m = i   )   Q <- precision(op_cov)   v_bar <- kronecker(matrix(1, nrow = i + 1), v2)   A_bar <- kronecker(matrix(1, ncol = i + 1), A2)   c_cov.approx <- (A_bar) %*% solve(Q, v_bar)   errors[i] <- norm(c.true - c_cov.approx) } print(errors) ## [1] 0.977500618 0.086659189 0.017335545 0.008432139"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"using-the-approximation","dir":"Articles","previous_headings":"","what":"Using the approximation","title":"Rational approximation with the rSPDE package","text":"use function matern.operators(), can simulate model using simulate() method. end simply apply simulate() method object returned matern.operators() function: want replicates, simply set argument nsim desired number replicates. instance, generate two replicates model, simply :","code":"u <- simulate(op_cov) u.rep <- simulate(op_cov, nsim = 2)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"fitting-a-model","dir":"Articles","previous_headings":"Using the approximation","what":"Fitting a model","title":"Rational approximation with the rSPDE package","text":"built-support computing log-likelihood functions performing kriging prediction rSPDE package. illustrate , use simulation create noisy observations process. , first construct observation matrix linking FEM basis functions locations want simulate. first randomly generate observation locations construct matrix. now generate observations \\(Y_i = u(s_i) + \\varepsilon_i\\), \\(\\varepsilon_i \\sim N(0,\\sigma_e^2)\\) Gaussian measurement noise. assume latent process Matérn covariance \\(\\kappa=20, \\sigma=2\\) \\(\\nu=0.8\\): Let us now fit model. end first must compute loglikelihood function function parameters want estimate. define loglikelihood function parametrized using logarithm parameter avoid constrained optimization. now get suitable initial values optimization using get.initial.values.rSPDE(). add initial guess sigma.e. can also speed optimization using optimParallel() function optimParallel package. end, simply replace optim() function optimParallel() set number cores want use:","code":"set.seed(1) s <- seq(from = 0, to = 1, length.out = 501) n.obs <- 200 obs.loc <- runif(n.obs) fem <- rSPDE.fem1d(s) A <- rSPDE.A1d(s, obs.loc) kappa <- 20 sigma <- 2 nu <- 0.8 op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 ) tau <- op_cov$tau u <- simulate(op_cov)  sigma.e <- 0.3 Y <- as.vector(A %*% u + sigma.e * rnorm(n.obs)) mlik_cov <- rSPDE.construct.matern.loglike(op_cov, Y=Y, A=A) theta0 <- c(   get.initial.values.rSPDE(mesh.range = 1, dim = 1,   parameterization = \"spde\"),   log(0.1 * sqrt(var(as.vector(Y)))) )  start_time <- Sys.time() theta <- optim(theta0, mlik_cov,   method = \"L-BFGS-B\" ) end_time <- Sys.time()  time_optim <- end_time - start_time  print(data.frame(   tau = c(tau, exp(theta$par[1])), kappa = c(kappa, exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) ##                  tau    kappa        nu   sigma.e ## Truth     0.02753295 20.00000 0.8000000 0.3000000 ## Estimates 0.02283271 18.00963 0.8176276 0.3302516 # Total time print(time_optim) ## Time difference of 5.935263 secs library(optimParallel) # Preparing the parallel  # Checking if we have a limit to the number of cores chk <- Sys.getenv(\"_R_CHECK_LIMIT_CORES_\", \"\") if (nzchar(chk) && chk == \"TRUE\") {   n_cores <- 2L } else {   n_cores <- parallel::detectCores() - 1 }  cl <- makeCluster(n_cores) setDefaultCluster(cl = cl)  # Exporting the needed objects to the parallel cores # This step is not necessary for the regular optim parallel::clusterExport(cl, \"op_cov\") parallel::clusterExport(cl, \"Y\") parallel::clusterExport(cl, \"A\")  start_time <- Sys.time() theta_parallel <- optimParallel(theta0, mlik_cov) end_time <- Sys.time()  time_optim <- end_time - start_time  print(data.frame(   tau = c(tau, exp(theta_parallel$par[1])),   kappa = c(kappa, exp(theta_parallel$par[2])),   nu = c(nu, exp(theta_parallel$par[3])),   sigma.e = c(sigma.e, exp(theta_parallel$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) ##                  tau    kappa        nu   sigma.e ## Truth     0.02753295 20.00000 0.8000000 0.3000000 ## Estimates 0.02283271 18.00963 0.8176276 0.3302516 # Total time print(time_optim) ## Time difference of 2.314552 secs"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"kriging","dir":"Articles","previous_headings":"Using the approximation","what":"Kriging","title":"Rational approximation with the rSPDE package","text":"Finally, compute kriging prediction process \\(u\\) locations s based observations. specify locations predicted, argument Aprd used. argument observation matrix links mesh locations prediction locations. Let us update CBrSPDEobj object (returned matern.operators() function) fitted parameters: can now perform kriging predict() method: simulated process, observed data, kriging prediction shown following figure.","code":"A.krig <- rSPDE.A1d(s, s) tau_est <- exp(theta$par[1]) kappa_est <- exp(theta$par[2]) nu_est <- exp(theta$par[3])  op_cov <- update(op_cov,   user_kappa = kappa_est,   user_tau = tau_est,   user_nu = nu_est ) u.krig <- predict(op_cov, A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e) opar <- par(mgp = c(1.3, 0.5, 0), mar = c(2, 2, 0.5, 0.5) + 0.1) plot(obs.loc, Y,   ylab = \"u(s)\", xlab = \"s\",   ylim = c(min(c(min(u), min(Y))), max(c(max(u), max(Y)))),   cex.main = 0.8, cex.axis = 0.8, cex.lab = 0.8 ) lines(s, u) lines(s, u.krig$mean, col = 2) par(opar)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"fitting-a-model-with-replicates","dir":"Articles","previous_headings":"","what":"Fitting a model with replicates","title":"Rational approximation with the rSPDE package","text":"Let us illustrate simulate dataset replicates fit model data. Recall simulate latent model replicates, set nsim argument number replicates. use CBrSPDEobj object (returned matern.operators() function) previous example, namely op_cov. Now, let us generate observed values \\(Y\\): Note \\(Y\\) matrix 20 columns, column containing one replicate. Now, remaining code identical previous case. rSPDE.matern.loglike() function automatically identifies replicates fact \\(Y\\) matrix one column.","code":"set.seed(123) n.rep <- 20 u.rep <- simulate(op_cov, nsim = n.rep) sigma.e <- 0.3 Y.rep <- A %*% u.rep + sigma.e * matrix(rnorm(n.obs * n.rep), ncol = n.rep) theta0 <- c(   get.initial.values.rSPDE(mesh.range = 1, dim = 1,   parameterization = \"spde\"),   log(0.1 * sqrt(var(as.vector(Y)))) )  mlik_cov <- rSPDE.construct.matern.loglike(op_cov, Y=Y.rep, A=A)  # Exporting the needed objects to the parallel cores # This step is not necessary for the regular optim parallel::clusterExport(cl, \"op_cov\") parallel::clusterExport(cl, \"Y.rep\") parallel::clusterExport(cl, \"A\")  start_time <- Sys.time() theta <- optimParallel(theta0, mlik_cov,   method = \"L-BFGS-B\" ) end_time <- Sys.time()  time_optim <- end_time - start_time  print(data.frame(   tau = c(tau, exp(theta$par[1])), kappa = c(kappa, exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) ##                  tau    kappa        nu   sigma.e ## Truth     0.02753295 20.00000 0.8000000 0.3000000 ## Estimates 0.02713452 17.50877 0.7854568 0.2934317 # Total time print(time_optim) ## Time difference of 1.013948 secs"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"spatial-data-and-parameter-estimation","dir":"Articles","previous_headings":"","what":"Spatial data and parameter estimation","title":"Rational approximation with the rSPDE package","text":"functions used previous examples also work spatial models. need construct mesh domain interest compute matrices needed define operator. tasks can performed, example, using R-INLA package. Let us start defining mesh \\([0,1]\\times [0, 1]\\) compute mass stiffness matrices mesh. important mention using R-INLA package recommend usage R-INLA implementation rational SPDE approach. purpose section show can estimate model without R-INLA using maximum likelihood approach instead. consider simple Gaussian linear model 30 independent replicates latent spatial field \\(u(\\mathbf{s})\\), observed \\(m\\) locations, \\(\\{\\mathbf{s}_1 , \\ldots , \\mathbf{s}_m \\}\\), replicate. \\(= 1,\\ldots,m,\\) \\[\\begin{align} y_i &= u_1(\\mathbf{s}_i)+\\varepsilon_i,\\\\ \\vdots &= \\vdots\\\\  y_{+29m} &= u_{30}(\\mathbf{s}_i) + \\varepsilon_{+29m}, \\end{align}\\] \\(\\varepsilon_1,\\ldots,\\varepsilon_{30m}\\) iid normally distributed mean 0 standard deviation 0.1. Let us create FEM mesh:  can now use mesh define rational SPDE approximation order \\(m=2\\) Matérn model fashion one-dimensional case. now simulate latent process standard deviation \\(\\sigma=1\\) range \\(0.1\\). use \\(\\nu=0.5\\) model exponential covariance function. end create model object matern.operators() function: Now let us simulate noisy data use estimate parameters model. construct observation matrix, use R-INLA function inla.spde.make.(). Recall simulate data 30 replicates. first replicate simulated random field well observation locations shown following figure.  now use function rSPDE.matern.loglike() define likelihood. function object-based, sense obtains several quantities needs rSPDE model object. case, example, object op_cov_2d. simplify parameter estimation, create objective function minimize negative log-likelihood, parametrized using logarithm parameter avoid constrained optimization. can now estimate parameter using optimParallel():","code":"library(INLA) n_loc <- 500 loc_2d_mesh <- matrix(runif(n_loc * 2), n_loc, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   offset = c(0.1, 0.4),   max.edge = c(0.05, 0.5) ) plot(mesh_2d, main = \"\") points(loc_2d_mesh[, 1], loc_2d_mesh[, 2]) nu <- 0.5 sigma <- 1 range <- 0.1 kappa <- sqrt(8 * nu) / range d <- 2 op_cov_2d <- matern.operators(   mesh = mesh_2d,   nu = nu,   kappa = kappa,   sigma = sigma,   m = 2 ) tau <- op_cov_2d$tau n.rep <- 30 u <- simulate(op_cov_2d, nsim = n.rep) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 Y <- A %*% u + matrix(rnorm(n_loc * n.rep), ncol = n.rep) * sigma.e library(viridis) library(ggplot2) proj <- inla.mesh.projector(mesh_2d, dims = c(70, 70))  df_field <- data.frame(x = proj$lattice$loc[,1],                         y = proj$lattice$loc[,2],                         field = as.vector(inla.mesh.project(proj,                          field = as.vector(u[, 1]))),                         type = \"field\")  df_loc <- data.frame(x = loc_2d_mesh[, 1],                       y = loc_2d_mesh[, 2],                       field = as.vector(Y[,1]),                       type = \"locations\") df_plot <- rbind(df_field, df_loc)  ggplot(df_plot) + aes(x = x, y = y, fill = field) +         facet_wrap(~type) + xlim(0,1) + ylim(0,1) +          geom_raster(data = df_field) +         geom_point(data = df_loc, aes(colour = field),         show.legend = FALSE) +          scale_fill_viridis() + scale_colour_viridis() mlik_2d <- rSPDE.construct.matern.loglike(op_cov_2d, Y=Y, A=A) theta0_2d <- c(   get.initial.values.rSPDE(mesh = mesh_2d,      parameterization = \"spde\"),   log(0.1 * sqrt(var(as.vector(Y)))) )  # Exporting the needed objects to the parallel cores # This step is not necessary for the regular optim parallel::clusterExport(cl, \"op_cov_2d\") parallel::clusterExport(cl, \"Y\") parallel::clusterExport(cl, \"A\")  start_time <- Sys.time() pars <- optimParallel(theta0_2d, mlik_2d) end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(   tau = c(tau, exp(pars$par[1])),   kappa = c(kappa, exp(pars$par[2])),   nu = c(nu, exp(pars$par[3])),   sigma.e = c(sigma.e, exp(pars$par[4])),   row.names = c(\"True\", \"Estimate\") ) print(results) ##                 tau   kappa        nu   sigma.e ## True     0.08920621 20.0000 0.5000000 0.1000000 ## Estimate 0.06640018 21.5346 0.5681172 0.1003235 # Total time print(total_time) ## Time difference of 1.946412 secs"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"an-example-with-a-non-stationary-model","dir":"Articles","previous_headings":"","what":"An example with a non-stationary model","title":"Rational approximation with the rSPDE package","text":"goal now show one can fit model non-stationary \\(\\sigma\\) (std. deviation) non-stationary \\(\\rho\\) (range parameter). One can also use parameterization terms non-stationary SPDE parameters \\(\\kappa\\) \\(\\tau\\). example consider simulated data.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"simulating-the-data","dir":"Articles","previous_headings":"An example with a non-stationary model","what":"Simulating the data","title":"Rational approximation with the rSPDE package","text":"Let us consider simple Gaussian linear model latent spatial field \\(x(\\mathbf{s})\\), defined rectangle \\((0,10) \\times (0,5)\\), std. deviation range parameter satisfy following log-linear regressions: \\[\\begin{align} \\log(\\sigma(\\mathbf{s})) &= \\theta_1 + \\theta_3 b(\\mathbf{s}),\\\\ \\log(\\rho(\\mathbf{s})) &= \\theta_2 + \\theta_3 b(\\mathbf{s}), \\end{align}\\] \\(b(\\mathbf{s}) = (s_1-5)/10\\). assume data observed \\(m\\) locations, \\(\\{\\mathbf{s}_1 , \\ldots , \\mathbf{s}_m \\}\\). \\(= 1,\\ldots,m,\\) \\[y_i = x_1(\\mathbf{s}_i)+\\varepsilon_i,\\] \\(\\varepsilon_1,\\ldots,\\varepsilon_{m}\\) iid normally distributed mean 0 standard deviation 0.1. begin defining domain creating mesh: follow structure INLA. However, INLA allows one specify B.tau B.kappa matrices, , INLA, one wants parameterize terms range standard deviation one needs manually. provide option directly provide matrices B.sigma B.range. usage matrices B.tau B.kappa identical corresponding ones inla.spde2.matern() function. matrices B.sigma B.range work way, parameterize stardard deviation range, respectively. columns B matrices correspond parameter. first column parameter estimated, constant column. , instance, one wants share parameter sigma range (tau kappa), one simply let corresponding column nonzero B.sigma B.range (B.tau B.kappa). assume \\(\\nu = 0.8\\), \\(\\theta_1 = 0, \\theta_2 = 1\\) \\(\\theta_3=1\\). Let us now build model spde.matern.operators() function: Let us now sample data simulate() method: Let us now obtain 600 random locations rectangle compute \\(\\) matrix: can now generate response vector y:","code":"rec_domain <- cbind(c(0, 1, 1, 0, 0) * 10, c(0, 0, 1, 1, 0) * 5)  mesh <- inla.mesh.2d(loc.domain = rec_domain, cutoff = 0.1,    max.edge = c(0.5, 1.5), offset = c(0.5, 1.5)) nu <- 0.8 true_theta <- c(0,1, 1) B.sigma = cbind(0, 1, 0, (mesh$loc[,1] - 5) / 10) B.range = cbind(0, 0, 1, (mesh$loc[,1] - 5) / 10)  # SPDE model op_cov_ns <- spde.matern.operators(mesh = mesh,    theta = true_theta,   nu = nu,   B.sigma = B.sigma,    B.range = B.range) u <- as.vector(simulate(op_cov_ns, seed = 123)) m <-600 loc_mesh <- cbind(runif(m) * 10, runif(m) * 5)  A <- inla.spde.make.A(   mesh = mesh,   loc = loc_mesh ) y <- as.vector(A %*% as.vector(u)) + rnorm(m) * 0.1"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"fitting-the-non-stationary-rspde-model","dir":"Articles","previous_headings":"An example with a non-stationary model","what":"Fitting the non-stationary rSPDE model","title":"Rational approximation with the rSPDE package","text":"can build likelihood function using function factory construct.spde.matern.loglike(): Let us now choose reasonable starting values (log scale) depending size domain get.initial.values.rSPDE() function: Let us now fit model: Let us now compare true values:","code":"mlik <- construct.spde.matern.loglike(op_cov_ns, y, A) theta0 <- c(get.initial.values.rSPDE(mesh = mesh, B.sigma = B.sigma, B.range = B.range), log(0.01)) theta <- optim(theta0, mlik) print(data.frame(   theta1 = c(true_theta[1], theta$par[1]), theta2 = c(true_theta[2], theta$par[2]),   theta3 = c(true_theta[3], theta$par[3]),    nu = c(nu, exp(theta$par[4])), sigma.e = c(sigma.e, exp(theta$par[5])),   row.names = c(\"Truth\", \"Estimates\") )) ##                theta1  theta2   theta3        nu   sigma.e ## Truth      0.00000000 1.00000 1.000000 0.8000000 0.1000000 ## Estimates -0.08635712 1.38477 1.129211 0.7824993 0.1032874"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"changing-the-type-and-the-order-of-the-rational-approximation","dir":"Articles","previous_headings":"","what":"Changing the type and the order of the rational approximation","title":"Rational approximation with the rSPDE package","text":"three rational approximations available. BRASIL algorithm Hofreither (2021), two “versions” Clenshaw-Lord Chebyshev-Pade algorithm, one lower bound zero another lower bound given Xiong, Simas, Bolin (2022). type rational approximation can chosen setting type_rational_approximation argument matern.operators function. BRASIL algorithm corresponds choice brasil, Clenshaw-Lord Chebyshev pade zero lower bound non-zero lower bounds given, respectively, choices chebfun chebfunLB. instance, can create rSPDE object chebfunLB rational approximation can check order rational approximation rational.order() function assign new order rational.order<-() function: Let us fit model using data previous example: can now estimate parameter using optimParallel(): Finally, can check type rational approximation rational.type() function assign new type using rational.type<-() function: Let us now fit model, data previous example, brasil rational approximation: can now estimate parameter using optimParallel():","code":"op_cov_2d_type <- matern.operators(   mesh = mesh_2d,   nu = nu,   kappa = kappa,   sigma = sigma,   m = 2,   type_rational_approximation = \"chebfunLB\" ) tau <- op_cov_2d_type$tau rational.order(op_cov_2d_type) ## [1] 2 rational.order(op_cov_2d_type) <- 3 mlik_2d_type <- rSPDE.construct.matern.loglike(op_cov_2d_type, Y=Y, A=A) # Exporting the needed objects to the parallel cores # This step is not necessary for the regular optim parallel::clusterExport(cl, \"op_cov_2d_type\")  start_time <- Sys.time() pars <- optimParallel(theta0_2d, mlik_2d_type) end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(   tau = c(tau, exp(pars$par[1])),   kappa = c(kappa, exp(pars$par[2])),   nu = c(nu, exp(pars$par[3])),   sigma.e = c(sigma.e, exp(pars$par[4])),   row.names = c(\"True\", \"Estimate\") ) print(results) ##                 tau    kappa        nu   sigma.e ## True     0.02870953 20.00000 0.8000000 0.1000000 ## Estimate 0.05336251 22.40719 0.6216584 0.1003005 # Total time print(total_time) ## Time difference of 4.672406 secs rational.type(op_cov_2d_type) ## [1] \"chebfunLB\" rational.type(op_cov_2d_type) <- \"brasil\" mlik_2d_type <- rSPDE.construct.matern.loglike(op_cov_2d_type, Y=Y, A=A) # Exporting the needed objects to the parallel cores # This step is not necessary for the regular optim parallel::clusterExport(cl, \"op_cov_2d_type\")  start_time <- Sys.time() pars <- optimParallel(theta0_2d, mlik_2d_type) end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(   tau = c(tau, exp(pars$par[1])),   kappa = c(kappa, exp(pars$par[2])),   nu = c(nu, exp(pars$par[3])),   sigma.e = c(sigma.e, exp(pars$par[4])),   row.names = c(\"True\", \"Estimate\") ) print(results) ##                 tau    kappa        nu   sigma.e ## True     0.02870953 20.00000 0.8000000 0.1000000 ## Estimate 0.06399538 21.76824 0.5763722 0.1002827 # Total time print(total_time) ## Time difference of 2.773043 secs"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"R-INLA implementation of the rational SPDE approach","text":"vignette present R-INLA implementation rational SPDE approach. theoretical details refer reader Rational approximation rSPDE package vignette Xiong, Simas, Bolin (2022). begin providing step--step illustration use implementation. end consider real world data set consists precipitation measurements Paraná region Brazil. initial model fitting, show change parameters model. end, also provide example replicates. important mention one can improve performance using PARDISO solver. Please, go https://www.pardiso-project.org/r-inla/#license apply license. Also, use inla.pardiso() instructions enable PARDISO sparse library.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"example-with-real-data","dir":"Articles","previous_headings":"","what":"Example with real data","title":"R-INLA implementation of the rational SPDE approach","text":"illustrate implementation rSPDE R-INLA consider dataset available R-INLA. data also used illustrate SPDE approach, see instance book Advanced Spatial Modeling Stochastic Partial Differential Equations Using R INLA also vignette Spatial Statistics using R-INLA Gaussian Markov random fields. See also Lindgren, Rue, Lindström (2011) theoretical details standard SPDE approach. data consist precipitation measurements Paraná region Brazil provided Brazilian National Water Agency. data collected 616 gauge stations Paraná state, south Brazil, day 2011.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"an-rspde-model-for-precipitation","dir":"Articles","previous_headings":"Example with real data","what":"An rSPDE model for precipitation","title":"R-INLA implementation of the rational SPDE approach","text":"follow vignette Spatial Statistics using R-INLA Gaussian Markov random fields. precipitation data always positive, assume Gamma distributed. R-INLA uses following parameterization Gamma distribution, \\[\\Gamma(\\mu, \\phi): \\pi (y) = \\frac{1}{\\Gamma(\\phi)} \\left(\\frac{\\phi}{\\mu}\\right)^{\\phi} y^{\\phi - 1} \\exp\\left(-\\frac{\\phi y}{\\mu}\\right) .\\] parameterization, distribution expected value \\(E(x) = \\mu\\) variance \\(V(x) = \\mu^2/(\\phi)\\), \\(1/\\phi\\) dispersion parameter. example \\(\\mu\\) modeled using stochastic model includes covariates spatial structure, resulting latent Gaussian model precipitation measurements \\[\\begin{align} y_i\\mid \\mu(s_i), \\theta &\\sim \\Gamma(\\mu(s_i),c\\phi)\\\\ \\log (\\mu(s)) &= \\eta(s) = \\sum_k f_k(c_k(s))+u(s)\\\\ \\theta &\\sim \\pi(\\theta) \\end{align},\\] \\(y_i\\) denotes measurement taken location \\(s_i\\), \\(c_k(s)\\) covariates, \\(u(s)\\) mean-zero Gaussian Matérn field, \\(\\theta\\) vector containing parameters model, including smoothness field. , using rSPDE model also able estimate smoothness latent field.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"examining-the-data","dir":"Articles","previous_headings":"Example with real data","what":"Examining the data","title":"R-INLA implementation of the rational SPDE approach","text":"using R-INLA. install R-INLA go R-INLA Project. begin loading libraries need get data build plots. Let us load data border region data frame contains daily measurements 616 stations year 2011, well coordinates altitude information measurement stations. analyze full spatio-temporal data set, instead look total precipitation January, calculate next snippet code, extract coordinates altitudes remove locations missing values. Let us build plot precipitation observations using ggplot:  red line figure shows coast line, expect distance coast good covariate precipitation. covariate available, let us calculate observation location: Now, let us plot precipitation function possible covariates:","code":"library(ggplot2) library(INLA) library(splancs) library(viridis) data(PRprec) data(PRborder) Y <- rowMeans(PRprec[, 3 + 1:31]) ind <- !is.na(Y) Y <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) alt <- PRprec$Altitude[ind] ggplot() +   geom_point(aes(     x = coords[, 1], y = coords[, 2],     colour = Y   ), size = 2, alpha = 1) +   geom_path(aes(x = PRborder[, 1], y = PRborder[, 2])) +   geom_path(aes(x = PRborder[1034:1078, 1], y = PRborder[     1034:1078,     2   ]), colour = \"red\") +    scale_color_viridis() seaDist <- apply(spDists(coords, PRborder[1034:1078, ],   longlat = TRUE ), 1, min) par(mfrow = c(2, 2)) plot(coords[, 1], Y, cex = 0.5, xlab = \"Longitude\") plot(coords[, 2], Y, cex = 0.5, xlab = \"Latitude\") plot(seaDist, Y, cex = 0.5, xlab = \"Distance to sea\") plot(alt, Y, cex = 0.5, xlab = \"Altitude\") par(mfrow = c(1, 1))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"creating-the-rspde-model","dir":"Articles","previous_headings":"Example with real data","what":"Creating the rSPDE model","title":"R-INLA implementation of the rational SPDE approach","text":"use R-INLA implementation rSPDE model need load functions: rSPDE-INLA implementation reminiscent R-INLA, usage straightforward R-INLA users. instance, create rSPDE model, one use rspde.matern() place inla.spde2.matern(). create index, one use rspde.make.index() place inla.spde.make.index(). create matrix, one use rspde.make.() place inla.spde.make.(), . main differences comparing arguments rSPDE-INLA implementation standard SPDE implementation R-INLA, nu rspde.order arguments, present rSPDE-INLA implementation. see use arguments.","code":"library(rSPDE)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"mesh","dir":"Articles","previous_headings":"Example with real data > Creating the rSPDE model","what":"Mesh","title":"R-INLA implementation of the rational SPDE approach","text":"can use R-INLA creating mesh. Let us create mesh based non-convex hull avoid adding many small triangles outside domain interest:","code":"prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2) plot(prmesh, asp = 1, main = \"\") lines(PRborder, col = 3) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"the-observation-matrix","dir":"Articles","previous_headings":"Example with real data > Creating the rSPDE model","what":"The observation matrix","title":"R-INLA implementation of the rational SPDE approach","text":"now create \\(\\) matrix, connects mesh observation locations create rSPDE model. task, mentioned earlier, need use rSPDEspecific function, whose name reminiscent R-INLA’s standard SPDE approach, namely rspde.make.() (place R-INLA’s inla.spde.make.()). reason need specific function size \\(\\) matrix depends order rational approximation. details can found introduction Rational approximation rSPDE package vignette. default order 2 covariance-based rational approximation. mentioned introduction Rational approximation rSPDE package vignette, approximation order 2 covariance-based rational approximation approximately computational cost operator-based rational approximation order 1. Recall latent process \\(u\\) solution \\[(\\kappa^2 -\\Delta)^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(\\alpha = \\nu + d/2\\). want estimate three parameters \\(\\tau,\\kappa\\) \\(\\nu\\), default option rSPDE-INLA implementation. However, also option fix smoothness parameter \\(\\nu\\) predefined value estimate \\(\\tau\\) \\(\\kappa\\). discussed later. first example assume want rational approximation order 2. end can use rspde.make.() function. Since assume order 2 want estimate smoothness, default options function, required parameters simply mesh locations:","code":"Abar <- rspde.make.A(mesh = prmesh, loc = coords)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"setting-up-the-rspde-model","dir":"Articles","previous_headings":"Example with real data > Creating the rSPDE model","what":"Setting up the rSPDE model","title":"R-INLA implementation of the rational SPDE approach","text":"set rSPDEmodel, need mesh. default assume want estimate smoothness parameter \\(\\nu\\) covariance-based rational approximation order 2. Later vignette also see options setting rSPDE models keeping smoothness parameter fixed /increasing order covariance-based rational approximation. Therefore, set model use rspde.matern() function: Note function reminiscent R-INLA’s inla.spde2.matern() function. pattern tried keep consistent package: rSPDE versions R-INLA function either replace inla inla.spde inla.spde2 rspde.","code":"rspde_model <- rspde.matern(mesh = prmesh)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"the-inla-stack","dir":"Articles","previous_headings":"Example with real data > Creating the rSPDE model","what":"The inla.stack","title":"R-INLA implementation of the rational SPDE approach","text":"Since covariates already evaluated observation locations, want apply \\(\\) matrix spatial effect fixed effects. can use inla.stack() function. difference, however, need use function rspde.make.index() (place standard inla.spde.make.index()) create index. one using default options, , estimate smoothness parameter \\(\\nu\\) rational approximation order 2, usage rspde.make.index() identical usage inla.spde.make.index(): can create stack standard manner: observation matrix \\(\\) applied spatial effect intercept identity observation matrix, denoted \\(1\\), applied covariates. means covariates unaffected observation matrix. observation matrices \\(=list(Abar,1)\\) used link corresponding elements effects-list observations. Thus model latent spatial field mesh.index intercept linked log-expectation observations, .e. \\(\\eta(s)\\), \\(\\)-matrix. covariates, hand, linked directly \\(\\eta(s)\\). stk.dat object defined implies following principal linkage model components observations \\[\\eta(s) \\sim x(s) + \\text{ Intercept} + \\text{seaDist}.\\] \\(\\eta(s)\\) used observation-likelihood, \\[y_i\\mid \\eta(s_i),\\theta \\sim \\Gamma(\\exp(\\eta (s_i)), c\\phi).\\]","code":"mesh.index <- rspde.make.index(name = \"field\", mesh = prmesh) stk.dat <- inla.stack(   data = list(y = Y), A = list(Abar, 1), tag = \"est\",   effects = list(     c(       mesh.index     ),     list(       seaDist = inla.group(seaDist),       Intercept = 1     )   ) )"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"model-fitting","dir":"Articles","previous_headings":"Example with real data","what":"Model fitting","title":"R-INLA implementation of the rational SPDE approach","text":"build model using distance sea \\(x_i\\) covariate improper CAR(1) model \\(\\beta_{ij}=1(\\sim j)\\), R-INLA calls random walk order 1. -1 added remove R’s implicit intercept, replaced explicit +Intercept created stack. fit model proceed standard SPDE approach simply call inla().","code":"f.s <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model) rspde_fit <- inla(f.s,   family = \"Gamma\", data = inla.stack.data(stk.dat),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE) )"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"inla-results","dir":"Articles","previous_headings":"Example with real data","what":"INLA results","title":"R-INLA implementation of the rational SPDE approach","text":"can look summaries posterior distributions parameters, example fixed effects (.e. intercept) hyper-parameters (.e. dispersion gamma likelihood, precision RW1, parameters spatial field): Let \\(\\theta_1 = \\textrm{Theta1}\\), \\(\\theta_2=\\textrm{Theta2}\\) \\(\\theta_3=\\textrm{Theta3}\\). terms SPDE \\[(\\kappa^2 - \\Delta)^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(\\alpha = \\nu + d/2\\), \\[\\tau = \\exp(\\theta_1),\\quad \\kappa = \\exp(\\theta_2), \\] default \\[\\nu = 4\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] number 4 comes upper bound \\(\\nu\\), discussed later vignette. general, \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big),\\] \\(\\nu_{UB}\\) value upper bound smoothness parameter \\(\\nu\\). Another choice prior \\(\\nu\\) truncated lognormal distribution also discussed later vignette.","code":"summary(rspde_fit) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.37, Running = 8.34, Post = 0.0476, Total = 11.8  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 1.922 0.257      1.418    1.922      2.426 1.922   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field CGeneric ##  ## Model hyperparameters: ##                                                     mean       sd 0.025quant ## Precision parameter for the Gamma observations    13.553 7.20e-01     12.216 ## Precision for seaDist                          25959.013 2.20e+04   4686.777 ## Theta1 for field                                  -0.886 1.08e-01     -1.082 ## Theta2 for field                                   1.224 5.60e-01      0.093 ## Theta3 for field                                  -3.429 4.48e-01     -4.445 ##                                                 0.5quant 0.975quant      mode ## Precision parameter for the Gamma observations    13.523     15.062    13.442 ## Precision for seaDist                          19780.283  84812.600 11570.969 ## Theta1 for field                                  -0.888     -0.648    -0.911 ## Theta2 for field                                   1.225      2.351     1.229 ## Theta3 for field                                  -3.433     -2.584    -3.338 ##  ## Marginal log-Likelihood:  -1257.71  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"rspde-inla-results","dir":"Articles","previous_headings":"Example with real data","what":"rSPDE-INLA results","title":"R-INLA implementation of the rational SPDE approach","text":"can obtain outputs respect parameters original scale using function rspde.result(): create plots posterior marginal densities, can use gg_df() function, creates ggplot2-friendly data frames. following figure shows posterior marginal densities three parameters using gg_df() function.  function reminiscent inla.spde.result() function main difference summary() plot() methods implemented.","code":"result_fit <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result_fit) ##             mean        sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 0.414488 0.0451883  0.3398630 0.409299   0.516406 0.397742 ## range   3.970920 2.3614100  1.1366100 3.406260  10.128000 2.481610 ## nu      0.136829 0.0571691  0.0502609 0.128859   0.270514 0.112695 posterior_df_fit <- gg_df(result_fit)  ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) +  facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"predictions","dir":"Articles","previous_headings":"Example with real data","what":"Predictions","title":"R-INLA implementation of the rational SPDE approach","text":"Let us now obtain predictions (.e. kriging) expected precipitation dense grid region. begin creating grid want predictions. end, can use rspde.mesh.projector() function. function arguments function inla.mesh.projector(), difference rSPDE version also argument nu argument rspde.order. Thus, proceed fashion R-INLA’s standard SPDE implementation: lattice contains 150 × 100 locations. One can easily change resolution kriging prediction changing nxy. Let us find cells outside region interest plot estimates . Let us plot locations prediction:  Now, ways calculate kriging prediction. simplest way evaluate mean individual random effects linear predictor calculate exponential sum (since \\(\\mu(s)=\\exp(\\eta(s))\\) ). accurate way calculate prediction jointly estimation, unfortunately quite computationally expensive prediction fine grid. However, illustration, proceed option show one can . end, first, link prediction coordinates mesh nodes \\(\\) matrix Since using distance sea covariate, also calculate covariate prediction locations. now make stack prediction locations. data prediction locations, set y= NA. join stack estimation stack. joint estimation takes , therefore turn computation certain things interested , marginals random effect. also use simplified integration strategy (actually using posterior mode hyper-parameters) command control.inla = list(int.strategy = \"eb\"), .e. empirical Bayes. extract indices prediction nodes extract mean standard deviation response: Finally, plot results:  , std. deviations:","code":"nxy <- c(150, 100) projgrid <- rspde.mesh.projector(prmesh,   xlim = range(PRborder[, 1]),   ylim = range(PRborder[, 2]), dims = nxy ) xy.in <- inout(projgrid$lattice$loc, cbind(PRborder[, 1], PRborder[, 2])) coord.prd <- projgrid$lattice$loc[xy.in, ] plot(coord.prd, type = \"p\", cex = 0.1) lines(PRborder) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\") A.prd <- projgrid$proj$A[xy.in, ] seaDist.prd <- apply(spDists(coord.prd,   PRborder[1034:1078, ],   longlat = TRUE ), 1, min) ef.prd <- list(   c(mesh.index),   list(     long = inla.group(coord.prd[       ,       1     ]), lat = inla.group(coord.prd[, 2]),     seaDist = inla.group(seaDist.prd),     Intercept = 1   ) ) stk.prd <- inla.stack(   data = list(y = NA),   A = list(A.prd, 1), tag = \"prd\",   effects = ef.prd ) stk.all <- inla.stack(stk.dat, stk.prd) rspde_fitprd <- inla(f.s,   family = \"Gamma\",   data = inla.stack.data(stk.all),   control.predictor = list(     A = inla.stack.A(stk.all),     compute = TRUE, link = 1   ),   control.compute = list(     return.marginals = FALSE,     return.marginals.predictor = FALSE   ),   control.inla = list(int.strategy = \"eb\") ) id.prd <- inla.stack.index(stk.all, \"prd\")$data m.prd <- rspde_fitprd$summary.fitted.values$mean[id.prd] sd.prd <- rspde_fitprd$summary.fitted.values$sd[id.prd] # Plot the predictions pred_df <- data.frame(x1 = coord.prd[,1],                       x2 = coord.prd[,2],                       mean = m.prd,                       sd = sd.prd)  ggplot(pred_df, aes(x = x1, y = x2, fill = mean)) +   geom_raster() +   scale_fill_viridis() ggplot(pred_df, aes(x = x1, y = x2, fill = sd)) +   geom_raster() + scale_fill_viridis()"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"an-example-with-replicates","dir":"Articles","previous_headings":"","what":"An example with replicates","title":"R-INLA implementation of the rational SPDE approach","text":"example simulate data replicates. use example considered Rational approximation rSPDE package vignette (difference way data organized). also refer reader vignette description function matern.operators(), along methods (instance, simulate() method).","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"simulating-the-data","dir":"Articles","previous_headings":"An example with replicates","what":"Simulating the data","title":"R-INLA implementation of the rational SPDE approach","text":"Let us consider simple Gaussian linear model 30 independent replicates latent spatial field \\(x(\\mathbf{s})\\), observed \\(m\\) locations, \\(\\{\\mathbf{s}_1 , \\ldots , \\mathbf{s}_m \\}\\), replicate. \\(= 1,\\ldots,m,\\) \\[\\begin{align} y_i &= x_1(\\mathbf{s}_i)+\\varepsilon_i,\\\\ \\vdots &= \\vdots\\\\  y_{+29m} &= x_{30}(\\mathbf{s}_i) + \\varepsilon_{+29m}, \\end{align}\\] \\(\\varepsilon_1,\\ldots,\\varepsilon_{30m}\\) iid normally distributed mean 0 standard deviation 0.1. use basis function representation \\(x(\\cdot)\\) define \\(\\) matrix linking point locations mesh. also need account fact 30 replicates locations. end, \\(\\) matrix need can generated inla.spde.make.() function. reason sampling \\(x(\\cdot)\\) directly latent vector described introduction Rational approximation rSPDE package vignette. begin creating mesh:  compute \\(\\) matrix, needed simulation, connects observation locations mesh: Notice simulated data, use \\(\\) matrix inla.spde.make.() function. now simulate latent process standard deviation \\(\\sigma=1\\) range \\(0.1\\). use \\(\\nu=0.5\\) model exponential covariance function. end create model object matern.operators() function: details function can found Rational approximation rSPDE package vignette. simulate latent process need use simulate() method operator_information object. obtain simulated data \\(y\\) connecting \\(\\) matrix adding gaussian noise. first replicate simulated random field well observation locations shown following figure.","code":"m <- 200 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   offset = c(0.1, 0.4),   max.edge = c(0.05, 0.5) ) plot(mesh_2d, main = \"\") points(loc_2d_mesh[, 1], loc_2d_mesh[, 2]) n.rep <- 30 A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh,   index = rep(1:m, times = n.rep),   repl = rep(1:n.rep, each = m) ) nu <- 0.5 sigma <- 1 range <- 0.1 kappa <- sqrt(8 * nu) / range tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi) * gamma(nu + 1))) d <- 2 operator_information <- matern.operators(   mesh = mesh_2d,   nu = nu,   kappa = kappa,   sigma = sigma,   m = 2 ) set.seed(1) u <- simulate(operator_information, nsim = n.rep) y <- as.vector(A %*% as.vector(u)) +   rnorm(m * n.rep) * 0.1 proj <- inla.mesh.projector(mesh_2d, dims = c(100, 100))  df_field <- data.frame(x = proj$lattice$loc[,1],                         y = proj$lattice$loc[,2],                         field = as.vector(inla.mesh.project(proj,                          field = as.vector(u[, 1]))),                         type = \"field\")  df_loc <- data.frame(x = loc_2d_mesh[, 1],                       y = loc_2d_mesh[, 2],                       field = y[1:m],                       type = \"locations\") df_plot <- rbind(df_field, df_loc)  ggplot(df_plot) + aes(x = x, y = y, fill = field) +         facet_wrap(~type) + xlim(0,1) + ylim(0,1) +          geom_raster(data = df_field) +         geom_point(data = df_loc, aes(colour = field),         show.legend = FALSE) +          scale_fill_viridis() + scale_colour_viridis() ## Warning: Removed 7599 rows containing missing values (`geom_raster()`)."},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"fitting-the-r-inla-rspde-model","dir":"Articles","previous_headings":"An example with replicates","what":"Fitting the R-INLA rSPDE model","title":"R-INLA implementation of the rational SPDE approach","text":"Let us use rational SPDE approach fit data. begin creating \\(\\) matrix index replicates, inla.stack object. important notice since replicates provide index repl arguments rspde.make.() function, also argument n.repl rspde.make.index() function. behave identically R-INLA’s counterparts, namely, inla.spde.make.() inla.make.index(). now create model object. Finally, create formula fit. extremely important forget replicate argument building formula inla() function produce warning might fit meaningless model. can get summary: summary user’s scale:","code":"Abar.rep <- rspde.make.A(   mesh = mesh_2d, loc = loc_2d_mesh, index = rep(1:m, times = n.rep),   repl = rep(1:n.rep, each = m) ) mesh.index.rep <- rspde.make.index(   name = \"field\", mesh = mesh_2d,   n.repl = n.rep )  st.dat.rep <- inla.stack(   data = list(y = y),   A = Abar.rep,   effects = mesh.index.rep ) rspde_model.rep <- rspde.matern(mesh = mesh_2d, parameterization = \"spde\") f.rep <-   y ~ -1 + f(field,     model = rspde_model.rep,     replicate = field.repl   ) rspde_fit.rep <-   inla(f.rep,     data = inla.stack.data(st.dat.rep),     family = \"gaussian\",     control.predictor =       list(A = inla.stack.A(st.dat.rep))   ) summary(rspde_fit.rep) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.35, Running = 54, Post = 0.606, Total = 58  ## Random effects: ##   Name     Model ##     field CGeneric ##  ## Model hyperparameters: ##                                          mean    sd 0.025quant 0.5quant ## Precision for the Gaussian observations 92.93 3.494      86.67    92.70 ## Theta1 for field                        -2.54 0.144      -2.81    -2.54 ## Theta2 for field                         3.04 0.040       2.96     3.04 ## Theta3 for field                        -1.87 0.034      -1.94    -1.87 ##                                         0.975quant  mode ## Precision for the Gaussian observations     100.44 91.95 ## Theta1 for field                             -2.25 -2.55 ## Theta2 for field                              3.12  3.04 ## Theta3 for field                             -1.81 -1.87 ##  ## Marginal log-Likelihood:  -4387.52  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit_rep <- rspde.result(rspde_fit.rep, \"field\", rspde_model.rep) summary(result_fit_rep) ##             mean        sd 0.025quant  0.5quant 0.975quant       mode ## tau    0.0799779 0.0116273   0.060194  0.078867   0.105770  0.0764737 ## kappa 20.8581000 0.8317780  19.300900 20.829600  22.566400 20.7591000 ## nu     0.5326670 0.0154717   0.502070  0.532814   0.562788  0.5335730 result_df <- data.frame(   parameter = c(\"tau\", \"kappa\", \"nu\"),   true = c(tau, kappa, nu),   mean = c(     result_fit_rep$summary.tau$mean,     result_fit_rep$summary.kappa$mean,     result_fit_rep$summary.nu$mean   ),   mode = c(     result_fit_rep$summary.tau$mode,     result_fit_rep$summary.kappa$mode,     result_fit_rep$summary.nu$mode   ) ) print(result_df) ##   parameter        true        mean       mode ## 1       tau  0.08920621  0.07997791  0.0764737 ## 2     kappa 20.00000000 20.85813990 20.7591373 ## 3        nu  0.50000000  0.53266700  0.5335733"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"an-example-with-a-non-stationary-model","dir":"Articles","previous_headings":"","what":"An example with a non-stationary model","title":"R-INLA implementation of the rational SPDE approach","text":"also possible consider models \\(\\sigma\\) (std. deviation) \\(\\rho\\) (range parameter) non-stationary. One can also use parameterization terms SPDE parameters \\(\\kappa\\) \\(\\tau\\). example model given vignette inlabru implementation rational SPDE approach.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"further-options-of-the-rspde-inla-implementation","dir":"Articles","previous_headings":"","what":"Further options of the rSPDE-INLA implementation","title":"R-INLA implementation of the rational SPDE approach","text":"now discuss arguments introduced R-INLA implementation rational approximation present R-INLA’s standard SPDE implementation. case provide illustrative example.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-upper-bound-for-the-smoothness-parameter","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the upper bound for the smoothness parameter","title":"R-INLA implementation of the rational SPDE approach","text":"fit rspde.matern() model need provide upper bound smoothness parameter \\(\\nu\\). reason sparsity precision matrix kept fixed R-INLA’s estimation higher value \\(\\nu\\) denser precision matrix gets. means higher value \\(\\nu\\), higher computational cost fit model. Therefore, ideally, want choose upper bound \\(\\nu\\) small possible. change value upper bound smoothness parameter, must change argument nu.upper.bound. default value nu.upper.bound 4. common choices nu.upper.bound 2 1. clear discussion smaller value nu.upper.bound faster estimation procedure . However, choose value nu.upper.bound low, “correct” value \\(\\nu\\) might belong interval \\((0,\\nu_{UB})\\), \\(\\nu_{UB}\\) value nu.upper.bound. Hence, one might forced increase nu.upper.bound estimate , , obviously increase computational cost need one estimation. Let us illustrate considering model considered precipitation Paraná region Brazil consider nu.upper.bound equal 2, generally good choice nu.upper.bound. simply use function rspde.matern() argument nu.upper.bound set 2: Since considering default rspde.order, \\(\\) matrix mesh index objects previous ones. Let us update formula fit model: Let us see summary fit: Let us compare cost previous fit, default value nu.upper.bound 4: can see fit nu.upper.bound equal 2 considerably faster. Finally, let us get result results field see estimate \\(\\nu\\):","code":"rspde_model_2 <- rspde.matern(mesh = prmesh, nu.upper.bound = 2) f.s.2 <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_2)  rspde_fit_2 <- inla(f.s.2,   family = \"Gamma\", data = inla.stack.data(stk.dat),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE) ) summary(rspde_fit_2) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.31, Running = 2.37, Post = 0.026, Total = 5.71  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 1.946 0.061      1.827    1.946      2.065 1.946   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field CGeneric ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.260    0.894     11.566 ## Precision for seaDist                          8975.051 5905.961   2672.264 ## Theta1 for field                                 -1.383    0.159     -1.689 ## Theta2 for field                                  0.171    0.408     -0.572 ## Theta3 for field                                 -0.347    1.357     -2.759 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.238      15.09   13.207 ## Precision for seaDist                          7416.802   24663.70 5288.967 ## Theta1 for field                                 -1.386      -1.06   -1.396 ## Theta2 for field                                  0.150       1.03    0.064 ## Theta3 for field                                 -0.445       2.54   -0.797 ##  ## Marginal log-Likelihood:  -1261.75  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') # nu.upper.bound = 4 rspde_fit$cpu.used ##         Pre     Running        Post       Total  ##  3.37185812  8.33515692  0.04762697 11.75464201 # nu.upper.bound = 2 rspde_fit_2$cpu.used ##        Pre    Running       Post      Total  ## 3.31405020 2.36998081 0.02600002 5.71003103 result_fit_2 <- rspde.result(rspde_fit_2, \"field\", rspde_model_2) summary(result_fit_2) ##             mean        sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 0.253922 0.0405445   0.185291 0.250000   0.344086 0.241696 ## range   1.291260 0.5749120   0.568471 1.157060   2.776920 0.940702 ## nu      0.858752 0.5076120   0.120588 0.779772   1.850620 0.358280"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-order-of-the-rational-approximation","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the order of the rational approximation","title":"R-INLA implementation of the rational SPDE approach","text":"change order rational approximation set argument rspde.order desired value. current available possibilities 1,2,3,…, 8. higher order rational approximation, accurate results , however, higher computational cost . default rspde.order 2 generally good choice reasonably accurate. See vignette Rational approximation rSPDE package details order rational approximation comparison Matérn covariance. Let us fit model covariance-based rational approximation order 3. Since changing order rational approximation, , changing rspde.order argument, need recompute \\(\\) matrix mesh index. Therefore, proceed follows: build new model: create new \\(\\) matrix: create new index: Now remaining steps : Let us see summary: can see summary computational cost significantly increased. Let us compare cost rspde.order=3 nu.upper.bound=2 cost rspde.order=2 nu.upper.bound=4: One can check order rational approximation using rational.order() function. also allows another way change order rational order, using corresponding rational.order<-() function. rational.order() rational.order<-() functions can applied inla.rspde object, matrix index objects. check models: check matrices: check indexes: Let us now change order rspde_model object 1: Let us fit new model: summary:","code":"rspde_model_order_3 <- rspde.matern(mesh = prmesh,    rspde.order = 3,   nu.upper.bound = 2 ) Abar_3 <- rspde.make.A(mesh = prmesh, loc = coords, rspde.order = 3) mesh.index.3 <- rspde.make.index(   name = \"field\", mesh = prmesh,   rspde.order = 3 ) stk.dat.3 <- inla.stack(   data = list(y = Y), A = list(Abar_3, 1), tag = \"est\",   effects = list(     c(       mesh.index.3     ),     list(       long = inla.group(coords[, 1]),       lat = inla.group(coords[, 2]),       seaDist = inla.group(seaDist),       Intercept = 1     )   ) )  f.s.3 <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_order_3)  rspde_fit_order_3 <- inla(f.s.3,   family = \"Gamma\", data = inla.stack.data(stk.dat.3),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat.3), compute = TRUE) ) summary(rspde_fit_order_3) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.19, Running = 3.85, Post = 0.0291, Total = 7.06  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 1.943 0.074      1.798    1.943      2.087 1.943   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field CGeneric ##  ## Model hyperparameters: ##                                                     mean       sd 0.025quant ## Precision parameter for the Gamma observations    13.248 8.82e-01     11.563 ## Precision for seaDist                          15036.390 1.24e+04   4560.264 ## Theta1 for field                                  -1.212 2.02e-01     -1.552 ## Theta2 for field                                   0.666 6.36e-01     -0.348 ## Theta3 for field                                  -0.872 1.41e+00     -3.500 ##                                                 0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations    13.232     15.037   13.221 ## Precision for seaDist                          11442.822  48311.595 7240.072 ## Theta1 for field                                  -1.230     -0.766   -1.308 ## Theta2 for field                                   0.595      2.107    0.267 ## Theta3 for field                                  -0.926      2.020   -1.125 ##  ## Marginal log-Likelihood:  -1260.83  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') # nu.upper.bound = 4 rspde_fit$cpu.used ##         Pre     Running        Post       Total  ##  3.37185812  8.33515692  0.04762697 11.75464201 # nu.upper.bound = 2 rspde_fit_order_3$cpu.used ##        Pre    Running       Post      Total  ## 3.18765306 3.84797382 0.02912617 7.06475306 rational.order(rspde_model) ## [1] 2 rational.order(rspde_model_order_3) ## [1] 3 rational.order(Abar) ## [1] 2 rational.order(Abar_3) ## [1] 3 rational.order(mesh.index) ## [1] 2 rational.order(mesh.index.3) ## [1] 3 rational.order(rspde_model) <- 1 rational.order(Abar) <- 1 rational.order(mesh.index) <- 1 f.s.1 <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model)  stk.dat.1 <- inla.stack(   data = list(y = Y), A = list(Abar, 1), tag = \"est\",   effects = list(     c(       mesh.index     ),     list(       long = inla.group(coords[, 1]),       lat = inla.group(coords[, 2]),       seaDist = inla.group(seaDist),       Intercept = 1     )   ) )  rspde_fit_order_1 <- inla(f.s.1,   family = \"Gamma\", data = inla.stack.data(stk.dat.1),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat.1), compute = TRUE) ) summary(rspde_fit_order_1) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.19, Running = 5.26, Post = 0.0251, Total = 8.47  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 1.919 0.575      0.792    1.919      3.046 1.919   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field CGeneric ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations    13.44 8.98e-01      11.72 ## Precision for seaDist                          24512.15 1.64e+04    4753.20 ## Theta1 for field                                  -1.06 6.20e-02      -1.21 ## Theta2 for field                                   1.91 3.70e-01       1.01 ## Theta3 for field                                  -2.65 3.04e-01      -3.36 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations    13.43     15.254    13.44 ## Precision for seaDist                          20608.34  66842.728 12980.93 ## Theta1 for field                                  -1.06     -0.953    -1.03 ## Theta2 for field                                   1.87      2.605     2.08 ## Theta3 for field                                  -2.66     -2.097    -2.50 ##  ## Marginal log-Likelihood:  -1257.92  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"estimating-models-with-fixed-smoothness","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Estimating models with fixed smoothness","title":"R-INLA implementation of the rational SPDE approach","text":"can fix smoothness, say \\(\\nu\\), model providing non-NULL positive value nu. smoothness, \\(\\nu\\), fixed, can two possibilities: \\(\\alpha = \\nu + d/2\\) integer; \\(\\alpha = \\nu + d/2\\) integer. first case, .e., \\(\\alpha\\) integer, less computational cost. Furthermore, \\(\\) matrix different \\(\\) matrix non-integer \\(\\alpha\\). \\(\\) matrix values \\(\\nu\\) \\(\\alpha\\) integer. , \\(\\) matrix cases need computed . holds index obtained rspde.make.index() function. second case \\(\\) matrix depends order rational approximation \\(\\nu\\). Therefore, matrix \\(\\) already computed rspde.order, \\(\\) matrix values \\(\\nu\\) \\(\\alpha\\) non-integer rspde.order. holds index obtained rspde.make.index() function. \\(\\nu\\) fixed, parameters returned R-INLA \\[\\kappa = \\exp(\\theta_1)\\quad\\hbox{}\\quad\\tau = \\exp(\\theta_2).\\] now provide illustrations scenarios. also noteworthy just case estimate \\(\\nu\\), can also change order rational approximation changing value rspde.order. illustrations fixed \\(\\nu\\) , consider order rational approximation 2, , default order.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"estimating-models-with-fixed-smoothness-and-non-integer-alpha","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation > Estimating models with fixed smoothness","what":"Estimating models with fixed smoothness and non-integer \\(\\alpha\\)","title":"R-INLA implementation of the rational SPDE approach","text":"Recall : \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] Thus, illustrate, let us consider fixed \\(\\nu\\) given mean \\(\\nu\\) obtained first model considered vignette, namely, fit given rspde_fit, approximately \\(\\nu = 1.21\\). Notice \\(\\nu\\), value \\(\\alpha\\) non-integer, can use \\(\\) matrix index first fitted model, also order 2. Therefore, build new model set nu 1.21: Let us now fit model: summary: Now, summary original scale:","code":"rspde_model_fix <- rspde.matern(mesh = prmesh, rspde.order = 2,   nu = 1.21 ) f.s.fix <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_fix)  rspde_fix <- inla(f.s.fix,   family = \"Gamma\", data = inla.stack.data(stk.dat),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE) ) summary(rspde_fix) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.26, Running = 1.88, Post = 0.0257, Total = 5.16  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 1.945 0.051      1.845    1.945      2.045 1.945   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field CGeneric ##  ## Model hyperparameters: ##                                                   mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.22    0.889      11.55 ## Precision for seaDist                          9879.57 7824.307    2458.62 ## Theta1 for field                                 -1.48    0.136      -1.74 ## Theta2 for field                                 -0.01    0.282      -0.52 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.193     15.050   13.145 ## Precision for seaDist                          7658.036  30694.645 5013.268 ## Theta1 for field                                 -1.478     -1.207   -1.482 ## Theta2 for field                                 -0.025      0.585   -0.087 ##  ## Marginal log-Likelihood:  -1262.38  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fix <- rspde.result(rspde_fix, \"field\", rspde_model_fix) summary(result_fix) ##             mean        sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 0.230418 0.0313161   0.175606 0.228065   0.298369 0.223101 ## range   1.030630 0.3058310   0.596852 0.972720   1.783950 0.863373"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"estimating-models-with-fixed-smoothness-and-integer-alpha","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation > Estimating models with fixed smoothness","what":"Estimating models with fixed smoothness and integer \\(\\alpha\\)","title":"R-INLA implementation of the rational SPDE approach","text":"Since dimension \\(d=2\\), \\(\\nu>0\\), smallest value \\(\\nu\\) makes \\(\\alpha = \\nu + 1\\) integer \\(\\nu=1\\). value also close estimated mean first model fitted enclosed posterior marginal density \\(\\nu\\) first fit. Therefore, let us fit model \\(\\nu=1\\). end need compute new \\(\\) matrix: new index: create new model (remember set nu=1): remaining standard: Let us check summary: check summary user’s scale:","code":"Abar.int <- rspde.make.A(   mesh = prmesh, loc = coords,   nu = 1 ) mesh.index.int <- rspde.make.index(   name = \"field\", mesh = prmesh,   nu = 1 ) rspde_model_fix_int1 <- rspde.matern(mesh = prmesh,   nu = 1) stk.dat.int <- inla.stack(   data = list(y = Y), A = list(Abar.int, 1), tag = \"est\",   effects = list(     c(       mesh.index.int     ),     list(       long = inla.group(coords[, 1]),       lat = inla.group(coords[, 2]),       seaDist = inla.group(seaDist),       Intercept = 1     )   ) )  f.s.fix.int.1 <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_fix_int1)  rspde_fix_int_1 <- inla(f.s.fix.int.1,   family = \"Gamma\",   data = inla.stack.data(stk.dat.int), verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(     A = inla.stack.A(stk.dat.int),     compute = TRUE   ) ) summary(rspde_fix_int_1) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.23, Running = 0.659, Post = 0.0203, Total = 3.91  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 1.944 0.057      1.833    1.944      2.056 1.944   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field CGeneric ##  ## Model hyperparameters: ##                                                     mean       sd 0.025quant ## Precision parameter for the Gamma observations    13.212 8.88e-01     11.525 ## Precision for seaDist                          13195.937 1.30e+04   2695.358 ## Theta1 for field                                  -1.425 1.53e-01     -1.718 ## Theta2 for field                                   0.108 3.35e-01     -0.498 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.191     15.024   13.165 ## Precision for seaDist                          9324.872  47397.432 5496.085 ## Theta1 for field                                 -1.429     -1.116   -1.441 ## Theta2 for field                                  0.089      0.816    0.014 ##  ## Marginal log-Likelihood:  -1262.04  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') rspde_result_int <- rspde.result(rspde_fix_int_1, \"field\", rspde_model_fix_int1) summary(rspde_result_int) ##             mean        sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 0.243194 0.0374033   0.180039 0.239504   0.326554 0.231535 ## range   1.178970 0.4225040   0.611035 1.089970   2.244390 0.931383"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-priors","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the priors","title":"R-INLA implementation of the rational SPDE approach","text":"begin recalling fitted rSPDE model R-INLA contains parameters \\(\\textrm{Theta1}\\), \\(\\textrm{Theta2}\\) \\(\\textrm{Theta3}\\). Let, , \\(\\theta_1 = \\textrm{Theta1}\\), \\(\\theta_2=\\textrm{Theta2}\\) \\(\\theta_3=\\textrm{Theta3}\\). terms SPDE \\[(\\kappa^2 - \\Delta)^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(\\alpha = \\nu + d/2\\). also range parameter \\(\\rho = \\frac{\\sqrt{8\\nu}}{\\kappa}\\) standard deviation \\(\\sigma = \\sqrt{\\frac{\\Gamma(\\nu)}{\\tau^2 \\kappa^{2\\nu}(4\\pi)^{d/2}\\Gamma(\\nu + d/2)}}\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-priors-of-tau-and-kappa","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation > Changing the priors","what":"Changing the priors of \\(\\tau\\) and \\(\\kappa\\)","title":"R-INLA implementation of the rational SPDE approach","text":"begin dealing \\(\\tau\\) \\(\\kappa\\). \\[\\tau = \\exp(\\theta_1),\\quad \\kappa = \\exp(\\theta_2).\\] rspde.matern() function assumes lognormal prior distribution \\(\\tau\\) \\(\\kappa\\). prior distribution obtained assuming \\(\\theta_1\\) \\(\\theta_2\\) follow normal distributions. default assume \\(\\theta_1\\) \\(\\theta_2\\) independent follow normal distributions \\(\\theta_1\\sim N(\\log(\\tau_0), 10)\\) \\(\\theta_2\\sim N(\\log(\\kappa_0), 10)\\). \\(\\kappa_0\\) suitably defined terms mesh \\(\\tau_0\\) defined terms \\(\\kappa_0\\) prior smoothness parameter. one wants define prior \\[\\theta_1 \\sim N(\\text{mean_theta_1}, \\text{sd_theta_1}),\\] one can simply set argument prior.tau = list(meanlog=mean_theta_1, sdlog=sd_theta_1). Analogously, define prior \\[\\theta_2 \\sim N(\\text{mean_theta_2}, \\text{sd_theta_2}),\\] one can set argument prior.kappa = list(meanlog=mean_theta_2, sdlog=sd_theta_2). important mention , default, initial values \\(\\tau\\) \\(\\kappa\\) \\(\\exp(\\text{mean_theta_1})\\) \\(\\exp(\\text{mean_theta_2})\\), respectively. , user change parameters, also change initial values, initial values \\(\\tau\\) \\(\\kappa\\) , respectively, \\(\\tau_0\\) \\(\\kappa_0\\). one sets prior.tau = list(meanlog=mean_theta_1), prior \\(\\theta_1\\) \\[\\theta_1 \\sim N(\\text{mean_theta_1}, 1),\\] whereas, one sets, prior.tau = list(sdlog=sd_theta_1), prior \\[\\theta_1 \\sim N(\\log(\\tau_0), \\text{sd_theta_1}).\\] Analogously, one sets prior.kappa = list(meanlog=mean_theta_2), prior \\(\\theta_2\\) \\[\\theta_2 \\sim N(\\text{mean_theta_2}, 1),\\] whereas, one sets, prior.kappa = list(sdlog=sd_theta_2), prior \\[\\theta_2 \\sim N(\\log(\\kappa_0), \\text{sd_theta_2}).\\]","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-priors-of-rho-range-and-sigma-std--dev-","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation > Changing the priors","what":"Changing the priors of \\(\\rho\\) (range) and \\(\\sigma\\) (std. dev.)","title":"R-INLA implementation of the rational SPDE approach","text":"Let us now consider priors range, \\(\\rho\\), std. deviation, \\(\\sigma\\). parameterization used argument parameterization = \"matern\", default. case, \\[\\sigma = \\exp(\\theta_1),\\quad \\rho = \\exp(\\theta_2).\\] two options prior. default, option prior.theta.param = \"theta\", rspde.matern() function assumes lognormal prior distribution \\(\\sigma\\) \\(\\rho\\). prior distribution obtained assuming \\(\\theta_1\\) \\(\\theta_2\\) follow normal distributions. default assume \\(\\theta_1\\) \\(\\theta_2\\) independent follow normal distributions \\(\\theta_1\\sim N(\\log(\\sigma_0), 10)\\) \\(\\theta_2\\sim N(\\log(\\rho_0), 10)\\). \\(\\rho_0\\) suitably defined terms mesh \\(\\sigma_0\\) defined terms \\(\\rho_0\\) prior smoothness parameter. Similarly priors \\(\\tau\\) \\(\\kappa\\), one wants define prior \\[\\theta_1 \\sim N(\\text{mean_theta_1}, \\text{sd_theta_1}),\\] one can simply set argument prior.tau = list(meanlog=mean_theta_1, sdlog=sd_theta_1). Analogously, define prior \\[\\theta_2 \\sim N(\\text{mean_theta_2}, \\text{sd_theta_2}),\\] one can set argument prior.kappa = list(meanlog=mean_theta_2, sdlog=sd_theta_2). Another option set prior.theta.param = \"spde\". case, change variables performed. , assume lognormal prior \\(\\tau\\) \\(\\kappa\\). , relations \\(\\rho = \\frac{\\sqrt{8\\nu}}{\\kappa}\\) \\(\\sigma = \\sqrt{\\frac{\\Gamma(\\nu)}{\\tau^2 \\kappa^{2\\nu}(4\\pi)^{d/2}\\Gamma(\\nu + d/2)}}\\), obtain prior \\(\\rho\\) \\(\\sigma\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-prior-of-nu","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation > Changing the priors","what":"Changing the prior of \\(\\nu\\)","title":"R-INLA implementation of the rational SPDE approach","text":"Finally, let us consider smoothness parameter \\(\\nu\\). default, assume \\(\\nu\\) follows beta distribution interval \\((0,\\nu_{UB})\\), \\(\\nu_{UB}\\) upper bound \\(\\nu\\), mean \\(\\nu_0=\\min\\{1, \\nu_{UB}/2\\}\\) variance \\(\\frac{\\nu_0(\\nu_{UB}-\\nu_0)}{1+\\phi_0}\\), call \\(\\phi_0\\) precision parameter, whose default value \\[\\phi_0 = \\max\\Big\\{\\frac{\\nu_{UB}}{\\nu_0}, \\frac{\\nu_{UB}}{\\nu_{UB}-\\nu_0}\\Big\\} + \\phi_{inc}.\\] parameter \\(\\phi_{inc}\\) increment ensure prior beta density boundary values equal zero (boundary values defined either continuity limits). default value \\(\\phi_{inc}\\) 1. value \\(\\phi_{inc}\\) can changed changing argument nu.prec.inc rspde.matern() function. higher value \\(\\phi_{inc}\\) (, value nu.prec.inc) informative prior distribution becomes. Let us denote beta distribution support \\((0,\\nu_{UB})\\), mean \\(\\mu\\) precision parameter \\(\\phi\\) \\(\\mathcal{B}_{\\nu_{UB}}(\\mu,\\phi)\\). want \\(\\nu\\) prior \\[\\nu \\sim \\mathcal{B}_{\\nu_{UB}}(\\text{nu_1},\\text{prec_1}),\\] one simply needs set prior.nu = list(mean=nu_1, prec=prec_1). one sets prior.nu = list(mean=nu_1), \\(\\nu\\) prior \\[\\nu \\sim \\mathcal{B}_{\\nu_{UB}}(\\text{nu_1},\\phi_1),\\] \\[\\phi_1 = \\max\\Big\\{\\frac{\\nu_{UB}}{\\text{nu_1}}, \\frac{\\nu_{UB}}{\\nu_{UB}-\\text{nu_1}}\\Big\\} + \\text{nu.prec.inc}.\\] one sets prior.nu = list(prec=prec_1), \\(\\nu\\) prior \\[\\nu\\sim \\mathcal{B}_{\\nu_{UB}}(\\nu_0, \\text{prec_1}).\\] also noteworthy , terms R-INLA’s parameters, \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] important mention , default, beta prior distribution chosen smoothness parameter \\(\\nu\\), initial value \\(\\nu\\) mean prior beta distribution. , user change parameter, also change initial value, initial value \\(\\nu\\) \\(\\min\\{1,\\nu_{UB}/2\\}\\). also assume , terms R-INLA’s parameters, \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] can another possibility prior distribution \\(\\nu\\), namely, truncated lognormal distribution. truncated lognormal distribution defined following sense. assume \\(\\log(\\nu)\\) prior distribution given truncated normal distribution support \\((-\\infty,\\log(\\nu_{UB}))\\), \\(\\nu_{UB}\\) upper bound \\(\\nu\\), location parameter \\(\\mu_0 =\\log(\\nu_0)= \\log\\Big(\\min\\{1,\\nu_{UB}/2\\}\\Big)\\) scale parameter \\(\\sigma_0 = 1\\). precisely, let \\(\\Phi(\\cdot; \\mu,\\sigma)\\) stand cumulative distribution function (CDF) normal distribution mean \\(\\mu\\) standard deviation \\(\\sigma\\). , \\(\\log(\\nu)\\) cumulative distribution function given \\[F_{\\log(\\nu)}(x) = \\frac{\\Phi(x;\\mu_0,\\sigma_0)}{\\Phi(\\nu_{UB})},\\quad x\\leq \\nu_{UB},\\] \\(F_{\\log(\\nu)}(x) = 1\\) \\(x>\\nu_{UB}\\). call \\(\\mu_0\\) \\(\\sigma_0\\) log-location log-scale parameters \\(\\nu\\), respectively, say \\(\\log(\\nu)\\) follows truncated normal distribution location parameter \\(\\mu_0\\) scale parameter \\(\\sigma_0\\). change prior distribution \\(\\nu\\) truncated lognormal distribution, need set argument prior.nu.dist=\"lognormal\". change parameters prior distribution , say, log_nu_1 log_sigma_1, one can simply set prior.nu = list(loglocation=log_nu_1, logscale=sigma_1). one sets prior.nu = list(loglocation=log_nu_1), prior \\(\\theta_3\\) truncated normal normal distribution location parameter log_nu_1 scale parameter 1. Analogously, one sets, prior.nu = list(logscale=sigma_1), prior \\(\\theta_3\\) truncated normal distribution location parameter \\(\\log(\\nu_0)= \\log\\Big(\\min\\{1,\\nu_{UB}/2\\}\\Big)\\) scale parameter sigma_1. important mention , default, truncated lognormal prior distribution chosen smoothness parameter \\(\\nu\\), initial value \\(\\nu\\) exponential log-location parameter \\(\\nu\\). , user change parameter, also change initial value, initial value \\(\\nu\\) \\(\\min\\{1,\\nu_{UB}/2\\}\\). Let us consider example dataset used first model vignette change prior distribution \\(\\nu\\) beta lognormal. Since change rspde.order fixing \\(\\nu\\), can use \\(\\) matrix index first example. Therefore, update formula fit model: summary: Also, can summary user’s scale: plot posterior marginal densities","code":"rspde_model_beta <- rspde.matern(mesh = prmesh, prior.nu.dist = \"lognormal\") f.s.beta <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_beta)  rspde_fit_beta <- inla(f.s.beta,   family = \"Gamma\", data = inla.stack.data(stk.dat),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE) ) summary(rspde_fit_beta) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.18, Running = 5.94, Post = 0.0325, Total = 9.16  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 1.945 0.048       1.85    1.945       2.04 1.945   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field CGeneric ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.199    0.887     11.512 ## Precision for seaDist                          8613.454 6282.253   2328.476 ## Theta1 for field                                 -1.515    0.136     -1.785 ## Theta2 for field                                 -0.104    0.228     -0.535 ## Theta3 for field                                 -0.045    0.972     -1.950 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.180     15.004   13.158 ## Precision for seaDist                          6874.369  25304.150 4686.269 ## Theta1 for field                                 -1.514     -1.249   -1.512 ## Theta2 for field                                 -0.111      0.361   -0.137 ## Theta3 for field                                 -0.049      1.880   -0.065 ##  ## Marginal log-Likelihood:  -1262.69  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit_beta <- rspde.result(rspde_fit_beta, \"field\", rspde_model_beta) summary(result_fit_beta) ##             mean        sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 0.221804 0.0300503   0.168231 0.219957    0.28609 0.216499 ## range   0.924331 0.2151720   0.588354 0.893895    1.42876 0.831014 ## nu      1.961290 0.8141540   0.506047 1.950230    3.46209 1.881100 posterior_df_fit_beta <- gg_df(result_fit_beta)  ggplot(posterior_df_fit_beta) + geom_line(aes(x = x, y = y)) +  facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-starting-values","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the starting values","title":"R-INLA implementation of the rational SPDE approach","text":"starting values used R-INLA’s optimization algorithm can changed setting arguments start.ltau, start.lkappa start.nu. start.ltau initial value \\(\\log(\\tau)\\), , logarithm \\(\\tau\\). start.lkappa inital value \\(\\log(\\kappa)\\), , logarithm \\(\\kappa\\). start.nu initial value \\(\\nu\\). Notice initial value log scale. One can change initial value one parameters. instance, let us consider example precipitation data, rspde.order=3, change initial values ones close fitted value considering default rspde.order (2): Since already computed \\(\\) matrix index rspde.order=3, update formula fit: summary:","code":"rspde_model_order_3_start <- rspde.matern(mesh = prmesh, rspde.order = 3,   nu.upper.bound = 2,   start.lkappa = result_fit$summary.log.kappa$mean,   start.ltau = result_fit$summary.log.tau$mean,   start.nu = min(result_fit$summary.nu$mean, 2 - 1e-5) ) f.s.3.start <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_order_3_start)  rspde_fit_order_3_start <- inla(f.s.3.start,   family = \"Gamma\",   data = inla.stack.data(stk.dat.3),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(     A = inla.stack.A(stk.dat.3),     compute = TRUE   ) ) summary(rspde_fit_order_3_start) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.25, Running = 4.29, Post = 0.0299, Total = 7.56  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 1.919 0.408      1.119    1.919      2.719 1.919   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field CGeneric ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations    13.30 8.95e-01     11.633 ## Precision for seaDist                          28348.28 2.22e+04   5057.111 ## Theta1 for field                                  -0.84 2.09e-01     -1.221 ## Theta2 for field                                   2.08 9.67e-01      0.386 ## Theta3 for field                                  -2.35 6.87e-01     -3.779 ##                                                 0.5quant 0.975quant      mode ## Precision parameter for the Gamma observations    13.264     15.159    13.189 ## Precision for seaDist                          22391.203  87357.722 13187.236 ## Theta1 for field                                  -0.851     -0.401    -0.893 ## Theta2 for field                                   2.006      4.167     1.712 ## Theta3 for field                                  -2.328     -1.071    -2.226 ##  ## Marginal log-Likelihood:  -1259.08  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-type-of-the-rational-approximation","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the type of the rational approximation","title":"R-INLA implementation of the rational SPDE approach","text":"three rational approximations available. BRASIL algorithm Hofreither (2021), two “versions” Clenshaw-Lord Chebyshev-Pade algorithm, one lower bound zero another lower bound given Xiong, Simas, Bolin (2022). type rational approximation can chosen setting type.rational.approx argument rspde.matern function. BRASIL algorithm corresponds choice brasil, Clenshaw-Lord Chebyshev pade zero lower bound non-zero lower bounds given, respectively, choices chebfun chebfunLB. Let us fit model assigning brasil rational approximation. consider model order rational approximation 1: Let us get summary: Finally, similarly order rational approximation, one can check order rational.type() function, assign new type rational.type<-() function. Let us change type rational approximation model rational approximation order 3: Let us get summary:","code":"rspde_model_brasil <- rspde.matern(prmesh,                type.rational.approx = \"brasil\")  f.s.brasil <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_brasil)  rspde_fit_order_1_brasil <- inla(f.s.brasil,   family = \"Gamma\", data = inla.stack.data(stk.dat),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE) ) summary(rspde_fit_order_1_brasil) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.23, Running = 9.33, Post = 0.0281, Total = 12.6  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 1.926 0.376      1.189    1.926      2.663 1.926   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field CGeneric ##  ## Model hyperparameters: ##                                                     mean       sd 0.025quant ## Precision parameter for the Gamma observations    13.682 7.72e-01     12.263 ## Precision for seaDist                          21015.448 1.56e+04   6702.941 ## Theta1 for field                                  -0.437 2.61e-01     -0.940 ## Theta2 for field                                   1.137 5.55e-01     -0.101 ## Theta3 for field                                  -4.864 7.20e-01     -6.651 ##                                                 0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations    13.646     15.308    13.55 ## Precision for seaDist                          16685.984  63444.710 11016.35 ## Theta1 for field                                  -0.405      0.209    -0.54 ## Theta2 for field                                   1.143      2.159     1.25 ## Theta3 for field                                  -4.960     -3.472    -4.58 ##  ## Marginal log-Likelihood:  -1257.22  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') rational.type(rspde_model) ## [1] \"chebfun\" rational.type(rspde_model_brasil) ## [1] \"brasil\" rational.type(rspde_model_order_3) <- \"brasil\"  f.s.3 <- y ~ -1 + Intercept + f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_order_3)  rspde_fit_order_3_brasil <- inla(f.s.3,   family = \"Gamma\", data = inla.stack.data(stk.dat.3),   verbose = FALSE,   control.inla = list(int.strategy = \"eb\"),   control.predictor = list(A = inla.stack.A(stk.dat.3), compute = TRUE) ) summary(rspde_fit_order_3_brasil) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.15, Running = 2.98, Post = 0.0315, Total = 6.16  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant  mode kld ## Intercept 1.945 0.055      1.837    1.945      2.054 1.945   0 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field CGeneric ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.231    0.848     11.590 ## Precision for seaDist                          9284.074 6556.235   2595.428 ## Theta1 for field                                 -1.488    0.111     -1.737 ## Theta2 for field                                 -0.121    0.241     -0.643 ## Theta3 for field                                  0.072    0.992     -1.598 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.223     14.929   13.241 ## Precision for seaDist                          7495.658  26737.313 5182.791 ## Theta1 for field                                 -1.482     -1.299   -1.442 ## Theta2 for field                                 -0.111      0.319   -0.052 ## Theta3 for field                                  0.041      2.327   -0.346 ##  ## Marginal log-Likelihood:  -1260.69  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"inlabru implementation of the rational SPDE approach","text":"vignette present inlabru implementation covariance-based rational SPDE approach. technical details covariance-based approach, see Rational approximation rSPDE package vignette Xiong, Simas, Bolin (2022). begin providing step--step illustration use implementation. end consider real world data set consists precipitation measurements Paraná region Brazil. initial model fitting, show change parameters model. end, also provide example replicates. examples vignette R-INLA implementation rational SPDE approach vignette. case, important mention one can improve performance using PARDISO solver. Please, go https://www.pardiso-project.org/r-inla/#license apply license. Also, use inla.pardiso() instructions enable PARDISO sparse library.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"an-example-with-real-data","dir":"Articles","previous_headings":"","what":"An example with real data","title":"inlabru implementation of the rational SPDE approach","text":"illustrate implementation rSPDE inlabru consider dataset available R-INLA. data also used illustrate SPDE approach, see instance book Advanced Spatial Modeling Stochastic Partial Differential Equations Using R INLA also vignette Spatial Statistics using R-INLA Gaussian Markov random fields. See also Lindgren, Rue, Lindström (2011) theoretical details standard SPDE approach. data consist precipitation measurements Paraná region Brazil provided Brazilian National Water Agency. data collected 616 gauge stations Paraná state, south Brazil, day 2011.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"an-rspde-model-for-precipitation","dir":"Articles","previous_headings":"An example with real data","what":"An rSPDE model for precipitation","title":"inlabru implementation of the rational SPDE approach","text":"follow vignette Spatial Statistics using R-INLA Gaussian Markov random fields. precipitation data always positive, assume Gamma distributed. R-INLA uses following parameterization Gamma distribution, \\[\\Gamma(\\mu, \\phi): \\pi (y) = \\frac{1}{\\Gamma(\\phi)} \\left(\\frac{\\phi}{\\mu}\\right)^{\\phi} y^{\\phi - 1} \\exp\\left(-\\frac{\\phi y}{\\mu}\\right) .\\] parameterization, distribution expected value \\(E(x) = \\mu\\) variance \\(V(x) = \\mu^2/\\phi\\), \\(1/\\phi\\) dispersion parameter. example \\(\\mu\\) modelled using stochastic model includes covariates spatial structure, resulting latent Gaussian model precipitation measurements \\[\\begin{align} y_i\\mid \\mu(s_i), \\theta &\\sim \\Gamma(\\mu(s_i),c\\phi)\\\\ \\log (\\mu(s)) &= \\eta(s) = \\sum_k f_k(c_k(s))+u(s)\\\\ \\theta &\\sim \\pi(\\theta) \\end{align},\\] \\(y_i\\) denotes measurement taken location \\(s_i\\), \\(c_k(s)\\) covariates, \\(u(s)\\) mean-zero Gaussian Matérn field, \\(\\theta\\) vector containing parameters model, including smoothness field. , using rSPDE model also able estimate smoothness latent field.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"examining-the-data","dir":"Articles","previous_headings":"An example with real data","what":"Examining the data","title":"inlabru implementation of the rational SPDE approach","text":"using inlabru. inlabru package available CRAN also GitHub. begin loading libraries need get data build plots. Let us load data border region data frame contains daily measurements 616 stations year 2011, well coordinates altitude information measurement stations. analyze full spatio-temporal data set, instead look total precipitation January, calculate next snippet code, extract coordinates altitudes remove locations missing values. Let us build plot precipitations:  red line figure shows coast line, expect distance coast good covariate precipitation. covariate available, let us calculate observation location: Now, let us plot precipitation function possible covariates:","code":"library(ggplot2) library(INLA) library(inlabru) library(splancs) library(viridis) data(PRprec) data(PRborder) Y <- rowMeans(PRprec[, 3 + 1:31]) ind <- !is.na(Y) Y <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) alt <- PRprec$Altitude[ind] ggplot() +   geom_point(aes(     x = coords[, 1], y = coords[, 2],     colour = Y   ), size = 2, alpha = 1) +   geom_path(aes(x = PRborder[, 1], y = PRborder[, 2])) +   geom_path(aes(x = PRborder[1034:1078, 1], y = PRborder[     1034:1078,     2   ]), colour = \"red\") +    scale_color_viridis() seaDist <- apply(spDists(coords, PRborder[1034:1078, ],   longlat = TRUE ), 1, min) par(mfrow = c(2, 2)) plot(coords[, 1], Y, cex = 0.5, xlab = \"Longitude\") plot(coords[, 2], Y, cex = 0.5, xlab = \"Latitude\") plot(seaDist, Y, cex = 0.5, xlab = \"Distance to sea\") plot(alt, Y, cex = 0.5, xlab = \"Altitude\") par(mfrow = c(1, 1))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"creating-the-rspde-model","dir":"Articles","previous_headings":"An example with real data","what":"Creating the rSPDE model","title":"inlabru implementation of the rational SPDE approach","text":"use inlabru implementation rSPDE model need load functions: create rSPDE model, one rspde.matern() function similar fashion one use inla.spde2.matern() function.","code":"library(rSPDE)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"mesh","dir":"Articles","previous_headings":"An example with real data > Creating the rSPDE model","what":"Mesh","title":"inlabru implementation of the rational SPDE approach","text":"can use R-INLA creating mesh. Let us create mesh based non-convex hull avoid adding many small triangles outside domain interest:","code":"prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2) plot(prmesh, asp = 1, main = \"\") lines(PRborder, col = 3) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"setting-up-the-data-frame","dir":"Articles","previous_headings":"An example with real data > Creating the rSPDE model","what":"Setting up the data frame","title":"inlabru implementation of the rational SPDE approach","text":"place inla.stack, can set data.frame() use inlabru. refer reader vignettes https://inlabru-org.github.io/inlabru/index.html details.","code":"prdata <- data.frame(long = coords[,1], lat = coords[,2],                          seaDist = inla.group(seaDist), y = Y) coordinates(prdata) <- c(\"long\",\"lat\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"setting-up-the-rspde-model","dir":"Articles","previous_headings":"An example with real data > Creating the rSPDE model","what":"Setting up the rSPDE model","title":"inlabru implementation of the rational SPDE approach","text":"set rSPDEmodel, need mesh. default assume want estimate smoothness parameter \\(\\nu\\) covariance-based rational approximation order 2. Later vignette also see options setting rSPDE models keeping smoothness parameter fixed /increasing order covariance-based rational approximation. Therefore, set model use rspde.matern() function: Notice function reminiscent R-INLA’s inla.spde2.matern() function. assume following linkage model components observations \\[\\eta(s) \\sim x(s) + \\text{ Intercept} + \\text{seaDist}.\\] \\(\\eta(s)\\) used observation-likelihood, \\[y_i\\mid \\eta(s_i),\\theta \\sim \\Gamma(\\exp(\\eta (s_i)), c\\phi).\\]","code":"rspde_model <- rspde.matern(mesh = prmesh)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"model-fitting","dir":"Articles","previous_headings":"An example with real data","what":"Model fitting","title":"inlabru implementation of the rational SPDE approach","text":"build model using distance sea \\(x_i\\) covariate improper CAR(1) model \\(\\beta_{ij}=1(\\sim j)\\), R-INLA calls random walk order 1. fit inlabru’s style: fit model simply use bru() function:","code":"cmp <- y ~ Intercept(1) + distSea(seaDist, model=\"rw1\") + field(coordinates, model = rspde_model) rspde_fit <- bru(cmp, data = prdata,   family = \"Gamma\",   options = list(     control.inla = list(int.strategy = \"eb\"),     verbose = FALSE) )"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"inlabru-results","dir":"Articles","previous_headings":"An example with real data","what":"inlabru results","title":"inlabru implementation of the rational SPDE approach","text":"can look summaries posterior distributions parameters, example fixed effects (.e. intercept) hyper-parameters (.e. dispersion gamma likelihood, precision RW1, parameters spatial field): Let \\(\\theta_1 = \\textrm{Theta1}\\), \\(\\theta_2=\\textrm{Theta2}\\) \\(\\theta_3=\\textrm{Theta3}\\). terms SPDE \\[(\\kappa^2 - \\Delta)^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(\\alpha = \\nu + d/2\\), \\[\\tau = \\exp(\\theta_1),\\quad \\kappa = \\exp(\\theta_2), \\] default \\[\\nu = 4\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] number 4 comes upper bound \\(\\nu\\), discussed R-INLA implementation rational SPDE approach vignette. general, \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big),\\] \\(\\nu_{UB}\\) value upper bound smoothness parameter \\(\\nu\\). Another choice prior \\(\\nu\\) truncated lognormal distribution also discussed R-INLA implementation rational SPDE approach vignette.","code":"summary(rspde_fit) ## inlabru version: 2.7.0 ## INLA version: 23.02.04 ## Components: ## Intercept: main = linear(1) ## distSea: main = rw1(seaDist) ## field: main = cgeneric(coordinates) ## Likelihoods: ##   Family: 'Gamma' ##     Data class: 'SpatialPointsDataFrame' ##     Predictor: y ~ . ## Time used: ##     Pre = 3.47, Running = 10.1, Post = 0.047, Total = 13.7  ## Fixed effects: ##           mean    sd 0.025quant 0.5quant 0.975quant mode kld ## Intercept 1.92 0.602       0.74     1.92        3.1 1.92   0 ##  ## Random effects: ##   Name     Model ##     distSea RW1 model ##    field CGeneric ##  ## Model hyperparameters: ##                                                     mean       sd 0.025quant ## Precision parameter for the Gamma observations    13.548    0.800     12.054 ## Precision for distSea                          18587.773 9023.659   5598.663 ## Theta1 for field                                  -0.847    0.076     -0.985 ## Theta2 for field                                   1.932    0.420      0.992 ## Theta3 for field                                  -3.341    0.371     -4.210 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations    13.52     15.212    13.45 ## Precision for distSea                          16896.49  41039.404 13638.05 ## Theta1 for field                                  -0.85     -0.681    -0.87 ## Theta2 for field                                   1.94      2.707     2.01 ## Theta3 for field                                  -3.40     -2.555    -3.25 ##  ## Deviance Information Criterion (DIC) ...............: 2497.82 ## Deviance Information Criterion (DIC, saturated) ....: 704.82 ## Effective number of parameters .....................: 89.46 ##  ## Watanabe-Akaike information criterion (WAIC) ...: 2498.63 ## Effective number of parameters .................: 79.37 ##  ## Marginal log-Likelihood:  -1257.28  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"inlabru-results-in-the-original-scale","dir":"Articles","previous_headings":"An example with real data","what":"inlabru results in the original scale","title":"inlabru implementation of the rational SPDE approach","text":"can obtain outputs respect parameters original scale using function rspde.result(): can also plot posterior densities. end use gg_df() function, creates ggplot2 user-friendly data frames:","code":"result_fit <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result_fit) ##             mean        sd 0.025quant 0.5quant 0.975quant     mode ## std.dev 0.429693 0.0329686   0.374796 0.426004   0.503355 0.416509 ## range   7.508820 3.0769100   2.887320 7.065200  14.763300 6.203980 ## nu      0.145075 0.0494758   0.063158 0.140520   0.254438 0.132142 posterior_df_fit <- gg_df(result_fit)  ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) +  facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"predictions","dir":"Articles","previous_headings":"An example with real data","what":"Predictions","title":"inlabru implementation of the rational SPDE approach","text":"Let us now obtain predictions (.e. kriging) expected precipitation dense grid region. begin creating grid want predictions. end, can use inla.mesh.projector() function: lattice contains 150 × 100 locations. One can easily change resolution kriging prediction changing nxy. Let us find cells outside region interest plot estimates . Let us plot locations prediction:  Let us now create data.frame() coordinates: Since using distance sea covariate, also calculate covariate prediction locations. Finally, add prediction location prediction data.frame(), namely, coord.prd.df: Let us now build data frame results: Finally, plot results. First predicted mean:  , std. deviations:","code":"nxy <- c(150, 100) projgrid <- inla.mesh.projector(prmesh,   xlim = range(PRborder[, 1]),   ylim = range(PRborder[, 2]), dims = nxy ) xy.in <- inout(projgrid$lattice$loc, cbind(PRborder[, 1], PRborder[, 2])) coord.prd <- projgrid$lattice$loc[xy.in, ] plot(coord.prd, type = \"p\", cex = 0.1) lines(PRborder) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\") coord.prd.df <- data.frame(x1 = coord.prd[,1],                             x2 = coord.prd[,2]) coordinates(coord.prd.df) <- c(\"x1\", \"x2\") seaDist.prd <- apply(spDists(coord.prd,   PRborder[1034:1078, ],   longlat = TRUE ), 1, min) coord.prd.df$seaDist <- seaDist.prd pred_obs <- predict(rspde_fit, coord.prd.df,          ~exp(Intercept + field + distSea)) pred_df <- pred_obs@data pred_df <- cbind(pred_df, pred_obs@coords) ggplot(pred_df, aes(x = x1, y = x2, fill = mean)) +   geom_raster() +   scale_fill_viridis() ggplot(pred_df, aes(x = x1, y = x2, fill = sd)) +   geom_raster() + scale_fill_viridis()"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"an-example-with-replicates","dir":"Articles","previous_headings":"","what":"An example with replicates","title":"inlabru implementation of the rational SPDE approach","text":"example simulate data replicates. use example considered Rational approximation rSPDE package vignette (difference way data organized). also refer reader vignette description function matern.operators(), along methods (instance, simulate() method).","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"simulating-the-data","dir":"Articles","previous_headings":"An example with replicates","what":"Simulating the data","title":"inlabru implementation of the rational SPDE approach","text":"Let us consider simple Gaussian linear model 30 independent replicates latent spatial field \\(x(\\mathbf{s})\\), observed \\(m\\) locations, \\(\\{\\mathbf{s}_1 , \\ldots , \\mathbf{s}_m \\}\\), replicate. \\(= 1,\\ldots,m,\\) \\[\\begin{align} y_i &= x_1(\\mathbf{s}_i)+\\varepsilon_i,\\\\ \\vdots &= \\vdots\\\\  y_{+29m} &= x_{30}(\\mathbf{s}_i) + \\varepsilon_{+29m}, \\end{align}\\] \\(\\varepsilon_1,\\ldots,\\varepsilon_{30m}\\) iid normally distributed mean 0 standard deviation 0.1. use basis function representation \\(x(\\cdot)\\) define \\(\\) matrix linking point locations mesh. also need account fact 30 replicates locations. end, \\(\\) matrix need can generated inla.spde.make.() function. reason sampling \\(x(\\cdot)\\) directly latent vector described introduction Rational approximation rSPDE package vignette. begin creating mesh:  compute \\(\\) matrix, needed simulation, connects observation locations mesh: Notice simulated data, use \\(\\) matrix inla.spde.make.() function. now simulate latent process standard deviation \\(\\sigma=1\\) range \\(0.1\\). use \\(\\nu=0.5\\) model exponential covariance function. end create model object matern.operators() function: details function can found Rational approximation rSPDE package vignette. simulate latent process need use simulate() method operator_information object. obtain simulated data \\(y\\) connecting \\(\\) matrix adding gaussian noise. first replicate simulated random field well observation locations shown following figure.","code":"m <- 200 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   offset = c(0.1, 0.4),   max.edge = c(0.05, 0.5) ) plot(mesh_2d, main = \"\") points(loc_2d_mesh[, 1], loc_2d_mesh[, 2]) n.rep <- 30 A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh,   index = rep(1:m, times = n.rep),   repl = rep(1:n.rep, each = m) ) nu <- 0.5 sigma <- 1 range <- 0.1 kappa <- sqrt(8 * nu) / range tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi) * gamma(nu + 1))) d <- 2 operator_information <- matern.operators(   mesh = mesh_2d,   nu = nu,   kappa = kappa,   sigma = sigma,   m = 2 ) set.seed(1) u <- simulate(operator_information, nsim = n.rep) y <- as.vector(A %*% as.vector(u)) +   rnorm(m * n.rep) * 0.1 proj <- inla.mesh.projector(mesh_2d, dims = c(100, 100))  df_field <- data.frame(x = proj$lattice$loc[,1],                         y = proj$lattice$loc[,2],                         field = as.vector(inla.mesh.project(proj,                          field = as.vector(u[, 1]))),                         type = \"field\")  df_loc <- data.frame(x = loc_2d_mesh[, 1],                       y = loc_2d_mesh[, 2],                       field = y[1:m],                       type = \"locations\") df_plot <- rbind(df_field, df_loc)  ggplot(df_plot) + aes(x = x, y = y, fill = field) +         facet_wrap(~type) + xlim(0,1) + ylim(0,1) +          geom_raster(data = df_field) +         geom_point(data = df_loc, aes(colour = field),         show.legend = FALSE) +          scale_fill_viridis() + scale_colour_viridis()"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"fitting-the-inlabru-rspde-model","dir":"Articles","previous_headings":"An example with replicates","what":"Fitting the inlabru rSPDE model","title":"inlabru implementation of the rational SPDE approach","text":"Let us use rational SPDE approach fit data. begin creating model object. Let us now create data.frame() vector replicates indexes: Let us create component fit. extremely important forget replicate fitting model bru() function. produce warning might fit meaningless model. can get summary: summary user’s scale:","code":"rspde_model.rep <- rspde.matern(mesh = mesh_2d,           parameterization = \"spde\") rep.df <- data.frame(y = y, x1 = rep(loc_2d_mesh[,1], n.rep),                       x2 = rep(loc_2d_mesh[,2], n.rep)) coordinates(rep.df) <- c(\"x1\", \"x2\") repl <- rep(1:n.rep, each=m) cmp.rep <-   y ~ -1 + field(coordinates,     model = rspde_model.rep,     replicate = repl   )   rspde_fit.rep <-   bru(cmp.rep,     data = rep.df,     family = \"gaussian\"   ) summary(rspde_fit.rep) ## inlabru version: 2.7.0 ## INLA version: 23.02.04 ## Components: ## field: main = cgeneric(coordinates), replicate = iid(repl) ## Likelihoods: ##   Family: 'gaussian' ##     Data class: 'SpatialPointsDataFrame' ##     Predictor: y ~ . ## Time used: ##     Pre = 3.43, Running = 36.8, Post = 5.24, Total = 45.5  ## Random effects: ##   Name     Model ##     field CGeneric ##  ## Model hyperparameters: ##                                          mean    sd 0.025quant 0.5quant ## Precision for the Gaussian observations 94.33 0.861      92.43    94.36 ## Theta1 for field                        -2.93 0.050      -3.10    -2.86 ## Theta2 for field                         3.10 0.011       3.07     3.09 ## Theta3 for field                        -1.69 0.023      -1.77    -1.72 ##                                         0.975quant  mode ## Precision for the Gaussian observations      96.24 94.28 ## Theta1 for field                             -2.74 -2.93 ## Theta2 for field                              3.14  3.10 ## Theta3 for field                             -1.61 -1.69 ##  ## Deviance Information Criterion (DIC) ...............: -5763.06 ## Deviance Information Criterion (DIC, saturated) ....: 10566.09 ## Effective number of parameters .....................: 4574.27 ##  ## Watanabe-Akaike information criterion (WAIC) ...: -6702.79 ## Effective number of parameters .................: 2672.89 ##  ## Marginal log-Likelihood:  -4326.95  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit_rep <- rspde.result(rspde_fit.rep, \"field\", rspde_model.rep) summary(result_fit_rep) ##             mean         sd 0.025quant   0.5quant 0.975quant       mode ## tau    0.0536797 0.00267034  0.0486705  0.0535835  0.0591918  0.0534945 ## kappa 22.3107000 0.24266000 21.8322000 22.3114000 22.7851000 22.3169000 ## nu     0.6232490 0.01193170  0.5997970  0.6232390  0.6467090  0.6230360 result_df <- data.frame(   parameter = c(\"tau\", \"kappa\", \"nu\"),   true = c(tau, kappa, nu),   mean = c(     result_fit_rep$summary.tau$mean,     result_fit_rep$summary.kappa$mean,     result_fit_rep$summary.nu$mean   ),   mode = c(     result_fit_rep$summary.tau$mode,     result_fit_rep$summary.kappa$mode,     result_fit_rep$summary.nu$mode   ) ) print(result_df) ##   parameter        true        mean        mode ## 1       tau  0.08920621  0.05367965  0.05349447 ## 2     kappa 20.00000000 22.31069415 22.31694409 ## 3        nu  0.50000000  0.62324918  0.62303616"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"an-example-with-a-non-stationary-model","dir":"Articles","previous_headings":"","what":"An example with a non-stationary model","title":"inlabru implementation of the rational SPDE approach","text":"goal now show one can fit model non-stationary \\(\\sigma\\) (std. deviation) non-stationary \\(\\rho\\) (range parameter). One can also use parameterization terms non-stationary SPDE parameters \\(\\kappa\\) \\(\\tau\\). example consider simulated data.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"simulating-the-data-1","dir":"Articles","previous_headings":"An example with a non-stationary model","what":"Simulating the data","title":"inlabru implementation of the rational SPDE approach","text":"Let us consider simple Gaussian linear model latent spatial field \\(x(\\mathbf{s})\\), defined rectangle \\((0,10) \\times (0,5)\\), std. deviation range parameter satisfy following log-linear regressions: \\[\\begin{align} \\log(\\sigma(\\mathbf{s})) &= \\theta_1 + \\theta_3 b(\\mathbf{s}),\\\\ \\log(\\rho(\\mathbf{s})) &= \\theta_2 + \\theta_3 b(\\mathbf{s}), \\end{align}\\] \\(b(\\mathbf{s}) = (s_1-5)/10\\). assume data observed \\(m\\) locations, \\(\\{\\mathbf{s}_1 , \\ldots , \\mathbf{s}_m \\}\\). \\(= 1,\\ldots,m,\\) \\[y_i = x_1(\\mathbf{s}_i)+\\varepsilon_i,\\] \\(\\varepsilon_1,\\ldots,\\varepsilon_{m}\\) iid normally distributed mean 0 standard deviation 0.1. begin defining domain creating mesh: follow structure INLA. However, INLA allows one specify B.tau B.kappa matrices, , INLA, one wants parameterize terms range standard deviation one needs manually. provide option directly provide matrices B.sigma B.range. usage matrices B.tau B.kappa identical corresponding ones inla.spde2.matern() function. matrices B.sigma B.range work way, parameterize stardard deviation range, respectively. columns B matrices correspond parameter. first column parameter estimated, constant column. , instance, one wants share parameter sigma range (tau kappa), one simply let corresponding column nonzero B.sigma B.range (B.tau B.kappa). assume \\(\\nu = 0.8\\), \\(\\theta_1 = 0, \\theta_2 = 1\\) \\(\\theta_3=1\\). Let us now build model obtain sample spde.matern.operators() function: Let us now sample data simulate() method: Let us now obtain 600 random locations rectangle compute \\(\\) matrix: can now generate response vector y:","code":"rec_domain <- cbind(c(0, 1, 1, 0, 0) * 10, c(0, 0, 1, 1, 0) * 5)  mesh <- inla.mesh.2d(loc.domain = rec_domain, cutoff = 0.1,    max.edge = c(0.5, 1.5), offset = c(0.5, 1.5)) nu <- 0.8 true_theta <- c(0,1, 1) B.sigma = cbind(0, 1, 0, (mesh$loc[,1] - 5) / 10) B.range = cbind(0, 0, 1, (mesh$loc[,1] - 5) / 10)  # SPDE model op_cov_ns <- spde.matern.operators(mesh = mesh,    theta = true_theta,   nu = nu,   B.sigma = B.sigma,    B.range = B.range, m = 2) u <- as.vector(simulate(op_cov_ns, seed = 123)) m <- 600 loc_mesh <- cbind(runif(m) * 10, runif(m) * 5)  A <- inla.spde.make.A(   mesh = mesh,   loc = loc_mesh ) y <- as.vector(A %*% as.vector(u)) + rnorm(m) * 0.1"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"fitting-the-inlabru-rspde-model-1","dir":"Articles","previous_headings":"An example with a non-stationary model","what":"Fitting the inlabru rSPDE model","title":"inlabru implementation of the rational SPDE approach","text":"Let us use rational SPDE approach fit data. begin creating model object. creating new one start estimation true values. Let us now create data.frame() vector replicates indexes: Let us create component fit. extremely important forget replicate fitting model bru() function. produce warning might fit meaningless model. can get summary: can obtain outputs respect parameters original scale using function rspde.result(): Let us compare mean true values parameters: can also plot posterior densities. end use gg_df() function, creates ggplot2 user-friendly data frames:","code":"rspde_model_nonstat <- rspde.matern(mesh = mesh,   B.sigma = B.sigma,   B.range = B.range) nonstat_df <- data.frame(y = y, x1 = loc_mesh[,1],                       x2 = loc_mesh[,2]) coordinates(nonstat_df) <- c(\"x1\", \"x2\") cmp_nonstat <-   y ~ -1 + field(coordinates,     model = rspde_model_nonstat   )   rspde_fit_nonstat <-   bru(cmp_nonstat,     data = nonstat_df,     family = \"gaussian\",     options = list(verbose = FALSE)   ) summary(rspde_fit_nonstat) ## inlabru version: 2.7.0 ## INLA version: 23.02.04 ## Components: ## field: main = cgeneric(coordinates) ## Likelihoods: ##   Family: 'gaussian' ##     Data class: 'SpatialPointsDataFrame' ##     Predictor: y ~ . ## Time used: ##     Pre = 3.21, Running = 18.4, Post = 0.256, Total = 21.8  ## Random effects: ##   Name     Model ##     field CGeneric ##  ## Model hyperparameters: ##                                           mean     sd 0.025quant 0.5quant ## Precision for the Gaussian observations 98.004 10.172     78.866   97.730 ## Theta1 for field                        -0.239  0.171     -0.565   -0.244 ## Theta2 for field                         1.135  0.220      0.714    1.131 ## Theta3 for field                         0.556  0.284      0.007    0.552 ## Theta4 for field                        -1.590  0.217     -2.001   -1.596 ##                                         0.975quant   mode ## Precision for the Gaussian observations     118.88 97.588 ## Theta1 for field                              0.11 -0.262 ## Theta2 for field                              1.58  1.114 ## Theta3 for field                              1.13  0.536 ## Theta4 for field                             -1.15 -1.619 ##  ## Deviance Information Criterion (DIC) ...............: -711.30 ## Deviance Information Criterion (DIC, saturated) ....: 939.63 ## Effective number of parameters .....................: 335.97 ##  ## Watanabe-Akaike information criterion (WAIC) ...: -732.70 ## Effective number of parameters .................: 237.91 ##  ## Marginal log-Likelihood:  -3.25  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit_nonstat <- rspde.result(rspde_fit_nonstat, \"field\", rspde_model_nonstat) summary(result_fit_nonstat) ##                    mean       sd  0.025quant  0.5quant 0.975quant      mode ## Theta1.matern -0.239366 0.171453 -0.56491500 -0.244020   0.110219 -0.261687 ## Theta2.matern  1.135230 0.219698  0.71383100  1.130810   1.579160  1.114200 ## Theta3.matern  0.556111 0.284074  0.00704698  0.551867   1.126790  0.535840 ## nu             0.686203 0.123354  0.47825800  0.673854   0.960619  0.645930 summ_res_nonstat <- summary(result_fit_nonstat) result_df <- data.frame(   parameter = result_fit_nonstat$params,   true = c(true_theta, nu),   mean = summ_res_nonstat[,1],   mode = summ_res_nonstat[,6] ) print(result_df) ##       parameter true      mean      mode ## 1 Theta1.matern  0.0 -0.239366 -0.261687 ## 2 Theta2.matern  1.0  1.135230  1.114200 ## 3 Theta3.matern  1.0  0.556111  0.535840 ## 4            nu  0.8  0.686203  0.645930 posterior_df_fit <- gg_df(result_fit_nonstat)  ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) +  facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inlabru.html","id":"further-options-of-the-inlabru-implementation","dir":"Articles","previous_headings":"","what":"Further options of the inlabru implementation","title":"inlabru implementation of the rational SPDE approach","text":"several additional options available. instance, possible change order rational approximation, upper bound smoothness parameter (may speed fit), change priors, change type rational approximation, among others. options described “options rSPDE-INLA implementation” section R-INLA implementation rational SPDE approach vignette. Observe options passed model rspde.matern() function, therefore resulting model object can directly used bru() function, identical manner examples .","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Bolin. Maintainer, author. Alexandre Simas. Author. Finn Lindgren. Contributor.","code":""},{"path":"https://davidbolin.github.io/rSPDE/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Bolin D, Simas (2023). rSPDE: Rational Approximations Fractional Stochastic Partial Differential Equations. R package version 2.2.0, https://CRAN.R-project.org/package=rSPDE. Xiong Z, Simas , Bolin D (2022). “Covariance-based rational approximations fractional SPDEs computationally efficient Bayesian inference.” arXiv preprint arXiv:2209.04670. doi:10.48550/arXiv.2209.04670. David Bolin, Kristin Kirchner (2020), rational SPDE approach Gaussian random fields general smoothness Journal Computational Graphical Statistics, 29:2, 274-285.","code":"@Manual{,   title = {rSPDE: Rational Approximations of Fractional Stochastic Partial Differential Equations},   author = {David Bolin and Alexandre B. Simas},   year = {2023},   note = {R package version 2.2.0},   url = {https://CRAN.R-project.org/package=rSPDE}, } @Article{,   title = {Covariance-based rational approximations of fractional SPDEs for computationally efficient Bayesian inference},   author = {Zhen Xiong and Alexandre B. Simas and David Bolin},   journal = {arXiv preprint arXiv:2209.04670},   year = {2022},   doi = {10.48550/arXiv.2209.04670}, } @Article{,   title = {The rational {SPDE} approach for {Gaussian} random fields with general smoothness},   author = {David Bolin and Kristin Kirchner},   journal = {Journal of Computational and Graphical Statistics},   year = {2020},   volume = {29},   number = {2},   pages = {274--285},   doi = {10.1080/10618600.2019.1665537}, }"},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"the-rspde-package-","dir":"","previous_headings":"","what":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"rSPDE R package used computing rational approximations fractional SPDEs. rational approximations can used computatially efficient statistical inference. Basic statistical operations likelihood evaluations kriging predictions using fractional approximations also implemented. package also contains interface R-INLA.","code":""},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"Several popular Gaussian random field models can represented solutions stochastic partial differential equations (SPDEs) form \\[ L^{\\beta}(\\tau u) = \\mathcal{W}. \\] \\(\\mathcal{W}\\) Gaussian white noise, \\(L\\) second-order differential operator, fractional power \\(\\beta>0\\) determines smoothness \\(u\\), \\(\\tau>0\\) scales variance \\(u\\). simplest example model \\(\\mathbb {R}^d\\) \\(L = \\kappa^2 - \\Delta\\), results Gaussian random field \\(u\\) Matérn covariance function \\[ C(h) = \\dfrac{ \\sigma^2 }{ 2 ^ {\\nu-1} \\Gamma (\\nu)} (\\kappa h) ^ {\\nu} K_{\\nu} (\\kappa h). \\] \\(2 \\beta\\) integer domain \\(\\mathcal {D}\\) model defined bounded, \\(u\\) can approximated Gaussian Markov random field (GMRF) \\(\\mathbf { \\mathrm{u} }\\) via finite element method (FEM) SPDE. Specifically, approximation can written \\[ u_h (s) = \\sum _ { =1 } ^ n u_i \\varphi_i (s). \\] \\(\\{\\varphi_i\\}\\) piecewise linear basis functions defined triangulation \\(\\mathcal {D}\\) vector weights \\( \\mathbf { \\mathrm { u } } = (u_1,\\ldots,u_n)^\\top \\) normally distributed, \\(N(\\mathbf { \\mathrm{u} }, \\tilde{ \\mathbf { \\mathrm{Q} } }^{-1})\\), \\(\\tilde{ \\mathbf{ \\mathrm{Q} } }\\) sparse. See explicit link Gaussian fields Gaussian Markov random fields: stochastic partial differential equation approach details. rSPDE package provides corresponding computationally efficient approximations case \\(\\beta\\) general fractional power. main idea combine FEM approximation rational approximation fractional operator. result, one can easily inference prediction using fractional SPDE models \\[ ( \\kappa^2-\\Delta )^\\beta u = \\mathcal{ W }. \\] particular, allows bayesian inference model parameters, including fractional parameter \\(\\beta\\). illustration purposes, package contains simple FEM implementation models R. See introduction rSPDE package vignette introduction package. Rational approximation rSPDE package Operator-based rational approximation vignettes provide introductions create fit rSPDE models. introduction R-INLA implementation rSPDE models see R-INLA implementation rational SPDE approach. rSPDE documentation contains descriptions examples functions rSPDE package.","code":""},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"installation-instructions","dir":"","previous_headings":"","what":"Installation instructions","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"latest CRAN release package can installed directly CRAN install.packages(\"rSPDE\"). latest stable version (sometimes slightly recent CRAN version), can installed using command R. development version can installed using command want install package using remotes::install_github-method Windows, first need install Rtools add paths Rtools gcc Windows PATH environment variable. can done current R session using commands variables rtools gcc need changed Rtools installed directly C:, gcc’s version might need changed depending version Rtools.","code":"remotes::install_github(\"davidbolin/rspde\", ref = \"stable\") remotes::install_github(\"davidbolin/rspde\", ref = \"devel\") rtools = \"C:\\\\Rtools\\\\bin\" gcc = \"C:\\\\Rtools\\\\gcc-4.6.3\\\\bin\" Sys.setenv(PATH = paste(c(gcc, rtools, Sys.getenv(\"PATH\")), collapse = \";\"))"},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"example-with-rspde---inla","dir":"","previous_headings":"","what":"Example with rSPDE - INLA","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"illustrate rSPDE package kriging example using R-INLA interface rSPDE. data consist precipitation measurements Paraná region Brazil provided Brazilian National Water Agency. data collected 616 gauge stations Paraná state, south Brazil, day 2011. analyse full spatio-temporal data set, instead look total precipitation January details dataset commands refer reader rSPDE-INLA Vignette.     , std. deviations:","code":"library(rSPDE) library(ggplot2) library(INLA) library(splancs)  #Load the data data(PRprec) data(PRborder)  #Get the precipitation in January Y <- rowMeans(PRprec[, 3 + 1:31])  #Treat the data and plot ind <- !is.na(Y) Y <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) alt <- PRprec$Altitude[ind]  ggplot() +   geom_point(aes(     x = coords[, 1], y = coords[, 2],     colour = Y   ), size = 2, alpha = 1) +   geom_path(aes(x = PRborder[, 1], y = PRborder[, 2])) +   geom_path(aes(x = PRborder[1034:1078, 1], y = PRborder[     1034:1078,     2   ]), colour = \"red\") +    scale_color_viridis() #Get distance from the sea seaDist <- apply(spDists(coords, PRborder[1034:1078, ], longlat = TRUE), 1,                   min)                   #Create the mesh prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2) plot(prmesh, asp = 1, main = \"\") lines(PRborder, col = 3) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\") #Create the observation matrix Abar <- rspde.make.A(mesh = prmesh, loc = coords)  #Create the rspde model object rspde_model <- rspde.matern(mesh = prmesh)  #Create the index and inla.stack object mesh.index <- rspde.make.index(name = \"field\", mesh = prmesh) stk.dat <- inla.stack(   data = list(y = Y), A = list(Abar, 1), tag = \"est\",    effects = list(c(mesh.index),                   list(long = inla.group(coords[, 1]),                        lat = inla.group(coords[,2]),                       seaDist = inla.group(seaDist),                       Intercept = 1)))                        #Create the formula object and fit the model f.s <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +    f(field, model = rspde_model)     rspde_fit <- inla(f.s, family = \"Gamma\", data = inla.stack.data(stk.dat),              verbose = FALSE,              control.inla=list(int.strategy='eb'),             control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE))              summary(rspde_fit) #> #>  #>  #> Call: #>    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  #>    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  #>    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  #>    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  #>    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  #>    = control.compute, \", \" control.predictor = control.predictor,  #>    control.family = control.family, \", \" control.inla = control.inla,  #>    control.fixed = control.fixed, \", \" control.mode = control.mode,  #>    control.expert = control.expert, \", \" control.hazard = control.hazard,  #>    control.lincomb = control.lincomb, \", \" control.update =  #>    control.update, control.lp.scale = control.lp.scale, \", \"  #>    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  #>    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  #>    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  #>    working.directory = working.directory, \", \" silent = silent, inla.mode  #>    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  #>    .parent.frame)\")  #> Time used: #>     Pre = 3.99, Running = 33.5, Post = 0.134, Total = 37.6  #> Fixed effects: #>            mean    sd 0.025quant 0.5quant 0.975quant  mode kld #> Intercept 0.642 0.036      0.571    0.642      0.712 0.642   0 #>  #> Random effects: #>   Name     Model #>     seaDist RW1 model #>    field CGeneric #>  #> Model hyperparameters: #>                                                     mean       sd 0.025quant #> Precision parameter for the Gamma observations    13.386    0.899     11.717 #> Precision for seaDist                          20934.746 6782.979   8078.653 #> Theta1 for field                                  -0.247    0.037     -0.337 #> Theta2 for field                                   0.581    0.177      0.094 #> Theta3 for field                                  -2.299    0.129     -2.609 #>                                                 0.5quant 0.975quant      mode #> Precision parameter for the Gamma observations    13.350     15.257    13.269 #> Precision for seaDist                          17336.147  47243.069 18259.956 #> Theta1 for field                                  -0.240     -0.155    -0.249 #> Theta2 for field                                   0.515      1.050     0.591 #> Theta3 for field                                  -2.280     -1.985    -2.307 #>  #> Marginal log-Likelihood:  -1261.82  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')  #Get the summary on the user's scale result_fit <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result_fit) #> #>             mean        sd 0.025quant 0.5quant 0.975quant     mode #> std.dev 0.781908 0.0288775   0.728352 0.780797   0.841701 0.778383 #> range   1.815890 0.3195230   1.252690 1.793990   2.504550 1.748340 #> nu      0.367063 0.0429435   0.291565 0.363951   0.460036 0.357430  #Plot the posterior densities posterior_df_fit <- gg_df(result_fit)  ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) +  facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\") #Create a grid to predict nxy <- c(150, 100) projgrid <- rspde.mesh.projector(prmesh, xlim = range(PRborder[, 1]),  ylim = range(PRborder[,2]), dims = nxy) xy.in <- inout(projgrid$lattice$loc, cbind(PRborder[, 1], PRborder[, 2])) coord.prd <- projgrid$lattice$loc[xy.in, ]  #Compute A matrix and seaDist at predict locations and build the stack A.prd <- projgrid$proj$A[xy.in, ] seaDist.prd <- apply(spDists(coord.prd,      PRborder[1034:1078, ], longlat = TRUE), 1, min) ef.prd = list(c(mesh.index),      list(long = inla.group(coord.prd[,      1]), lat = inla.group(coord.prd[, 2]),      seaDist = inla.group(seaDist.prd),     Intercept = 1)) stk.prd <- inla.stack(data = list(y = NA),      A = list(A.prd, 1), tag = \"prd\",      effects = ef.prd) stk.all <- inla.stack(stk.dat, stk.prd)  rspde_fitprd <- inla(f.s, family = \"Gamma\",               data = inla.stack.data(stk.all),               control.predictor = list(A = inla.stack.A(stk.all),              compute = TRUE, link = 1))  id.prd <- inla.stack.index(stk.all, \"prd\")$data sd.prd <- m.prd <- matrix(NA, nxy[1], nxy[2]) m.prd[xy.in] <- rspde_fitprd$summary.fitted.values$mean[id.prd] sd.prd[xy.in] <- rspde_fitprd$summary.fitted.values$sd[id.prd]  #Plot the predictions pred_df <- data.frame(x1 = coord.prd[,1],                       x2 = coord.prd[,2],                       mean = m.prd,                       sd = sd.prd)  ggplot(pred_df, aes(x = x1, y = x2, fill = mean)) +   geom_raster() +   scale_fill_viridis() ggplot(pred_df, aes(x = x1, y = x2, fill = sd)) +   geom_raster() + scale_fill_viridis()"},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"example-with-rspde---inlabru","dir":"","previous_headings":"","what":"Example with rSPDE - inlabru","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"now illustrate rSPDE kriging example inlabru interface rSPDE. make description self-contained, use information codes example . data consist precipitation measurements Paraná region Brazil provided Brazilian National Water Agency. data collected 616 gauge stations Paraná state, south Brazil, day 2011. analyse full spatio-temporal data set, instead look total precipitation January details dataset commands refer reader rSPDE-inlabru Vignette.    Finally, plot results. First predicted mean:  , std. deviations:","code":"library(rSPDE) library(ggplot2) library(INLA) library(inlabru) library(splancs)  #Load the data data(PRprec) data(PRborder)  #Get the precipitation in January Y <- rowMeans(PRprec[, 3 + 1:31])  #Treat the data and plot ind <- !is.na(Y) Y <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) alt <- PRprec$Altitude[ind]  ggplot() +   geom_point(aes(     x = coords[, 1], y = coords[, 2],     colour = Y   ), size = 2, alpha = 1) +   geom_path(aes(x = PRborder[, 1], y = PRborder[, 2])) +   geom_path(aes(x = PRborder[1034:1078, 1], y = PRborder[     1034:1078,     2   ]), colour = \"red\") +    scale_color_viridis() #Get distance from the sea seaDist <- apply(spDists(coords, PRborder[1034:1078, ], longlat = TRUE), 1,                   min)                   #Create the mesh prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2) plot(prmesh, asp = 1, main = \"\") lines(PRborder, col = 3) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\") #Create the rspde model object rspde_model <- rspde.matern(mesh = prmesh)  #Create the data.frame prdata <- data.frame(long = coords[,1], lat = coords[,2],                          seaDist = inla.group(seaDist), y = Y) coordinates(prdata) <- c(\"long\",\"lat\")                        #Create the component  # The following synthax is available for inlabru version 2.5.3.9002 and above: cmp <- y ~ Intercept(1) + distSea(seaDist, model=\"rw1\") + field(coordinates, model = rspde_model)  # For inlabru version 2.5.3 one should use: cmp <- y ~ Intercept(1) + distSea(seaDist, model=\"rw1\") + field(coordinates, model = rspde_model, mapper = bru_mapper(rspde_model))  # Fit the model    rspde_fit <- bru(cmp, family = \"Gamma\",              data = prdata,             options = list(             verbose = FALSE,              control.inla=list(int.strategy='eb'),             control.predictor = list(compute = TRUE)) )              summary(rspde_fit) #> #>  #> inlabru version: 2.6.0 #> INLA version: 22.10.23 #> Components: #>   Intercept: Model types main='linear', group='exchangeable', replicate='iid' #>   distSea: Model types main='rw1', group='exchangeable', replicate='iid' #>   field: Model types main='cgeneric', group='exchangeable', replicate='iid' #> Likelihoods: #>   Family: 'Gamma' #>     Data class: 'SpatialPointsDataFrame' #>     Predictor: y ~ . #> Time used: #>     Pre = 3.99, Running = 48, Post = 0.344, Total = 52.4  #> Fixed effects: #>            mean    sd 0.025quant 0.5quant 0.975quant  mode kld #> Intercept 1.919 0.644      0.657    1.919      3.181 1.919   0 #>  #> Random effects: #>   Name     Model #>     distSea RW1 model #>    field CGeneric #>  #> Model hyperparameters: #>                                                     mean       sd 0.025quant #> Precision parameter for the Gamma observations    13.511 9.13e-01     11.794 #> Precision for distSea                          25694.848 2.19e+04   4340.399 #> Theta1 for field                                  -0.444 8.70e-02     -0.619 #> Theta2 for field                                   2.147 1.07e+00      0.058 #> Theta3 for field                                  -3.466 7.09e-01     -4.898 #>                                                 0.5quant 0.975quant      mode #> Precision parameter for the Gamma observations    13.484     15.389    13.434 #> Precision for distSea                          19581.551  84073.684 11101.416 #> Theta1 for field                                  -0.443     -0.274    -0.439 #> Theta2 for field                                   2.137      4.291     2.098 #> Theta3 for field                                  -3.451     -2.106    -3.398 #>  #> Deviance Information Criterion (DIC) ...............: 2496.60 #> Deviance Information Criterion (DIC, saturated) ....: 4743.70 #> Effective number of parameters .....................: 90.50 #>  #> Watanabe-Akaike information criterion (WAIC) ...: 2498.45 #> Effective number of parameters .................: 81.06 #>  #> Marginal log-Likelihood:  -1258.94  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')   #Get the summary on the user's scale result_fit <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result_fit) #>      #>              mean         sd 0.025quant 0.5quant 0.975quant      mode #> std.dev  0.643757  0.0558954  0.5393440 0.642068   0.758644 0.6393640 #> range   15.214500 21.3076000  1.0785500 8.464680  71.716700 2.7165100 #> nu       0.150098  0.1053520  0.0300533 0.123157   0.429020 0.0766468  #Plot the posterior densities posterior_df_fit <- gg_df(result_fit)  ggplot(posterior_df_fit) + geom_line(aes(x = x, y = y)) +  facet_wrap(~parameter, scales = \"free\") + labs(y = \"Density\") #Create a grid to predict nxy <- c(150, 100) projgrid <- rspde.mesh.projector(prmesh, xlim = range(PRborder[, 1]),  ylim = range(PRborder[,2]), dims = nxy) xy.in <- inout(projgrid$lattice$loc, cbind(PRborder[, 1], PRborder[, 2])) coord.prd <- projgrid$lattice$loc[xy.in, ]  #Compute seaDist at predict locations  seaDist.prd <- apply(spDists(coord.prd,      PRborder[1034:1078, ], longlat = TRUE), 1, min)  # Build the prediction data.frame() coord.prd.df <- data.frame(x1 = coord.prd[,1],                             x2 = coord.prd[,2]) coordinates(coord.prd.df) <- c(\"x1\", \"x2\") coord.prd.df$seaDist <- seaDist.prd  # Obtain prediction at the locations pred_obs <- predict(rspde_fit, coord.prd.df,          ~exp(Intercept + field + distSea))  # Prepare the plotting data.frame() pred_df <- pred_obs@data pred_df <- cbind(pred_df, pred_obs@coords) ggplot(pred_df, aes(x = x1, y = x2, fill = mean)) +   geom_raster() +   scale_fill_viridis() ggplot(pred_df, aes(x = x1, y = x2, fill = sd)) +   geom_raster() + scale_fill_viridis()"},{"path":"https://davidbolin.github.io/rSPDE/reference/bru_get_mapper.inla_rspde.html","id":null,"dir":"Reference","previous_headings":"","what":"rSPDE inlabru mapper — bru_get_mapper.inla_rspde","title":"rSPDE inlabru mapper — bru_get_mapper.inla_rspde","text":"rSPDE inlabru mapper","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/bru_get_mapper.inla_rspde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rSPDE inlabru mapper — bru_get_mapper.inla_rspde","text":"","code":"bru_get_mapper.inla_rspde(model, ...)  ibm_n.bru_mapper_inla_rspde(mapper, ...)  ibm_values.bru_mapper_inla_rspde(mapper, ...)  ibm_jacobian.bru_mapper_inla_rspde(mapper, input, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/bru_get_mapper.inla_rspde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rSPDE inlabru mapper — bru_get_mapper.inla_rspde","text":"model inla_rspde construct extract mapper ... Arguments passed methods mapper bru_mapper_inla_rspde object input values produce mapping matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/bru_get_mapper.inla_rspde.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"rSPDE inlabru mapper — bru_get_mapper.inla_rspde","text":"","code":"#devel version if (requireNamespace(\"INLA\", quietly = TRUE) &&       requireNamespace(\"inlabru\", quietly = TRUE)){ library(INLA) library(inlabru)  set.seed(123) m <- 100 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   max.edge = c(0.1, 0.5) ) sigma <- 1 range <- 0.2 nu <- 0.8 kappa <- sqrt(8 * nu) / range op <- matern.operators(   mesh = mesh_2d, nu = nu,   kappa = kappa, sigma = sigma, m = 2 ) u <- simulate(op) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 y <- A %*% u + rnorm(m) * sigma.e y <- as.vector(y)  data_df <- data.frame(y=y, x1 = loc_2d_mesh[,1],                        x2 = loc_2d_mesh[,2]) coordinates(data_df) <- c(\"x1\", \"x2\") rspde_model <- rspde.matern(   mesh = mesh_2d,   nu_upper_bound = 2 )  cmp <- y ~ Intercept(1) +             field(coordinates, model = rspde_model)   rspde_fit <- bru(cmp, data = data_df) summary(rspde_fit) } #> Loading required package: foreach #> Loading required package: parallel #> Loading required package: sp #> This is INLA_23.02.04 built 2023-02-04 09:25:27 UTC. #>  - See www.r-inla.org/contact-us for how to get help. #>  - To enable PARDISO sparse library; see inla.pardiso() #> Warning: Model 'cgeneric' in section 'latent' is marked as 'experimental'; changes may appear at any time. #>   Use this model with extra care!!! Further warnings are disabled. #> inlabru version: 2.7.0 #> INLA version: 23.02.04 #> Components: #> Intercept: main = linear(1) #> field: main = cgeneric(coordinates) #> Likelihoods: #>   Family: 'gaussian' #>     Data class: 'SpatialPointsDataFrame' #>     Predictor: y ~ . #> Time used: #>     Pre = 3.65, Running = 2.36, Post = 0.358, Total = 6.36  #> Fixed effects: #>            mean   sd 0.025quant 0.5quant 0.975quant  mode kld #> Intercept 0.113 0.18     -0.242    0.111      0.475 0.108   0 #>  #> Random effects: #>   Name\t  Model #>     field CGeneric #>  #> Model hyperparameters: #>                                           mean      sd 0.025quant 0.5quant #> Precision for the Gaussian observations 213.51 115.208      66.79  188.692 #> Theta1 for field                         -0.15   0.083      -0.33   -0.146 #> Theta2 for field                         -1.85   0.218      -2.27   -1.855 #> Theta3 for field                         -1.12   0.629      -2.23   -1.151 #>                                         0.975quant    mode #> Precision for the Gaussian observations    506.938 145.683 #> Theta1 for field                            -0.002  -0.122 #> Theta2 for field                            -1.414  -1.868 #> Theta3 for field                             0.273  -1.352 #>  #> Deviance Information Criterion (DIC) ...............: -147.70 #> Deviance Information Criterion (DIC, saturated) ....: 194.10 #> Effective number of parameters .....................: 91.81 #>  #> Watanabe-Akaike information criterion (WAIC) ...: -165.61 #> Effective number of parameters .................: 55.22 #>  #> Marginal log-Likelihood:  -107.09  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') #>  #devel.tag"},{"path":"https://davidbolin.github.io/rSPDE/reference/construct.spde.matern.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor of Matern loglikelihood functions for non-stationary models. — construct.spde.matern.loglike","title":"Constructor of Matern loglikelihood functions for non-stationary models. — construct.spde.matern.loglike","text":"function evaluates log-likelihood function observations non-stationary Gaussian process defined solution SPDE $$(\\kappa(s) - \\Delta)^\\beta (\\tau(s)u(s)) = W.$$ observations assumed generated \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables. latent model approximated using rational approximation fractional SPDE model.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/construct.spde.matern.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor of Matern loglikelihood functions for non-stationary models. — construct.spde.matern.loglike","text":"","code":"construct.spde.matern.loglike(   object,   Y,   A,   sigma.e = NULL,   mu = 0,   user_nu = NULL,   user_m = NULL,   log_scale = TRUE,   return_negative_likelihood = TRUE,   pivot = TRUE )"},{"path":"https://davidbolin.github.io/rSPDE/reference/construct.spde.matern.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor of Matern loglikelihood functions for non-stationary models. — construct.spde.matern.loglike","text":"object rational SPDE approximation, computed using matern.operators() Y observations, either vector matrix columns correspond independent replicates observations. observation matrix links measurement location finite element basis. sigma.e non-null, standard deviation measurement noise kept fixed returned likelihood. mu Expectation vector latent field (default = 0). user_nu non-null, shape parameter kept fixed returned likelihood. user_m non-null, update order rational approximation, needs positive integer. log_scale parameters evaluated log-scale? return_negative_likelihood Return minus likelihood turn maximization minimization? pivot pivoting used Cholesky decompositions? Default TRUE","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/construct.spde.matern.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructor of Matern loglikelihood functions for non-stationary models. — construct.spde.matern.loglike","text":"log-likelihood function. parameters returned function given order theta, nu, sigma.e, whenever available.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/construct.spde.matern.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor of Matern loglikelihood functions for non-stationary models. — construct.spde.matern.loglike","text":"","code":"# this example illustrates how the function can be used for maximum # likelihood estimation # Sample a Gaussian Matern process on R using a rational approximation set.seed(123) sigma.e <- 0.1 n.rep <- 10 n.obs <- 100 n.x <- 51 # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x) tau <- rep(0.5, n.x) nu <- 0.8 kappa <- rep(1, n.x) # Matern parameterization # compute rational approximation  op <- spde.matern.operators(    kappa = kappa, tau = tau, nu = nu,    G = fem$G, C = fem$C, d = 1  ) # Sample the model u <- simulate(op, n.rep) # Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs * n.rep) dim(noise) <- c(n.obs, n.rep) Y <- as.matrix(A %*% u + sigma.e * noise) # define negative likelihood function for optimization using matern.loglike mlik <- construct.spde.matern.loglike(op, Y, A) #' #The parameters can now be estimated by minimizing mlik with optim # \\donttest{ # Choose some reasonable starting values depending on the size of the domain theta0 <- log(c( 1 / sqrt(var(c(Y))),sqrt(8), 0.9, 0.01)) # run estimation and display the results theta <- optim(theta0, mlik) print(data.frame(   tau = c(tau[1], exp(theta$par[1])), kappa = c(kappa[1], exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) #>                 tau     kappa        nu    sigma.e #> Truth     0.5000000 1.0000000 0.8000000 0.10000000 #> Estimates 0.5113561 0.8705163 0.7924875 0.09893805 # }  # SPDE parameterization # compute rational approximation  op <- spde.matern.operators(    kappa = kappa, tau = tau, nu = nu,    G = fem$G, C = fem$C, d = 1,     parameterization = \"spde\"  ) # Sample the model u <- simulate(op, n.rep) # Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs * n.rep) dim(noise) <- c(n.obs, n.rep) Y <- as.matrix(A %*% u + sigma.e * noise) # define negative likelihood function for optimization using matern.loglike mlik <- construct.spde.matern.loglike(op, Y, A) #' #The parameters can now be estimated by minimizing mlik with optim # \\donttest{ # Choose some reasonable starting values depending on the size of the domain theta0 <- log(c( 1 / sqrt(var(c(Y))),sqrt(8), 0.9, 0.01)) # run estimation and display the results theta <- optim(theta0, mlik) print(data.frame(   tau = c(tau[1], exp(theta$par[1])), kappa = c(kappa[1], exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) #>                 tau    kappa        nu   sigma.e #> Truth     0.5000000 1.000000 0.8000000 0.1000000 #> Estimates 0.6243566 0.978483 0.7304962 0.1009251 # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/cross_validation.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform cross-validation on a list of fitted models. — cross_validation","title":"Perform cross-validation on a list of fitted models. — cross_validation","text":"Obtain several scores list fitted models according folding scheme.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/cross_validation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform cross-validation on a list of fitted models. — cross_validation","text":"","code":"cross_validation(   models,   model_names = NULL,   scores = c(\"mse\", \"crps\", \"scrps\", \"dss\"),   cv_type = c(\"k-fold\", \"loo\", \"lpo\"),   k = 5,   percentage = 30,   number_folds = 10,   n_samples = 1000,   return_scores_folds = FALSE,   orientation_results = c(\"negative\", \"positive\"),   train_test_indexes = NULL,   return_train_test = FALSE,   parallelize_RP = FALSE,   n_cores_RP = parallel::detectCores() - 1,   true_CV = FALSE,   save_settings = FALSE,   print = TRUE,   fit_verbose = FALSE )"},{"path":"https://davidbolin.github.io/rSPDE/reference/cross_validation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform cross-validation on a list of fitted models. — cross_validation","text":"models fitted model obtained calling bru() function list models fitted bru() function. model_names vector containing names models appear returned data.frame. NULL, names form Model 1, Model 2, . scores vector containing scores computed. options \"mse\", \"crps\", \"scrps\" \"dss\". default, scores computed. cv_type type folding carried . options k-fold k-fold cross-validation, case parameter k provided, loo, leave-one-lpo leave-percentage-, case, parameter percentage given, also number_folds number folds done. default k-fold. k number folds used k-fold cross-validation. used cv_type k-fold. percentage percentage (1 99) data used train model. used cv_type lpo. number_folds Number folds done cv_type lpo. n_samples Number samples compute posterior statistics used compute scores. return_scores_folds TRUE, scores fold also returned. orientation_results character vector. options \"negative\" \"positive\". \"negative\", smaller scores better. \"positive\", larger scores better. train_test_indexes list containing two entries train, list whose elements vectors indexes training data, test, list whose elements vectors indexes test data. Typically returned list obtained setting argument return_train_test TRUE. return_train_test Logical. training test indexes returned? 'TRUE' train test indexes 'train_test' element returned list. parallelize_RP Logical. computation CRPS SCRPS parallelized? n_cores_RP Number cores used parallelize_rp TRUE. true_CV TRUE cross-validation performed? TRUE models fitted training dataset. FALSE, parameters kept fixed ones obtained result object. save_settings Logical. TRUE, settings used cross-validation also returned. print partial results printed throughout computation? fit_verbose INLA's run cross-validation verbose?","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/cross_validation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform cross-validation on a list of fitted models. — cross_validation","text":"data.frame fitted models corresponding scores.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/cross_validation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform cross-validation on a list of fitted models. — cross_validation","text":"","code":"#devel version if (requireNamespace(\"INLA\", quietly = TRUE)){ library(INLA) if (requireNamespace(\"inlabru\", quietly = TRUE)){ library(inlabru)  set.seed(123)   } #devel.tag }"},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":null,"dir":"Reference","previous_headings":"","what":"The 1d folded Matern covariance function — folded.matern.covariance.1d","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"folded.matern.covariance.1d evaluates 1d folded Matern covariance function interval \\([0,L]\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"","code":"folded.matern.covariance.1d(   h,   m,   kappa,   nu,   sigma,   L = 1,   N = 10,   boundary = c(\"neumann\", \"dirichlet\", \"periodic\") )"},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"h, m Vectors arguments covariance function. kappa Range parameter. nu Shape parameter. sigma Standard deviation. L upper bound interval \\([0,L]\\). default, L=1. N truncation parameter. boundary boundary condition. possible conditions \"neumann\" (default), \"dirichlet\" \"periodic\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"matrix corresponding covariance values.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"folded.matern.covariance.1d evaluates 1d folded Matern covariance function interval \\([0,L]\\) different boundary conditions. periodic boundary conditions $$C_{\\mathcal{P}}(h,m) = \\sum_{k=-\\infty}^{\\infty} (C(h-m+2kL),$$ Neumann boundary conditions $$C_{\\mathcal{N}}(h,m) = \\sum_{k=-\\infty}^{\\infty} (C(h-m+2kL)+C(h+m+2kL)),$$ Dirichlet boundary conditions: $$C_{\\mathcal{D}}(h,m) = \\sum_{k=-\\infty}^{\\infty} (C(h-m+2kL)-C(h+m+2kL)),$$ \\(C(\\cdot)\\) Matern covariance function: $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h).$$ consider truncation: $$C_{{\\mathcal{P}},N}(h,m) = \\sum_{k=-N}^{N} C(h-m+2kL), C_{\\mathcal{N},N}(h,m) = \\sum_{k=-\\infty}^{\\infty} (C(h-m+2kL)+C(h+m+2kL)),$$ $$C_{\\mathcal{D},N}(h,m) = \\sum_{k=-N}^{N} (C(h-m+2kL)-C(h+m+2kL)).$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"","code":"x <- seq(from = 0, to = 1, length.out = 101) plot(x, folded.matern.covariance.1d(rep(0.5, length(x)), x, kappa = 10, nu = 1 / 5, sigma = 1),   type = \"l\", ylab = \"C(h)\", xlab = \"h\" )"},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":null,"dir":"Reference","previous_headings":"","what":"The 2d folded Matern covariance function — folded.matern.covariance.2d","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"folded.matern.covariance.2d evaluates 2d folded Matern covariance function interval \\([0,L]\\times [0,L]\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"","code":"folded.matern.covariance.2d(   h,   m,   kappa,   nu,   sigma,   L = 1,   N = 10,   boundary = c(\"neumann\", \"dirichlet\", \"periodic\", \"R2\") )"},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"h, m Vectors two coordinates. kappa Range parameter. nu Shape parameter. sigma Standard deviation. L upper bound square \\([0,L]\\times [0,L]\\). default, L=1. N truncation parameter. boundary boundary condition. possible conditions \"neumann\" (default), \"dirichlet\", \"periodic\" \"R2\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"correspoding covariance.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"folded.matern.covariance.2d evaluates 1d folded Matern covariance function interval \\([0,L]\\times [0,L]\\) different boundary conditions. periodic boundary conditions $$C_{\\mathcal{P}}((h_1,h_2),(m_1,m_2)) = \\sum_{k_2=-\\infty}^\\infty \\sum_{k_1=-\\infty}^{\\infty} (C(\\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\\|),$$ Neumann boundary conditions $$C_{\\mathcal{N}}((h_1,h_2),(m_1,m_2)) = \\sum_{k_2=-\\infty}^\\infty \\sum_{k_1=-\\infty}^{\\infty} (C(\\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\\|)+C(\\|(h_1-m_1+2k_1L, h_2+m_2+2k_2L)\\|)+C(\\|(h_1+m_1+2k_1L,h_2-m_2+2k_2L)\\|)+ C(\\|(h_1+m_1+2k_1L,h_2+m_2+2k_2L)\\|)),$$ Dirichlet boundary conditions: $$C_{\\mathcal{D}}((h_1,h_2),(m_1,m_2)) = \\sum_{k_2=-\\infty}^\\infty \\sum_{k_1=-\\infty}^{\\infty} (C(\\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\\|)- C(\\|(h_1-m_1+2k_1L,h_2+m_2+2k_2L)\\|)-C(\\|(h_1+m_1+2k_1L, h_2-m_2+2k_2L)\\|)+C(\\|(h_1+m_1+2k_1L,h_2+m_2+2k_2L)\\|)),$$ \\(C(\\cdot)\\) Matern covariance function: $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)} (\\kappa h)^\\nu K_\\nu(\\kappa h).$$ consider truncation \\(k_1,k_2\\) \\(-N\\) \\(N\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"","code":"h <- c(0.5, 0.5) m <- c(0.5, 0.5) folded.matern.covariance.2d(h, m, kappa = 10, nu = 1 / 5, sigma = 1) #> [1] 1.000043"},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational approximations of fractional operators — fractional.operators","title":"Rational approximations of fractional operators — fractional.operators","text":"fractional.operators used computing approximation, can used inference simulation, fractional SPDE $$L^\\beta (\\tau u(s)) = W.$$ \\(L\\) differential operator, \\(\\beta>0\\) fractional power, \\(\\tau\\) positive scalar vector scales variance solution \\(u\\), \\(W\\) white noise.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational approximations of fractional operators — fractional.operators","text":"","code":"fractional.operators(L, beta, C, scale.factor, m = 1, tau = 1)"},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rational approximations of fractional operators — fractional.operators","text":"L finite element discretization operator \\(L\\). beta positive fractional power. C mass matrix finite element discretization. scale.factor constant \\(c\\) lower bound smallest eigenvalue non-discretized operator \\(L\\). m order rational approximation, needs positive integer. default value 1. Higer values gives accurate approximation, computationally expensive use inference. Currently, largest value m implemented 4. tau constant vector scales variance solution. default value 1.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rational approximations of fractional operators — fractional.operators","text":"fractional.operators returns object class \"rSPDEobj\". object contains following quantities: Pl operator \\(P_l\\). Pr operator \\(P_r\\). C mass lumped mass matrix. Ci inverse C. m order rational approximation. beta fractional power. type String indicating type approximation. Q matrix t(Pl) %*% solve(C,Pl). type String indicating type approximation. Pl.factors List elements can used assemble \\(P_l\\). Pr.factors List elements can used assemble \\(P_r\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational approximations of fractional operators — fractional.operators","text":"approximation based rational approximation fractional operator, resulting approximate model form $$P_l u(s) = P_r W,$$ \\(P_j = p_j(L)\\) non-fractional operators defined terms polynomials \\(p_j\\) \\(j=l,r\\). order \\(p_r\\) given m order \\(p_l\\) \\(m + m_\\beta\\) \\(m_\\beta\\) integer part \\(\\beta\\) \\(\\beta>1\\) \\(m_\\beta = 1\\) otherwise. discrete approximation can written \\(u = P_r x\\) \\(x \\sim N(0,Q^{-1})\\) \\(Q = P_l^T C^{-1} P_l\\). Note matrices \\(P_r\\) \\(Q\\) may ill-conditioned \\(m>1\\). case, methods operator.operations() used operations involving matrices, since methods numerically stable.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rational approximations of fractional operators — fractional.operators","text":"","code":"# Compute rational approximation of a Gaussian process with a # Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *   (4 * pi)^(1 / 2) * gamma(nu + 1 / 2))) op <- fractional.operators(   L = fem$G + kappa^2 * fem$C, beta = (nu + 1 / 2) / 2,   C = fem$C, scale.factor = kappa^2, tau = tau )  v <- t(rSPDE.A1d(x, 0.5)) c.approx <- Sigma.mult(op, v)  # plot the result and compare with the true Matern covariance plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma),   type = \"l\", ylab = \"C(h)\",   xlab = \"h\", main = \"Matern covariance and rational approximations\" ) lines(x, c.approx, col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/get.initial.values.rSPDE.html","id":null,"dir":"Reference","previous_headings":"","what":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.initial.values.rSPDE","title":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.initial.values.rSPDE","text":"Auxiliar function obtain domain-based initial values log-likelihood optimization rSPDE models latent stationary Gaussian Matern model","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/get.initial.values.rSPDE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.initial.values.rSPDE","text":"","code":"get.initial.values.rSPDE(   mesh = NULL,   mesh.range = NULL,   n.spde = 1,   dim = NULL,   B.tau = NULL,   B.kappa = NULL,   B.sigma = NULL,   B.range = NULL,   nu = NULL,   parameterization = c(\"matern\", \"spde\"),   include.nu = TRUE,   log.scale = TRUE,   nu.upper.bound = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/get.initial.values.rSPDE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.initial.values.rSPDE","text":"mesh INLA mesh mesh.range range mesh. n.spde number basis functions mesh model. dim dimension domain. B.tau Matrix specification log-linear model \\(\\tau\\). used parameterization = 'spde'. B.kappa Matrix specification log-linear model \\(\\kappa\\). used parameterization = 'spde'. B.sigma Matrix specification log-linear model \\(\\sigma\\). used parameterization = 'matern'. B.range Matrix specification log-linear model \\(\\rho\\), range-like parameter (exactly range parameter stationary case). used parameterization = 'matern'. nu smoothness parameter. parameterization parameterization use? matern uses range, std. deviation nu (smoothness). spde uses kappa, tau nu (smoothness). default matern. include.nu also provide initial guess nu? log.scale results provided log scale? nu.upper.bound upper bound nu considered?","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/get.initial.values.rSPDE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.initial.values.rSPDE","text":"vector form (theta_1,theta_2,theta_3) theta_1 initial guess tau, theta_2 initial guess kappa theta_3 initial guess nu.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/gg_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Data frame for result objects from R-INLA fitted models to be used in ggplot2 — gg_df","title":"Data frame for result objects from R-INLA fitted models to be used in ggplot2 — gg_df","text":"Data frame result objects R-INLA fitted models used ggplot2","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/gg_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data frame for result objects from R-INLA fitted models to be used in ggplot2 — gg_df","text":"","code":"gg_df(result, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/gg_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data frame for result objects from R-INLA fitted models to be used in ggplot2 — gg_df","text":"result result object data frame desired ... arguments passed methods.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/gg_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data frame for result objects from R-INLA fitted models to be used in ggplot2 — gg_df","text":"data frame containing posterior densities.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/gg_df.rspde_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Data frame for rspde_result objects to be used in ggplot2 — gg_df.rspde_result","title":"Data frame for rspde_result objects to be used in ggplot2 — gg_df.rspde_result","text":"Returns ggplot-friendly data-frame marginal posterior densities.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/gg_df.rspde_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data frame for rspde_result objects to be used in ggplot2 — gg_df.rspde_result","text":"","code":"# S3 method for rspde_result gg_df(   result,   parameter = result$params,   transform = TRUE,   restrict_x_axis = NULL,   restrict_quantiles = NULL,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/gg_df.rspde_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data frame for rspde_result objects to be used in ggplot2 — gg_df.rspde_result","text":"result rspde_result object. parameter Vector. parameters get posterior density data.frame? options std.dev, range, tau, kappa nu. transform posterior density given original scale? restrict_x_axis Variables restrict range x axis based quantiles. restrict_quantiles Named list quantiles restrict x axis. contain name parameter along vector two elements specifying lower upper quantiles. names match ones result$params. example, want restrict nu 0.05 0.95 quantiles restrict_quantiles = c(0.05, 0.95). ... currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/gg_df.rspde_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data frame for rspde_result objects to be used in ggplot2 — gg_df.rspde_result","text":"data frame containing posterior densities.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":null,"dir":"Reference","previous_headings":"","what":"The Matern covariance function — matern.covariance","title":"The Matern covariance function — matern.covariance","text":"matern.covariance evaluates Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h).$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Matern covariance function — matern.covariance","text":"","code":"matern.covariance(h, kappa, nu, sigma)"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Matern covariance function — matern.covariance","text":"h Distances evaluate covariance function . kappa Range parameter. nu Shape parameter. sigma Standard deviation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Matern covariance function — matern.covariance","text":"vector values C(h).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Matern covariance function — matern.covariance","text":"","code":"x <- seq(from = 0, to = 1, length.out = 101) plot(x, matern.covariance(abs(x - 0.5), kappa = 10, nu = 1 / 5, sigma = 1),   type = \"l\", ylab = \"C(h)\", xlab = \"h\" )"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter-based log-likelihood for a latent Gaussian Matern model\nusing a rational SPDE approximation — matern.loglike","title":"Parameter-based log-likelihood for a latent Gaussian Matern model\nusing a rational SPDE approximation — matern.loglike","text":"function evaluates log-likelihood function Gaussian process Matern covariance function, observed Gaussian measurement noise: \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables. latent model approximated using rational approximation fractional SPDE model corresponding Gaussian process.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameter-based log-likelihood for a latent Gaussian Matern model\nusing a rational SPDE approximation — matern.loglike","text":"","code":"matern.loglike(   kappa,   sigma,   nu,   sigma.e,   Y,   G,   C,   A,   mu = 0,   d = 2,   m = 1,   type = c(\"covariance\", \"operator\"),   pivot = TRUE )"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameter-based log-likelihood for a latent Gaussian Matern model\nusing a rational SPDE approximation — matern.loglike","text":"kappa Range parameter latent process. sigma Standard deviation latent process. nu Shape parameter latent process. sigma.e standard deviation measurement noise. Y observations, either vector matrix columns correspond independent replicates observations. G stiffness matrix finite element discretization domain. C mass matrix finite element discretization domain. matrix linking measurement locations basis FEM approximation latent model. mu Expectation vector latent field (default = 0). d dimension domain. default value 2. m order rational approximation, needs positive integer. default value 1. type type rational approximation. options \"covariance\" \"operator\". default \"covariance\". pivot pivoting used Cholesky decompositions? Default TRUE","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameter-based log-likelihood for a latent Gaussian Matern model\nusing a rational SPDE approximation — matern.loglike","text":"log-likelihood value.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parameter-based log-likelihood for a latent Gaussian Matern model\nusing a rational SPDE approximation — matern.loglike","text":"","code":"# this example illustrates how the function can be used for maximum # likelihood estimation  set.seed(123) # Sample a Gaussian Matern process on R using the covariance-based # rational approximation nu <- 0.8 kappa <- 5 sigma <- 1 sigma.e <- 0.1 n.rep <- 10 n.obs <- 100 n.x <- 51  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x)  tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))  # Compute the covariance-based rational approximation op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  # Sample the model u <- simulate(op_cov, n.rep)  # Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs * n.rep) dim(noise) <- c(n.obs, n.rep) Y <- as.matrix(A %*% u + sigma.e * noise)  # Define the negative likelihood function for optimization # using CBrSPDE.matern.loglike # Notice that we are also using sigma instead of tau, so it can be compared # to matern.loglike() mlik_cov2 <- function(theta, Y, A, C, G) {   kappa <- exp(theta[1])   sigma <- exp(theta[2])   nu <- exp(theta[3])   return(-matern.loglike(     kappa = kappa, sigma = sigma,     nu = nu, sigma.e = exp(theta[4]), Y = Y, A = A,     C = fem$C, G = fem$G, d = 1   )) }  # The parameters can now be estimated by minimizing mlik with optim # \\donttest{ # Choose some reasonable starting values depending on the size of the domain theta0 <- log(c(sqrt(8), sqrt(var(c(Y))), 0.9, 0.01))  # run estimation and display the results theta <- optim(theta0, mlik_cov2,   Y = Y, A = A, C = C, G = G,   method = \"L-BFGS-B\" )  print(data.frame(   kappa = c(kappa, exp(theta$par[1])), sigma = c(sigma, exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) #>              kappa     sigma      nu   sigma.e #> Truth     5.000000 1.0000000 0.80000 0.1000000 #> Estimates 7.679704 0.9688538 1.05354 0.0984116 # }  # this example illustrates how the function can be used for # maximum likelihood estimation when using the operator-based # rational approximation set.seed(123) # Sample a Gaussian Matern process on R using a rational approximation nu <- 0.8 kappa <- 5 sigma <- 1 sigma.e <- 0.1 n.rep <- 10 n.obs <- 100 n.x <- 51  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x)  # compute rational approximation op <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem$G, C = fem$C, d = 1,   type = \"operator\" )  # Sample the model u <- simulate(op, n.rep)  # Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs * n.rep) dim(noise) <- c(n.obs, n.rep) Y <- as.matrix(A %*% u + sigma.e * noise)  # define negative likelihood function for optimization using matern.loglike mlik <- function(theta, Y, G, C, A) {   return(-matern.loglike(exp(theta[1]), exp(theta[2]),     exp(theta[3]), exp(theta[4]),     Y = Y, G = G, C = C, A = A, d = 1,     type = \"operator\"   )) }  # The parameters can now be estimated by minimizing mlik with optim # \\donttest{ # Choose some reasonable starting values depending on the size of the domain theta0 <- log(c(sqrt(8), sqrt(var(c(Y))), 0.9, 0.01))  # run estimation and display the results theta <- optim(theta0, mlik,   Y = Y, G = fem$G, C = fem$C, A = A,   method = \"L-BFGS-B\" )  print(data.frame(   kappa = c(kappa, exp(theta$par[1])), sigma = c(sigma, exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) #>              kappa     sigma        nu    sigma.e #> Truth     5.000000 1.0000000 0.8000000 0.10000000 #> Estimates 4.063431 0.8095477 0.5906243 0.09566357 # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"matern.operators used computing rational SPDE approximation stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)} (\\kappa h)^\\nu K_\\nu(\\kappa h)$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"","code":"matern.operators(   kappa = NULL,   sigma = NULL,   tau = NULL,   range = NULL,   nu,   G = NULL,   C = NULL,   d = NULL,   mesh = NULL,   m = 1,   type = c(\"covariance\", \"operator\"),   compute_higher_order = FALSE,   return_block_list = FALSE,   type_rational_approximation = c(\"chebfun\", \"brasil\", \"chebfunLB\"),   fem_mesh_matrices = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"kappa Parameter kappa covariance function. sigma Standard deviation covariance function. tau Parameter tau covariance function (used sigma provided). range Range parameter covariance function (used kappa provided). nu Shape parameter covariance function. G stiffness matrix finite element discretization domain interest. need given mesh used. C mass matrix finite element discretization domain interest. need given mesh used. d dimension domain. need given mesh used. mesh optional inla mesh. d, C G must given mesh given. m order rational approximation, needs positive integer. default value 1. type type rational approximation. options \"covariance\" \"operator\". default \"covariance\". compute_higher_order Logical. higher order finite element matrices computed? return_block_list Logical. type = \"covariance\", block parts precision matrix returned separately list? type_rational_approximation type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\". fem_mesh_matrices list containing FEM-related matrices. list contain elements c0, g1, g2, g3, etc.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"type \"covariance\", matern.operators returns object class \"CBrSPDEobj\". object list containing following quantities: C mass lumped mass matrix. Ci inverse C. GCi stiffness matrix G times Ci Gk stiffness matrix G along higher-order FEM-related matrices G2, G3, etc. fem_mesh_matrices list containing mass lumped mass matrix, stiffness matrix higher-order FEM-related matrices. m order rational approximation. alpha fractional power precision operator. type String indicating type approximation. d dimension domain. nu Shape parameter covariance function. kappa Range parameter covariance function tau Scale parameter covariance function. sigma Standard deviation covariance function. type String indicating type approximation. type \"operator\", matern.operators returns object class \"rSPDEobj\". object contains quantities listed output fractional.operators(), G matrix, dimension domain, well parameters covariance function.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"type \"covariance\", use covariance-based rational approximation fractional operator. SPDE approach, model \\(u\\) solution following SPDE: $$L^{\\alpha/2}(\\tau u) = \\mathcal{W},$$ \\(L  = -\\Delta +\\kappa^2 \\) \\(\\mathcal{W}\\) standard Gaussian white noise. covariance operator \\(u\\) given \\(L^{-\\alpha}\\). Now, let \\(L_h\\) finite-element approximation \\(L\\). can use rational approximation order \\(m\\) \\(L_h^{-\\alpha}\\) obtain following approximation: $$L_{h,m}^{-\\alpha} = L_h^{-m_\\alpha} p(L_h^{-1})q(L_h^{-1})^{-1},$$ \\(m_\\alpha = \\lfloor \\alpha\\rfloor\\), \\(p\\) \\(q\\) polynomials arising rational approximation. approximation construct approximate precision matrix \\(u\\). type \"operator\", approximation based rational approximation fractional operator \\((\\kappa^2 -\\Delta)^\\beta\\), \\(\\beta = (\\nu + d/2)/2\\). results approximate model form $$P_l u(s) = P_r W,$$ \\(P_j = p_j(L)\\) non-fractional operators defined terms polynomials \\(p_j\\) \\(j=l,r\\). order \\(p_r\\) given m order \\(p_l\\) \\(m + m_\\beta\\) \\(m_\\beta\\) integer part \\(\\beta\\) \\(\\beta>1\\) \\(m_\\beta = 1\\) otherwise. discrete approximation can written \\(u = P_r x\\) \\(x \\sim N(0,Q^{-1})\\) \\(Q = P_l^T C^{-1} P_l\\). Note matrices \\(P_r\\) \\(Q\\) may ill-conditioned \\(m>1\\). case, methods operator.operations() used operations involving matrices, since methods numerically stable.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"","code":"# Compute the covariance-based rational approximation of a # Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization nobs <- 101 x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  v <- t(rSPDE.A1d(x, 0.5)) # Compute the precision matrix Q <- op_cov$Q # A matrix here is the identity matrix A <- Diagonal(nobs) # We need to concatenate 3 A's since we are doing a covariance-based rational # approximation of order 2 Abar <- cbind(A, A, A) w <- rbind(v, v, v) # The approximate covariance function: c_cov.approx <- (Abar) %*% solve(Q, w) c.true <- folded.matern.covariance.1d(rep(0.5, length(x)),    abs(x), kappa, nu, sigma)  # plot the result and compare with the true Matern covariance plot(x, c.true,   type = \"l\", ylab = \"C(h)\",   xlab = \"h\", main = \"Matern covariance and rational approximations\" ) lines(x, c_cov.approx, col = 2)    # Compute the operator-based rational approximation of a Gaussian # process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 op <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem$G, C = fem$C, d = 1,   type = \"operator\" )  v <- t(rSPDE.A1d(x, 0.5)) c.approx <- Sigma.mult(op, v) c.true <- folded.matern.covariance.1d(rep(0.5, length(x)),   abs(x), kappa, nu, sigma)  # plot the result and compare with the true Matern covariance plot(x, c.true,   type = \"l\", ylab = \"C(h)\",   xlab = \"h\", main = \"Matern covariance and rational approximation\" ) lines(x, c.approx, col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":null,"dir":"Reference","previous_headings":"","what":"Operations with the Pr and Pl operators — operator.operations","title":"Operations with the Pr and Pl operators — operator.operations","text":"Functions multiplying solving \\(P_r\\) \\(P_l\\) operators well latent precision matrix \\(Q = P_l C^{-1}P_l\\) covariance matrix \\(\\Sigma = P_r Q^{-1} P_r^T\\). operations done without first assembling \\(P_r\\), \\(P_l\\) order avoid numerical problems caused ill-conditioned matrices.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Operations with the Pr and Pl operators — operator.operations","text":"","code":"Pr.mult(obj, v, transpose = FALSE)  Pr.solve(obj, v, transpose = FALSE)  Pl.mult(obj, v, transpose = FALSE)  Pl.solve(obj, v, transpose = FALSE)  Q.mult(obj, v)  Q.solve(obj, v)  Qsqrt.mult(obj, v, transpose = FALSE)  Qsqrt.solve(obj, v, transpose = FALSE)  Sigma.mult(obj, v)  Sigma.solve(obj, v)"},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Operations with the Pr and Pl operators — operator.operations","text":"obj rSPDE object v vector apply operation transpose set TRUE operation performed transposed object","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Operations with the Pr and Pl operators — operator.operations","text":"vector values operation","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Operations with the Pr and Pl operators — operator.operations","text":"Pl.mult, Pr.mult, Q.mult multiplies vector respective object. Changing mult solve function names multiplies vector inverse object. Qsqrt.mult Qsqrt.solve performs operations square-root type object \\(Q_r = C^{-1/2}P_l\\) defined \\(Q = Q_r^T Q_r\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the precision matrix of CBrSPDEobj objects — precision","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"Function get precision matrix CBrSPDEobj object","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"","code":"precision(object, ...)  # S3 method for CBrSPDEobj precision(   object,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_range = NULL,   user_tau = NULL,   user_m = NULL,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"object covariance-based rational SPDE approximation, computed using matern.operators() ... Currently used. user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_range non-null, update range parameter covariance function. user_tau non-null, update parameter tau. user_m non-null, update order rational approximation, needs positive integer.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"precision matrix.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"","code":"# Compute the covariance-based rational approximation of a # Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi)^(1 / 2) * gamma(nu + 1 / 2))) op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  # Get the precision matrix: prec_matrix <- precision(op_cov)"},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.inla_rspde.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the precision matrix of inla_rspde objects — precision.inla_rspde","title":"Get the precision matrix of inla_rspde objects — precision.inla_rspde","text":"Function get precision matrix inla_rspde object created rspde.matern() function.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.inla_rspde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the precision matrix of inla_rspde objects — precision.inla_rspde","text":"","code":"# S3 method for inla_rspde precision(object, theta = NULL, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.inla_rspde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the precision matrix of inla_rspde objects — precision.inla_rspde","text":"object inla_rspde object obtained rspde.matern() function. theta null, starting values theta used. Otherwise, must suplied vector. stationary models, theta = c(log(tau), log(kappa), nu). nonstationary models, theta = c(theta_1, theta_2, ..., theta_n, nu). ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.inla_rspde.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the precision matrix of inla_rspde objects — precision.inla_rspde","text":"precision matrix.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction of a fractional SPDE using the covariance-based\nrational SPDE approximation — predict.CBrSPDEobj","title":"Prediction of a fractional SPDE using the covariance-based\nrational SPDE approximation — predict.CBrSPDEobj","text":"function used computing kriging predictions based data \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon\\) mean-zero Gaussian measurement noise \\(u(s)\\) defined fractional SPDE \\((\\kappa^2 - \\Delta)^{\\alpha/2} (\\tau u(s)) = W\\), \\(W\\) Gaussian white noise \\(\\alpha = \\nu + d/2\\), \\(d\\) dimension domain.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction of a fractional SPDE using the covariance-based\nrational SPDE approximation — predict.CBrSPDEobj","text":"","code":"# S3 method for CBrSPDEobj predict(   object,   A,   Aprd,   Y,   sigma.e,   mu = 0,   compute.variances = FALSE,   posterior_samples = FALSE,   n_samples = 100,   only_latent = FALSE,   pivot = TRUE,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction of a fractional SPDE using the covariance-based\nrational SPDE approximation — predict.CBrSPDEobj","text":"object covariance-based rational SPDE approximation, computed using matern.operators() matrix linking measurement locations basis FEM approximation latent model. Aprd matrix linking prediction locations basis FEM approximation latent model. Y vector observed data, can also matrix columns observations independent replicates \\(u\\). sigma.e standard deviation Gaussian measurement noise. Put zero model measurement noise. mu Expectation vector latent field (default = 0). compute.variances Set also TRUE compute kriging variances. posterior_samples TRUE, posterior samples returned. n_samples Number samples returned. used sampling TRUE. only_latent posterior samples given laten model? pivot pivoting used Cholesky decompositions? ... arguments passed methods.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction of a fractional SPDE using the covariance-based\nrational SPDE approximation — predict.CBrSPDEobj","text":"list elements mean kriging predictor (posterior mean u|Y). variance posterior variances (computed).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction of a fractional SPDE using the covariance-based\nrational SPDE approximation — predict.CBrSPDEobj","text":"","code":"set.seed(123) # Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8 sigma.e <- 0.3  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) *        (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))  # Compute the covariance-based rational approximation op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  # Sample the model u <- simulate(op_cov)  # Create some data obs.loc <- runif(n = 10, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) Y <- as.vector(A %*% u + sigma.e * rnorm(10))  # compute kriging predictions at the FEM grid A.krig <- rSPDE.A1d(x, x) u.krig <- predict(op_cov,   A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e,   compute.variances = TRUE )  plot(obs.loc, Y,   ylab = \"u(x)\", xlab = \"x\", main = \"Data and prediction\",   ylim = c(     min(u.krig$mean - 2 * sqrt(u.krig$variance)),     max(u.krig$mean + 2 * sqrt(u.krig$variance))   ) ) lines(x, u.krig$mean) lines(x, u.krig$mean + 2 * sqrt(u.krig$variance), col = 2) lines(x, u.krig$mean - 2 * sqrt(u.krig$variance), col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"function used computing kriging predictions based data \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon\\) mean-zero Gaussian measurement noise \\(u(s)\\) defined fractional SPDE \\(L^\\beta u(s) = W\\), \\(W\\) Gaussian white noise.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"","code":"# S3 method for rSPDEobj predict(   object,   A,   Aprd,   Y,   sigma.e,   compute.variances = FALSE,   posterior_samples = FALSE,   n_samples = 100,   only_latent = FALSE,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"object rational SPDE approximation, computed using fractional.operators(), matern.operators(), spde.matern.operators(). matrix linking measurement locations basis FEM approximation latent model. Aprd matrix linking prediction locations basis FEM approximation latent model. Y vector observed data, can also matrix columns observations independent replicates \\(u\\). sigma.e standard deviation Gaussian measurement noise. Put zero model measurement noise. compute.variances Set also TRUE compute kriging variances. posterior_samples TRUE, posterior samples returned. n_samples Number samples returned. used sampling TRUE. only_latent posterior samples given laten model? ... arguments passed methods.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"list elements mean kriging predictor (posterior mean u|Y). variance posterior variances (computed). samples matrix containing samples sampling TRUE.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"","code":"# Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8 sigma.e <- 0.3  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation op <- matern.operators(   kappa = kappa, sigma = sigma,   nu = nu, G = fem$G, C = fem$C, d = 1 )  # Sample the model u <- simulate(op)  # Create some data obs.loc <- runif(n = 10, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) Y <- as.vector(A %*% u + sigma.e * rnorm(10))  # compute kriging predictions at the FEM grid A.krig <- rSPDE.A1d(x, x) u.krig <- predict(op,   A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e,   compute.variances = TRUE )  plot(obs.loc, Y,   ylab = \"u(x)\", xlab = \"x\", main = \"Data and prediction\",   ylim = c(     min(u.krig$mean - 2 * sqrt(u.krig$variance)),     max(u.krig$mean + 2 * sqrt(u.krig$variance))   ) ) lines(x, u.krig$mean) lines(x, u.krig$mean + 2 * sqrt(u.krig$variance), col = 2) lines(x, u.krig$mean - 2 * sqrt(u.krig$variance), col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":null,"dir":"Reference","previous_headings":"","what":"Observation matrix for finite element discretization on R — rSPDE.A1d","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"finite element discretization R can written \\(u(s) = \\sum_i^n u_i \\varphi_i(s)\\) \\(\\varphi_i(s)\\) piecewise linear \"hat function\" centered location \\(x_i\\). function computes \\(m\\times n\\) matrix \\(\\) links basis function expansion specified locations \\(s = (s_1,\\ldots, s_m)\\) domain \\(A_ij = \\varphi_j(s_i)\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"","code":"rSPDE.A1d(x, loc)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"x locations nodes FEM discretization. loc locations \\((s_1,\\ldots, s_m)\\)","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"sparse matrix .","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"David Bolin davidbolin@gmail.com","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"","code":"# create mass and stiffness matrices for a FEM discretization on [0,1] x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # create the observation matrix for some locations in the domain obs.loc <- runif(n = 10, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.construct.matern.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Constructor of Matern loglikelihood functions. — rSPDE.construct.matern.loglike","title":"Constructor of Matern loglikelihood functions. — rSPDE.construct.matern.loglike","text":"function returns log-likelihood function Gaussian process Matern covariance function, observed Gaussian measurement noise: \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables. latent model approximated using rational approximation fractional SPDE model corresponding Gaussian process.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.construct.matern.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Constructor of Matern loglikelihood functions. — rSPDE.construct.matern.loglike","text":"","code":"rSPDE.construct.matern.loglike(   object,   Y,   A,   sigma.e = NULL,   mu = 0,   user_nu = NULL,   user_tau = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_range = NULL,   parameterization = c(\"spde\", \"matern\"),   user_m = NULL,   log_scale = TRUE,   return_negative_likelihood = TRUE,   pivot = TRUE )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.construct.matern.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Constructor of Matern loglikelihood functions. — rSPDE.construct.matern.loglike","text":"object rational SPDE approximation, computed using matern.operators() Y observations, either vector matrix columns correspond independent replicates observations. observation matrix links measurement location finite element basis. sigma.e non-null, standard deviation measurement noise kept fixed returned likelihood. mu Expectation vector latent field (default = 0). user_nu non-null, shape parameter kept fixed returned likelihood. user_tau non-null, tau parameter kept fixed returned likelihood. (Replaces sigma) user_kappa non-null, range parameter kept fixed returned likelihood. user_sigma non-null, standard deviation kept fixed returned likelihood. user_range non-null, range parameter kept fixed returned likelihood. (Replaces kappa) parameterization spde, one use parameters tau kappa. matern, one use parameters sigma range. user_m non-null, update order rational approximation, needs positive integer. log_scale parameters evaluated log-scale? return_negative_likelihood Return minus likelihood turn maximization minimization? pivot pivoting used Cholesky decompositions? Default TRUE","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.construct.matern.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Constructor of Matern loglikelihood functions. — rSPDE.construct.matern.loglike","text":"log-likelihood function. parameters returned function given order sigma, kappa, nu, sigma.e, whenever available.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.construct.matern.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Constructor of Matern loglikelihood functions. — rSPDE.construct.matern.loglike","text":"","code":"# this example illustrates how the function can be used for maximum # likelihood estimation  set.seed(123) # Sample a Gaussian Matern process on R using a rational approximation nu <- 0.8 kappa <- 15 sigma <- 1 sigma.e <- 0.1 n.rep <- 10 n.obs <- 200 n.x <- 51 # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x) tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi)^(1 / 2) * gamma(nu + 1 / 2))) # Compute the covariance-based rational approximation op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 ) # Sample the model u <- simulate(op_cov, n.rep) # Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs * n.rep) dim(noise) <- c(n.obs, n.rep) Y <- as.matrix(A %*% u + sigma.e * noise) # \\donttest{ # Define the negative likelihood function for optimization # using CBrSPDE.matern.loglike # Matern parameterization loglike <- rSPDE.construct.matern.loglike(op_cov, Y, A, parameterization = \"matern\")   # The parameters can now be estimated by minimizing mlik with optim  # Choose some reasonable starting values depending on the size of the domain theta0 <- log(c(1/sqrt(var(c(Y))), sqrt(8),  0.9, 0.01)) # run estimation and display the results theta <- optim(theta0, loglike,   method = \"L-BFGS-B\" ) print(data.frame(   sigma = c(sigma, exp(theta$par[1])), range = c(sqrt(8*nu)/kappa, exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) #>               sigma     range        nu   sigma.e #> Truth     1.0000000 0.1686548 0.8000000 0.1000000 #> Estimates 0.9994909 0.1698612 0.8060993 0.1001845  # SPDE parameterization: loglike <- rSPDE.construct.matern.loglike(op_cov, Y, A, parameterization = \"spde\")   # run estimation and display the results theta <- optim(theta0, loglike,   method = \"L-BFGS-B\" ) print(data.frame(   tau = c(tau, exp(theta$par[1])), kappa = c(kappa, exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) #>                  tau    kappa        nu  sigma.e #> Truth     0.06931604 15.00000 0.8000000 0.100000 #> Estimates 0.04018727 17.92134 0.9309403 0.100214 # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite element calculations for problems on R — rSPDE.fem1d","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"function computes mass stiffness matrices FEM approximation R, assuming Neumann boundary conditions. matrices needed discretizing operators rational approximations.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"","code":"rSPDE.fem1d(x)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"x Locations nodes FEM approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"function returns list following elements G stiffness matrix. C mass matrix.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"David Bolin davidbolin@gmail.com","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"","code":"# create mass and stiffness matrices for a FEM discretization on [0,1] x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational approximations of fractional SPDEs. — rSPDE","title":"Rational approximations of fractional SPDEs. — rSPDE","text":"rSPDE used approximating fractional elliptic SPDEs $$L^\\beta (\\tau u(s)) = W,$$ \\(L\\) differential operator \\(\\beta>0\\) general fractional power.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational approximations of fractional SPDEs. — rSPDE","text":"approximation based rational approximation fractional operator, allows computationally efficient inference simulation. main functions computing rational approximation objects : fractional.operators()works general rational operators matern.operators() works random fields stationary Matern covariance functions spde.matern.operators() works random fields defined solutions possibly non-stationary Matern-type SPDE model. rspde.matern() R-INLA implementation covariance-based rational approximation random fields stationary Matern covariance functions Basic statistical operations likelihood evaluations (see [rSPDE.loglike], [rSPDE.matern.loglike]) kriging predictions (see [predict.rSPDEobj], [predict.CBrSPDEobj]) using rational approximations also implemented. illustration purposes, package contains simple FEM implementation models R. spatial models, FEM implementation R-INLA package recommended. detailed introduction package, see rSPDE Vignettes.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","title":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","text":"function evaluates log-likelihood function fractional SPDE model \\(L^\\beta u(s) = W\\) observed Gaussian measurement noise: \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables \\(x(s) = \\mu(s) + u(s)\\), \\(\\mu(s)\\) expectation vector latent field.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","text":"","code":"rSPDE.loglike(obj, Y, A, sigma.e, mu = 0)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","text":"obj rational SPDE approximation, computed using fractional.operators(), matern.operators(), spde.matern.operators(). Y observations, either vector matrix columns correspond independent replicates observations. observation matrix links measurement location finite element basis. sigma.e standard deviation measurement noise. mu Expectation vector latent field (default = 0).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","text":"log-likelihood value.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","text":"example shows function can used evaluate likelihood latent Matern model. Se matern.loglike() example can used maximum likelihood estimation.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Object-based log-likelihood function for latent Gaussian\nfractional SPDE model — rSPDE.loglike","text":"","code":"# Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8 sigma.e <- 0.3  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation op <- matern.operators(   kappa = kappa, sigma = sigma, nu = nu,   G = fem$G, C = fem$C, d = 1,   type = \"operator\" )  # Sample the model u <- simulate(op)  # Create some data obs.loc <- runif(n = 10, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) Y <- as.vector(A %*% u + sigma.e * rnorm(10))  # compute log-likelihood of the data lik1 <- rSPDE.loglike(op, Y, A, sigma.e) cat(lik1) #> -9.104623"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Object-based log-likelihood function for latent Gaussian fractional\nSPDE model using the rational approximations — rSPDE.matern.loglike","title":"Object-based log-likelihood function for latent Gaussian fractional\nSPDE model using the rational approximations — rSPDE.matern.loglike","text":"function evaluates log-likelihood function Gaussian process Matern covariance function, observed Gaussian measurement noise: \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables. latent model approximated using rational approximation fractional SPDE model corresponding Gaussian process.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Object-based log-likelihood function for latent Gaussian fractional\nSPDE model using the rational approximations — rSPDE.matern.loglike","text":"","code":"rSPDE.matern.loglike(   object,   Y,   A,   sigma.e,   mu = 0,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_range = NULL,   user_tau = NULL,   user_m = NULL,   pivot = TRUE )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Object-based log-likelihood function for latent Gaussian fractional\nSPDE model using the rational approximations — rSPDE.matern.loglike","text":"object rational SPDE approximation, computed using matern.operators() Y observations, either vector matrix columns correspond independent replicates observations. observation matrix links measurement location finite element basis. sigma.e standard deviation measurement noise. mu Expectation vector latent field (default = 0). user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_range non-null, update range parameter covariance function. user_tau non-null, update parameter tau. user_m non-null, update order rational approximation, needs positive integer. pivot pivoting used Cholesky decompositions? Default TRUE","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Object-based log-likelihood function for latent Gaussian fractional\nSPDE model using the rational approximations — rSPDE.matern.loglike","text":"log-likelihood value.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Object-based log-likelihood function for latent Gaussian fractional\nSPDE model using the rational approximations — rSPDE.matern.loglike","text":"","code":"# this example illustrates how the function can be used for maximum # likelihood estimation  set.seed(123) # Sample a Gaussian Matern process on R using a rational approximation nu <- 0.8 kappa <- 5 sigma <- 1 sigma.e <- 0.1 n.rep <- 10 n.obs <- 100 n.x <- 51  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x)  tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi)^(1 / 2) * gamma(nu + 1 / 2)))  # Compute the covariance-based rational approximation op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  # Sample the model u <- simulate(op_cov, n.rep)  # Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs * n.rep) dim(noise) <- c(n.obs, n.rep) Y <- as.matrix(A %*% u + sigma.e * noise)  # Define the negative likelihood function for optimization # using CBrSPDE.matern.loglike  # Notice that we are also using sigma instead of tau, so it can be compared # to matern.loglike() mlik_cov <- function(theta, Y, A, op_cov) {   kappa <- exp(theta[1])   sigma <- exp(theta[2])   nu <- exp(theta[3])   return(-rSPDE.matern.loglike(     object = op_cov, Y = Y,     A = A, user_kappa = kappa, user_sigma = sigma,     user_nu = nu, sigma.e = exp(theta[4])   )) }  # The parameters can now be estimated by minimizing mlik with optim # \\donttest{ # Choose some reasonable starting values depending on the size of the domain theta0 <- log(c(sqrt(8), 1 / sqrt(var(c(Y))), 0.9, 0.01))  # run estimation and display the results theta <- optim(theta0, mlik_cov,   Y = Y, A = A, op_cov = op_cov,   method = \"L-BFGS-B\" )  print(data.frame(   kappa = c(kappa, exp(theta$par[1])), sigma = c(sigma, exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) #>              kappa     sigma        nu    sigma.e #> Truth     5.000000 1.0000000 0.8000000 0.10000000 #> Estimates 5.298476 0.9404033 0.8022152 0.09837292 # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order-set.html","id":null,"dir":"Reference","previous_headings":"","what":"Changing the order of the rational approximation — rational.order<-","title":"Changing the order of the rational approximation — rational.order<-","text":"Changing order rational approximation","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order-set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Changing the order of the rational approximation — rational.order<-","text":"","code":"rational.order(x) <- value"},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order-set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Changing the order of the rational approximation — rational.order<-","text":"x CBrSPDE rpsde.inla object value order rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order-set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Changing the order of the rational approximation — rational.order<-","text":"object class new order rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the order of rational approximation. — rational.order","title":"Get the order of rational approximation. — rational.order","text":"Get order rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the order of rational approximation. — rational.order","text":"","code":"rational.order(object)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the order of rational approximation. — rational.order","text":"object CBrSPDEobj object inla_rspde object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the order of rational approximation. — rational.order","text":"order rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type-set.html","id":null,"dir":"Reference","previous_headings":"","what":"Changing the type of the rational approximation — rational.type<-","title":"Changing the type of the rational approximation — rational.type<-","text":"Changing type rational approximation","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type-set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Changing the type of the rational approximation — rational.type<-","text":"","code":"rational.type(x) <- value"},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type-set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Changing the type of the rational approximation — rational.type<-","text":"x CBrSPDE rpsde.inla object value type rational approximation. current options \"chebfun\", \"brasil\" \"chebfunLB\"","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type-set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Changing the type of the rational approximation — rational.type<-","text":"object class new rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type.html","id":null,"dir":"Reference","previous_headings":"","what":"Get type of rational approximation. — rational.type","title":"Get type of rational approximation. — rational.type","text":"Get type rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get type of rational approximation. — rational.type","text":"","code":"rational.type(object)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get type of rational approximation. — rational.type","text":"object CBrSPDEobj object inla_rspde object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get type of rational approximation. — rational.type","text":"type rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":null,"dir":"Reference","previous_headings":"","what":"Warnings free loading of add-on packages — require.nowarnings","title":"Warnings free loading of add-on packages — require.nowarnings","text":"Turn warnings require(), allow clean completion examples require unavailable Suggested packages.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Warnings free loading of add-on packages — require.nowarnings","text":"","code":"require.nowarnings(package, lib.loc = NULL, character.only = FALSE)"},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Warnings free loading of add-on packages — require.nowarnings","text":"package name package, given character string. lib.loc character vector describing location R library trees search , NULL.  default value NULL corresponds libraries currently known .libPaths(). Non-existent library trees silently ignored. character.logical indicating whether package can assumed character string.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Warnings free loading of add-on packages — require.nowarnings","text":"require.nowarnings returns (invisibly) TRUE succeeds, otherwise FALSE","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Warnings free loading of add-on packages — require.nowarnings","text":"require(package) acts require(package, quietly = TRUE) warnings turned . particular, warning error given package unavailable. cases use requireNamespace(package, quietly = TRUE) instead, produce warnings.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Warnings free loading of add-on packages — require.nowarnings","text":"","code":"## This should produce no output: if (require.nowarnings(nonexistent)) {   message(\"Package loaded successfully\") }"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":null,"dir":"Reference","previous_headings":"","what":"Observation/prediction matrices for rSPDE models. — rspde.make.A","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"Constructs observation/prediction weight matrices rSPDE models based inla.mesh inla.mesh.1d objects.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"","code":"rspde.make.A(   mesh = NULL,   loc = NULL,   A = NULL,   dim = NULL,   rspde.order = 2,   nu = NULL,   index = NULL,   group = NULL,   repl = 1L,   n.group = NULL,   n.repl = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"mesh inla.mesh, inla.mesh.1d object metric_graph object. loc Locations, needed INLA mesh provided matrix standard SPDE approach, matrix returned inla.spde.make.. provided mesh provided. dim dimension. provided mesh provided. rspde.order order covariance-based rational SPDE approach. nu NULL, model assume nu estimated. nu fixed, provide value nu. index observation/prediction value, index loc. Default seq_len(nrow(.loc)). group observation/prediction value, index group model. repl observation/prediction value, replicate index. n.group size group model. n.repl total number replicates.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"\\(\\) matrix rSPDE models.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"","code":"#devel version if (requireNamespace(\"INLA\", quietly = TRUE)){ library(INLA)  set.seed(123) loc <- matrix(runif(100 * 2) * 100, 100, 2) mesh <- inla.mesh.2d(   loc = loc,   cutoff = 50,   max.edge = c(50, 500) ) A <- rspde.make.A(mesh, loc = loc, rspde.order = 3) } #devel.tag"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":null,"dir":"Reference","previous_headings":"","what":"rSPDE model index vector generation — rspde.make.index","title":"rSPDE model index vector generation — rspde.make.index","text":"Generates list named index vectors rSPDE model.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rSPDE model index vector generation — rspde.make.index","text":"","code":"rspde.make.index(   name,   n.spde = NULL,   n.group = 1,   n.repl = 1,   mesh = NULL,   rspde.order = 2,   nu = NULL,   dim = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rSPDE model index vector generation — rspde.make.index","text":"name character string base name effect. n.spde number basis functions mesh model. n.group size group model. n.repl total number replicates. mesh inla.mesh, inla.mesh.1d object metric_graph object. rspde.order order rational approximation nu NULL, model assume nu estimated. nu fixed, provide value nu. dim dimension domain. provided mesh provided.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"rSPDE model index vector generation — rspde.make.index","text":"list named index vectors. name Indices vector latent variables name.group 'group' indices name.repl Indices replicates","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"rSPDE model index vector generation — rspde.make.index","text":"","code":"#devel version if (requireNamespace(\"INLA\", quietly = TRUE)){ library(INLA)  set.seed(123)  m <- 100 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   max.edge = c(0.1, 0.5) ) sigma <- 1 range <- 0.2 nu <- 0.8 kappa <- sqrt(8 * nu) / range op <- matern.operators(   mesh = mesh_2d, nu = nu,   kappa = kappa, sigma = sigma, m = 2 ) u <- simulate(op) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 y <- A %*% u + rnorm(m) * sigma.e Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d) st.dat <- inla.stack(   data = list(y = as.vector(y)),   A = Abar,   effects = mesh.index ) rspde_model <- rspde.matern(   mesh = mesh_2d,   nu.upper.bound = 2 ) f <- y ~ -1 + f(field, model = rspde_model) rspde_fit <- inla(f,   data = inla.stack.data(st.dat),   family = \"gaussian\",   control.predictor =     list(A = inla.stack.A(st.dat)) ) result <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result) } #>             mean        sd 0.025quant 0.5quant 0.975quant     mode #> std.dev 0.815661 0.0627635   0.682994 0.820796   0.924411 0.843027 #> range   0.150870 0.0283591   0.102946 0.148207   0.214006 0.142815 #> nu      1.353250 0.3673680   0.676298 1.368270   1.938220 1.748470 #devel.tag"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":null,"dir":"Reference","previous_headings":"","what":"Matern rSPDE model object for INLA — rspde.matern","title":"Matern rSPDE model object for INLA — rspde.matern","text":"Creates INLA object stationary Matern model general smoothness parameter.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matern rSPDE model object for INLA — rspde.matern","text":"","code":"rspde.matern(   mesh,   nu.upper.bound = 4,   rspde.order = 2,   nu = NULL,   B.sigma = matrix(c(0, 1, 0), 1, 3),   B.range = matrix(c(0, 0, 1), 1, 3),   parameterization = c(\"matern\", \"spde\", \"matern2\"),   B.tau = matrix(c(0, 1, 0), 1, 3),   B.kappa = matrix(c(0, 0, 1), 1, 3),   start.nu = NULL,   start.theta = NULL,   prior.nu = NULL,   theta.prior.mean = NULL,   theta.prior.prec = 0.1,   prior.std.dev.nominal = 1,   prior.range.nominal = NULL,   prior.kappa.mean = NULL,   prior.tau.mean = NULL,   start.lstd.dev = NULL,   start.lrange = NULL,   start.ltau = NULL,   start.lkappa = NULL,   prior.theta.param = c(\"theta\", \"spde\"),   prior.nu.dist = c(\"beta\", \"lognormal\"),   nu.prec.inc = 1,   type.rational.approx = c(\"chebfun\", \"brasil\", \"chebfunLB\"),   debug = FALSE,   shared_lib = \"detect\",   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matern rSPDE model object for INLA — rspde.matern","text":"mesh mesh build model. can inla.mesh inla.mesh.1d object. Otherwise, list containing elements d, dimension, C, mass matrix, G, stiffness matrix. nu.upper.bound Upper bound smoothness parameter. rspde.order order covariance-based rational SPDE approach. nu nu set parameter, nu kept fixed estimated. nu NULL, estimated. B.sigma Matrix specification log-linear model \\(\\sigma\\) ('matern' parameterization) \\(\\sigma^2\\) ('matern2' parameterization). used parameterization = 'matern' parameterization = 'matern2'. B.range Matrix specification log-linear model \\(\\rho\\), range-like parameter (exactly range parameter stationary case). used parameterization = 'matern' parameterization = 'matern2'. parameterization parameterization use? matern uses range, std. deviation nu (smoothness). spde uses kappa, tau nu (smoothness). matern2 uses range-like (1/kappa), variance nu (smoothness). default matern. B.tau Matrix specification log-linear model \\(\\tau\\). used parameterization = 'spde'. B.kappa Matrix specification log-linear model \\(\\kappa\\). used parameterization = 'spde'. start.nu Starting value nu. start.theta Starting values model parameters. stationary case, parameterization='matern', theta[1] std.dev theta[2] range parameter. parameterization = 'spde', theta[1] tau theta[2] kappa. prior.nu list containing elements mean prec beta distribution, loglocation logscale truncated lognormal distribution. loglocation stands location parameter truncated lognormal distribution log scale. prec stands precision beta distribution. logscale stands scale truncated lognormal distribution log scale. Check details . theta.prior.mean vector mean priors theta. theta.prior.prec precision matrix prior theta. prior.std.dev.nominal Prior std. deviation used priors starting values. prior.range.nominal Prior range used priors starting values. prior.kappa.mean Prior kappa used priors starting values. prior.tau.mean Prior tau used priors starting values. start.lstd.dev Starting value log std. deviation. used start.ltau non-null. used stationary case parameterization = 'matern'. start.lrange Starting value log range. used start.lkappa non-null. used stationary case parameterization = 'matern'. start.ltau Starting value log tau. used stationary case parameterization = 'spde'. start.lkappa Starting value log kappa. used stationary case parameterization = 'spde'. prior.theta.param lognormal prior theta SPDE parameters (tau kappa stationary case)? prior.nu.dist distribution smoothness parameter. current options \"beta\" \"lognormal\". default \"lognormal\". nu.prec.inc Amount increase precision beta prior distribution. Check details . type.rational.approx type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\". debug INLA debug argument shared_lib shared lib use cgeneric implementation? \"detect\", check shared lib exists locally, case use . Otherwise use INLA's shared library. \"INLA\", use shared lib INLA's installation. 'rSPDE', use local installation (work installation CRAN). Otherwise, can directly supply path .(.dll) file. ... used internally. prior.kappa list containing elements meanlog sdlog, , mean standard deviation log scale. prior.tau list containing elements meanlog sdlog, , mean standard deviation log scale. prior.range list containing elements meanlog sdlog, , mean standard deviation log scale. used prior.kappa non-null. prior.std.dev list containing elements meanlog sdlog, , mean standard deviation log scale. used prior.tau non-null.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matern rSPDE model object for INLA — rspde.matern","text":"INLA model.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Precision matrix of the covariance-based rational approximation of\nstationary Gaussian Matern random fields — rspde.matern.precision","title":"Precision matrix of the covariance-based rational approximation of\nstationary Gaussian Matern random fields — rspde.matern.precision","text":"rspde.matern.precision used computing precision matrix covariance-based rational SPDE approximation stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^(\\nu-1)\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h)$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Precision matrix of the covariance-based rational approximation of\nstationary Gaussian Matern random fields — rspde.matern.precision","text":"","code":"rspde.matern.precision(   kappa,   nu,   tau = NULL,   sigma = NULL,   rspde.order,   dim,   fem_mesh_matrices,   only_fractional = FALSE,   return_block_list = FALSE,   type_rational_approx = \"chebfun\" )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Precision matrix of the covariance-based rational approximation of\nstationary Gaussian Matern random fields — rspde.matern.precision","text":"kappa Range parameter covariance function. nu Shape parameter covariance function. tau Scale parameter covariance function. sigma provided, tau provided. sigma Standard deviation covariance function. tau provided, sigma provided. rspde.order order rational approximation dim dimension domain fem_mesh_matrices list containing FEM-related matrices. list contain elements c0, g1, g2, g3, etc. only_fractional Logical. fractional-order part precision matrix returned? return_block_list Logical. type = \"covariance\", block parts precision matrix returned separately list? type_rational_approx type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Precision matrix of the covariance-based rational approximation of\nstationary Gaussian Matern random fields — rspde.matern.precision","text":"precision matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Precision matrix of the covariance-based rational approximation of\nstationary Gaussian Matern random fields — rspde.matern.precision","text":"","code":"set.seed(123) nobs <- 101 x <- seq(from = 0, to = 1, length.out = nobs) fem <- rSPDE.fem1d(x) kappa <- 40 sigma <- 1 d <- 1 nu <- 2.6 tau <- sqrt(gamma(nu) / (kappa^(2 * nu) * (4 * pi)^(d / 2) * gamma(nu + d / 2))) op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu, kappa = kappa, sigma = sigma,   d = 1, m = 2, compute_higher_order = TRUE ) v <- t(rSPDE.A1d(x, 0.5)) c.true <- matern.covariance(abs(x - 0.5), kappa, nu, sigma) Q <- rspde.matern.precision(   kappa = kappa, nu = nu, tau = tau, rspde.order = 2, d = 1,   fem_mesh_matrices = op_cov$fem_mesh_matrices ) A <- Diagonal(nobs) Abar <- cbind(A, A, A) w <- rbind(v, v, v) c.approx_cov <- (Abar) %*% solve(Q, w)  # plot the result and compare with the true Matern covariance plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma),   type = \"l\", ylab = \"C(h)\",   xlab = \"h\", main = \"Matern covariance and rational approximations\" ) lines(x, c.approx_cov, col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":null,"dir":"Reference","previous_headings":"","what":"Precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer","title":"Precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer","text":"rspde.matern.precision.integer.opt used computing precision matrix stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^(\\nu-1)\\Gamma(\\nu)} (\\kappa h)^\\nu K_\\nu(\\kappa h)$$, \\(\\alpha = \\nu + d/2\\) natural number.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer","text":"","code":"rspde.matern.precision.integer(   kappa,   nu,   tau = NULL,   sigma = NULL,   dim,   fem_mesh_matrices )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer","text":"kappa Range parameter covariance function. nu Shape parameter covariance function. tau Scale parameter covariance function. sigma Standard deviation covariance function. tau provided, sigma provided. dim dimension domain fem_mesh_matrices list containing FEM-related matrices. list contain elements c0, g1, g2, g3, etc.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer","text":"precision matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer","text":"","code":"set.seed(123) nobs <- 101 x <- seq(from = 0, to = 1, length.out = nobs) fem <- rSPDE.fem1d(x) kappa <- 40 sigma <- 1 d <- 1 nu <- 0.5 tau <- sqrt(gamma(nu) / (kappa^(2 * nu) * (4 * pi)^(d / 2) * gamma(nu + d / 2))) op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu, kappa = kappa, sigma = sigma,   d = 1, m = 2 ) v <- t(rSPDE.A1d(x, 0.5)) c.true <- matern.covariance(abs(x - 0.5), kappa, nu, sigma) Q <- rspde.matern.precision.integer(   kappa = kappa, nu = nu, tau = tau, d = 1,   fem_mesh_matrices = op_cov$fem_mesh_matrices ) A <- Diagonal(nobs) c.approx_cov <- A %*% solve(Q, v)  # plot the result and compare with the true Matern covariance plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma),   type = \"l\", ylab = \"C(h)\",   xlab = \"h\", main = \"Matern covariance and rational approximations\" ) lines(x, c.approx_cov, col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.opt.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimized precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer.opt","title":"Optimized precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer.opt","text":"rspde.matern.precision.integer.opt used computing optimized version precision matrix stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h),$$ \\(\\alpha = \\nu + d/2\\) natural number.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.opt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimized precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer.opt","text":"","code":"rspde.matern.precision.integer.opt(   kappa,   nu,   tau,   d,   fem_matrices,   graph = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.opt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimized precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer.opt","text":"kappa Range parameter covariance function. nu Shape parameter covariance function. tau Scale parameter covariance function. d dimension domain fem_matrices list containing FEM-related matrices. list contain elements C, G, G_2, G_3, etc. graph sparsity graph matrices. NULL, vector elements returned, non-NULL, sparse matrix returned.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.opt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimized precision matrix of stationary Gaussian Matern\nrandom fields with integer covariance exponent — rspde.matern.precision.integer.opt","text":"precision matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.opt.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimized precision matrix of the covariance-based rational\napproximation — rspde.matern.precision.opt","title":"Optimized precision matrix of the covariance-based rational\napproximation — rspde.matern.precision.opt","text":"rspde.matern.precision used computing optimized version precision matrix covariance-based rational SPDE approximation stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h).$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.opt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimized precision matrix of the covariance-based rational\napproximation — rspde.matern.precision.opt","text":"","code":"rspde.matern.precision.opt(   kappa,   nu,   tau,   rspde.order,   dim,   fem_matrices,   graph = NULL,   sharp,   type_rational_approx )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.opt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimized precision matrix of the covariance-based rational\napproximation — rspde.matern.precision.opt","text":"kappa Range parameter covariance function. nu Shape parameter covariance function. tau Scale parameter covariance function. rspde.order order rational approximation dim dimension domain fem_matrices list containing FEM-related matrices. list contain elements C, G, G_2, G_3, etc. graph sparsity graph matrices. NULL, vector elements returned, non-NULL, sparse matrix returned. sharp sparsity graph correct sparsity (costs perform sparsity analysis) upper bound sparsity? type_rational_approx type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.opt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimized precision matrix of the covariance-based rational\napproximation — rspde.matern.precision.opt","text":"precision matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a lattice projection to/from an inla.mesh for\nrSPDE objects — rspde.mesh.project","title":"Calculate a lattice projection to/from an inla.mesh for\nrSPDE objects — rspde.mesh.project","text":"Calculate lattice projection /inla.mesh rSPDE objects","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a lattice projection to/from an inla.mesh for\nrSPDE objects — rspde.mesh.project","text":"","code":"rspde.mesh.project(...)  rspde.mesh.projector(   mesh,   nu = NULL,   rspde.order = 2,   loc = NULL,   lattice = NULL,   xlim = NULL,   ylim = NULL,   dims = c(100, 100),   projection = NULL,   ... )  # S3 method for inla.mesh rspde.mesh.project(   mesh,   loc = NULL,   field = NULL,   rspde.order = 2,   nu = NULL,   ... )  # S3 method for rspde.mesh.projector rspde.mesh.project(projector, field, ...)  # S3 method for inla.mesh.1d rspde.mesh.project(mesh, loc, field = NULL, rspde.order = 2, nu = NULL, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a lattice projection to/from an inla.mesh for\nrSPDE objects — rspde.mesh.project","text":"... Additional parameters. mesh inla.mesh inla.mesh.1d object. nu smoothness parameter. NULL, assumed nu estimated. rspde.order order rational approximation. loc Projection locations. Can matrix SpatialPoints SpatialPointsDataFrame object. lattice inla.mesh.lattice object. xlim X-axis limits lattice. R2 meshes, defaults covering domain. ylim Y-axis limits lattice. R2 meshes, defaults covering domain. dims Lattice dimensions. projection One c(\"default\", \"longlat\", \"longsinlat\", \"mollweide\"). field Basis function weights, one per mesh basis function, describing function evaluated projection locations. projector rspde.mesh.projector object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a lattice projection to/from an inla.mesh for\nrSPDE objects — rspde.mesh.project","text":"list projection information rspde.mesh.project. rspde.mesh.projector(mesh, ...), rspde.mesh.projector object. rspde.mesh.project(projector, field, ...), field projected mesh onto locations given projector object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate a lattice projection to/from an inla.mesh for\nrSPDE objects — rspde.mesh.project","text":"function built upon inla.mesh.project inla.mesh.projector functions INLA.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.metric_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Matern rSPDE model object for metric graphs in INLA — rspde.metric_graph","title":"Matern rSPDE model object for metric graphs in INLA — rspde.metric_graph","text":"Creates INLA object stationary Matern model metric graph general smoothness parameter.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.metric_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matern rSPDE model object for metric graphs in INLA — rspde.metric_graph","text":"","code":"rspde.metric_graph(   graph_obj,   h = NULL,   nu.upper.bound = 2,   rspde.order = 2,   nu = NULL,   debug = FALSE,   B.sigma = matrix(c(0, 1, 0), 1, 3),   B.range = matrix(c(0, 0, 1), 1, 3),   parameterization = c(\"matern\", \"spde\"),   B.tau = matrix(c(0, 1, 0), 1, 3),   B.kappa = matrix(c(0, 0, 1), 1, 3),   start.nu = NULL,   start.theta = NULL,   prior.nu = NULL,   theta.prior.mean = NULL,   theta.prior.prec = 0.1,   prior.std.dev.nominal = 1,   prior.range.nominal = NULL,   prior.kappa.mean = NULL,   prior.tau.mean = NULL,   start.lstd.dev = NULL,   start.lrange = NULL,   start.ltau = NULL,   start.lkappa = NULL,   prior.theta.param = c(\"theta\", \"spde\"),   prior.nu.dist = c(\"lognormal\", \"beta\"),   nu.prec.inc = 1,   type.rational.approx = c(\"chebfun\", \"brasil\", \"chebfunLB\"),   shared_lib = \"INLA\" )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.metric_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matern rSPDE model object for metric graphs in INLA — rspde.metric_graph","text":"graph_obj graph object build model. Needs class metric_graph. built mesh. mesh built, one built using h=0.01 default. h width mesh case mesh built. nu.upper.bound Upper bound smoothness parameter. rspde.order order covariance-based rational SPDE approach. nu nu set parameter, nu kept fixed estimated. nu NULL, estimated. debug INLA debug argument B.sigma Matrix specification log-linear model \\(\\sigma\\). used parameterization = 'matern'. B.range Matrix specification log-linear model \\(\\rho\\), range-like parameter (exactly range parameter stationary case). used parameterization = 'matern'. parameterization parameterization use? matern uses range, std. deviation nu (smoothness). spde uses kappa, tau nu (smoothness). default matern. B.tau Matrix specification log-linear model \\(\\tau\\). used parameterization = 'spde'. B.kappa Matrix specification log-linear model \\(\\kappa\\). used parameterization = 'spde'. start.nu Starting value nu. start.theta Starting values model parameters. stationary case, parameterization='matern', theta[1] std.dev theta[2] range parameter. parameterization = 'spde', theta[1] tau theta[2] kappa. prior.nu list containing elements mean prec beta distribution, loglocation logscale truncated lognormal distribution. loglocation stands location parameter truncated lognormal distribution log scale. prec stands precision beta distribution. logscale stands scale truncated lognormal distribution log scale. Check details . theta.prior.mean vector mean priors theta. theta.prior.prec precision matrix prior theta. prior.std.dev.nominal Prior std. deviation used priors starting values. prior.range.nominal Prior range used priors starting values. prior.kappa.mean Prior kappa used priors starting values. prior.tau.mean Prior tau used priors starting values. start.lstd.dev Starting value log std. deviation. used start.ltau non-null. used stationary case parameterization = 'matern'. start.lrange Starting value log range. used start.lkappa non-null. used stationary case parameterization = 'matern'. start.ltau Starting value log tau. used stationary case parameterization = 'spde'. start.lkappa Starting value log kappa. used stationary case parameterization = 'spde'. prior.theta.param lognormal prior theta SPDE parameters (tau kappa stationary case)? prior.nu.dist distribution smoothness parameter. current options \"beta\" \"lognormal\". default \"lognormal\". nu.prec.inc Amount increase precision beta prior distribution. Check details . type.rational.approx type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\". shared_lib shared lib use cgeneric implementation? \"INLA\", use shared lib INLA's installation. 'rSPDE', use local installation (work installation CRAN). Otherwise, can directly supply path .(.dll) file. prior.kappa list containing elements meanlog sdlog, , mean standard deviation log scale. prior.tau list containing elements meanlog sdlog, , mean standard deviation log scale. prior.range list containing elements meanlog sdlog, , mean standard deviation log scale. used prior.kappa non-null. prior.std.dev list containing elements meanlog sdlog, , mean standard deviation log scale. used prior.tau non-null.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.metric_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matern rSPDE model object for metric graphs in INLA — rspde.metric_graph","text":"INLA model.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":null,"dir":"Reference","previous_headings":"","what":"rSPDE result extraction from INLA estimation results — rspde.result","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"Extract field parameter values distributions rspde effect inla result object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"","code":"rspde.result(inla, name, rspde, compute.summary = TRUE)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"inla inla object obtained call inla(). name character string name rSPDE effect inla formula. rspde inla_rspde object used effect inla formula. compute.summary summary computed?","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"model fitted matern parameterization (default), returns list containing: marginals.range Marginal densities range parameter marginals.log.range Marginal densities log(range) marginals.std.dev Marginal densities std. deviation marginals.log.std.dev Marginal densities log(std. deviation) marginals.values Marginal densities field values summary.log.range Summary statistics log(range) summary.log.std.dev Summary statistics log(std. deviation) summary.values Summary statistics field values compute.summary TRUE, list also contain summary.kappa Summary statistics kappa summary.tau Summary statistics tau model fitted spde parameterization, returns list containing: marginals.kappa Marginal densities kappa marginals.log.kappa Marginal densities log(kappa) marginals.log.tau Marginal densities log(tau) marginals.tau Marginal densities tau marginals.values Marginal densities field values summary.log.kappa Summary statistics log(kappa) summary.log.tau Summary statistics log(tau) summary.values Summary statistics field values compute.summary TRUE, list also contain summary.kappa Summary statistics kappa summary.tau Summary statistics tau cases, nu estimated, list also contain marginals.nu Marginal densities nu nu estimated beta prior used, list also contain marginals.logit.nu Marginal densities logit(nu) summary.logit.nu Marginal densities logit(nu) nu estimated truncated lognormal prior used, list also contain marginals.log.nu Marginal densities log(nu) summary.log.nu Marginal densities log(nu) nu estimated compute.summary TRUE, list also contain summary.nu Summary statistics nu","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"","code":"#devel version if (requireNamespace(\"INLA\", quietly = TRUE)){ library(INLA)  set.seed(123)  m <- 100 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   max.edge = c(0.1, 0.5) ) sigma <- 1 range <- 0.2 nu <- 0.8 kappa <- sqrt(8 * nu) / range op <- matern.operators(   mesh = mesh_2d, nu = nu,   kappa = kappa, sigma = sigma, m = 2 ) u <- simulate(op) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 y <- A %*% u + rnorm(m) * sigma.e Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d) st.dat <- inla.stack(   data = list(y = as.vector(y)),   A = Abar,   effects = mesh.index ) rspde_model <- rspde.matern(   mesh = mesh_2d,   nu.upper.bound = 2 ) f <- y ~ -1 + f(field, model = rspde_model) rspde_fit <- inla(f,   data = inla.stack.data(st.dat),   family = \"gaussian\",   control.predictor =     list(A = inla.stack.A(st.dat)) ) result <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result) } #>             mean        sd 0.025quant 0.5quant 0.975quant     mode #> std.dev 0.810342 0.0598560   0.681332 0.816471   0.909826 0.843767 #> range   0.150642 0.0281085   0.103007 0.148042   0.213082 0.142797 #> nu      1.361710 0.3550100   0.715373 1.373140   1.934830 1.709370 #devel.tag"},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation of a fractional SPDE using the\ncovariance-based rational SPDE approximation — simulate.CBrSPDEobj","title":"Simulation of a fractional SPDE using the\ncovariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"function samples Gaussian random field based using covariance-based rational SPDE approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation of a fractional SPDE using the\ncovariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"","code":"# S3 method for CBrSPDEobj simulate(   object,   nsim = 1,   seed = NULL,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_range = NULL,   user_tau = NULL,   user_theta = NULL,   user_m = NULL,   pivot = TRUE,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation of a fractional SPDE using the\ncovariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"object covariance-based rational SPDE approximation, computed using matern.operators() nsim number simulations. seed object specifying random number generator initialized (‘seeded’). user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_range non-null, update range parameter covariance function. user_tau non-null, update parameter tau. user_theta non-stationary models. non-null, update vector parameters. user_m non-null, update order rational approximation, needs positive integer. pivot pivoting used Cholesky decompositions? Default TRUE ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation of a fractional SPDE using the\ncovariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"matrix n samples columns.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation of a fractional SPDE using the\ncovariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"","code":"# Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi)^(1 / 2) * gamma(nu + 1 / 2))) op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  # Sample the model and plot the result Y <- simulate(op_cov) plot(x, Y, type = \"l\", ylab = \"u(x)\", xlab = \"x\")"},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate.rSPDEobj","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate.rSPDEobj","text":"function samples Gaussian random field based pre-computed rational SPDE approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate.rSPDEobj","text":"","code":"# S3 method for rSPDEobj simulate(object, nsim = 1, seed = NULL, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate.rSPDEobj","text":"object rational SPDE approximation, computed using fractional.operators(), matern.operators(), spde.matern.operators(). nsim number simulations. seed object specifying random number generator initialized (‘seeded’). ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate.rSPDEobj","text":"matrix n samples columns.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate.rSPDEobj","text":"","code":"# Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation op <- matern.operators(   kappa = kappa, sigma = sigma,   nu = nu, G = fem$G, C = fem$C, d = 1 )  # Sample the model and plot the result Y <- simulate(op) plot(x, Y, type = \"l\", ylab = \"u(x)\", xlab = \"x\")"},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","text":"function evaluates log-likelihood function observations Gaussian process defined solution SPDE $$(\\kappa(s) - \\Delta)^\\beta (\\tau(s)u(s)) = W.$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","text":"","code":"spde.matern.loglike(   object,   Y,   A,   sigma.e,   mu = 0,   user_nu = NULL,   user_kappa = NULL,   user_tau = NULL,   user_theta = NULL,   user_m = NULL,   pivot = TRUE )"},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","text":"object rational SPDE approximation, computed using spde.matern.operators() Y observations, either vector matrix columns correspond independent replicates observations. observation matrix links measurement location finite element basis. sigma.e non-null, standard deviation measurement noise kept fixed returned likelihood. mu Expectation vector latent field (default = 0). user_nu non-null, shape parameter kept fixed returned likelihood. user_kappa non-null, updates range parameter. user_tau non-null, updates parameter tau. user_theta non-null, updates parameter theta (connects tau kappa model matrices object). user_m non-null, update order rational approximation, needs positive integer. pivot pivoting used Cholesky decompositions? Default TRUE","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","text":"log-likelihood value.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","text":"observations assumed generated \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables. latent model approximated using rational approximation fractional SPDE model.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model\nusing a rational SPDE approximation — spde.matern.loglike","text":"","code":"# this example illustrates how the function can be used for maximum # likelihood estimation # Sample a Gaussian Matern process on R using a rational approximation sigma.e <- 0.1 n.rep <- 10 n.obs <- 100 n.x <- 51 # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x) tau <- rep(0.5, n.x) nu <- 0.8 kappa <- rep(1, n.x) # compute rational approximation op <- spde.matern.operators(   kappa = kappa, tau = tau, nu = nu,   G = fem$G, C = fem$C, d = 1 ) # Sample the model u <- simulate(op, n.rep) # Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs * n.rep) dim(noise) <- c(n.obs, n.rep) Y <- as.matrix(A %*% u + sigma.e * noise) # define negative likelihood function for optimization using matern.loglike mlik <- function(theta) {   return(-spde.matern.loglike(op, Y, A, sigma.e = exp(theta[4]),                                  user_nu = exp(theta[3]),                                  user_kappa = exp(theta[2]),                                  user_tau = exp(theta[1]),                                  pivot = TRUE)) } #' #The parameters can now be estimated by minimizing mlik with optim # \\donttest{ # Choose some reasonable starting values depending on the size of the domain theta0 <- log(c(1 / sqrt(var(c(Y))), sqrt(8), 0.9, 0.01)) # run estimation and display the results theta <- optim(theta0, mlik) print(data.frame(   tau = c(tau[1], exp(theta$par[1])), kappa = c(kappa[1], exp(theta$par[2])),   nu = c(nu, exp(theta$par[3])), sigma.e = c(sigma.e, exp(theta$par[4])),   row.names = c(\"Truth\", \"Estimates\") )) #>                tau    kappa        nu    sigma.e #> Truth     0.500000 1.000000 0.8000000 0.10000000 #> Estimates 0.526797 0.828407 0.7635583 0.09516762 # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"spde.matern.operators used computing rational SPDE approximation Gaussian random fields \\(R^d\\) defined solution SPDE $$(\\kappa(s) - \\Delta)^\\beta (\\tau(s)u(s)) = W.$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"","code":"spde.matern.operators(   kappa = NULL,   tau = NULL,   theta = NULL,   B.tau = matrix(c(0, 1, 0), 1, 3),   B.kappa = matrix(c(0, 0, 1), 1, 3),   B.sigma = matrix(c(0, 1, 0), 1, 3),   B.range = matrix(c(0, 0, 1), 1, 3),   nu,   parameterization = c(\"matern\", \"spde\"),   G = NULL,   C = NULL,   d = NULL,   mesh = NULL,   m = 1,   type = c(\"covariance\", \"operator\"),   type_rational_approximation = c(\"chebfun\", \"brasil\", \"chebfunLB\") )"},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"kappa Vector , possibly spatially varying, range parameter evaluated locations mesh used finite element discretization SPDE. tau Vector , possibly spatially varying, precision parameter evaluated locations mesh used finite element discretization SPDE. theta Theta parameter connects B.tau B.kappa tau kappa log-linear regression, case parameterization spde, connects B.sigma B.range tau kappa case parameterization matern. B.tau Matrix specification log-linear model \\(\\tau\\). used parameterization = 'spde'. B.kappa Matrix specification log-linear model \\(\\kappa\\). used parameterization = 'spde'. B.sigma Matrix specification log-linear model \\(\\sigma\\). used parameterization = 'matern'. B.range Matrix specification log-linear model \\(\\rho\\), range-like parameter (exactly range parameter stationary case). used parameterization = 'matern'. nu Shape parameter covariance function, related \\(\\beta\\) equation \\(\\beta = (\\nu + d/2)/2\\). parameterization parameterization use? matern uses range, std. deviation nu (smoothness). spde uses kappa, tau nu (smoothness). default matern. G stiffness matrix finite element discretization domain interest. C mass matrix finite element discretization domain interest. d dimension domain. need given mesh used. mesh optional inla mesh. d, C G must given mesh given. m order rational approximation, needs positive integer. default value 1. type type rational approximation. options \"covariance\" \"operator\". default \"covariance\". type_rational_approximation type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"spde.matern.operators returns object class \"rSPDEobj. object contains quantities listed output fractional.operators() well smoothness parameter \\(\\nu\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"approximation based rational approximation fractional operator \\((\\kappa(s)^2 -\\Delta)^\\beta\\), \\(\\beta = (\\nu + d/2)/2\\). results approximate model form $$P_l u(s) = P_r W,$$ \\(P_j = p_j(L)\\) non-fractional operators defined terms polynomials \\(p_j\\) \\(j=l,r\\). order \\(p_r\\) given m order \\(p_l\\) \\(m + m_\\beta\\) \\(m_\\beta\\) integer part \\(\\beta\\) \\(\\beta>1\\) \\(m_\\beta = 1\\) otherwise. discrete approximation can written \\(u = P_r x\\) \\(x \\sim N(0,Q^{-1})\\) \\(Q = P_l^T C^{-1} P_l\\). Note matrices \\(P_r\\) \\(Q\\) may ill-conditioned \\(m>1\\). case, metehods operator.operations() used operations involving matrices, since methods numerically stable.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"","code":"# Sample non-stationary Matern field on R tau <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # define a non-stationary range parameter kappa <- seq(from = 2, to = 20, length.out = length(x))  # compute rational approximation op <- spde.matern.operators(   kappa = kappa, tau = tau, nu = nu,   G = fem$G, C = fem$C, d = 1 )  # sample the field u <- simulate(op)  # plot the sample plot(x, u, type = \"l\", ylab = \"u(s)\", xlab = \"s\")"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise CBrSPDE objects — summary.CBrSPDEobj","title":"Summarise CBrSPDE objects — summary.CBrSPDEobj","text":"Summary method class \"CBrSPDEobj\"","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise CBrSPDE objects — summary.CBrSPDEobj","text":"","code":"# S3 method for CBrSPDEobj summary(object, ...)  # S3 method for summary.CBrSPDEobj print(x, ...)  # S3 method for CBrSPDEobj print(x, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise CBrSPDE objects — summary.CBrSPDEobj","text":"object object class \"CBrSPDEobj\", usually, result call matern.operators(). ... arguments passed methods. x object class \"summary.CBrSPDEobj\", usually, result call summary.CBrSPDEobj().","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise CBrSPDE objects — summary.CBrSPDEobj","text":"","code":"# Compute the covariance-based rational approximation of a # Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2 * nu) * (4 * pi)^(1 / 2) * gamma(nu + 1 / 2))) op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 )  op_cov #> Type of approximation:  Covariance-Based Matern SPDE Approximation  #> Type of rational approximation:  chebfun  #> Parameters of covariance function: kappa =  10 , sigma =  1 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101  #> Stationary Model"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise rSPDE objects — summary.rSPDEobj","title":"Summarise rSPDE objects — summary.rSPDEobj","text":"Summary method class \"rSPDEobj\"","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise rSPDE objects — summary.rSPDEobj","text":"","code":"# S3 method for rSPDEobj summary(object, ...)  # S3 method for summary.rSPDEobj print(x, ...)  # S3 method for rSPDEobj print(x, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise rSPDE objects — summary.rSPDEobj","text":"object object class \"rSPDEobj\", usually, result call fractional.operators(), matern.operators(), spde.matern.operators(). ... arguments passed methods. x object class \"summary.rSPDEobj\", usually, result call summary.rSPDEobj().","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde_result object — summary.rspde_result","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde_result object — summary.rspde_result","text":"Summary posteriors rSPDE field parameters original scales.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde_result object — summary.rspde_result","text":"","code":"# S3 method for rspde_result summary(object, digits = 6, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde_result object — summary.rspde_result","text":"object rspde_result object. digits integer, used number formatting signif() ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde_result object — summary.rspde_result","text":"Returns data.frame containing summary.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary for posteriors of field parameters for an inla_rspde\nmodel from a rspde_result object — summary.rspde_result","text":"","code":"#devel version if (requireNamespace(\"INLA\", quietly = TRUE)){ library(INLA)  set.seed(123)  m <- 100 loc_2d_mesh <- matrix(runif(m * 2), m, 2) mesh_2d <- inla.mesh.2d(   loc = loc_2d_mesh,   cutoff = 0.05,   max.edge = c(0.1, 0.5) ) sigma <- 1 range <- 0.2 nu <- 0.8 kappa <- sqrt(8 * nu) / range op <- matern.operators(   mesh = mesh_2d, nu = nu,   kappa = kappa, sigma = sigma, m = 2 ) u <- simulate(op) A <- inla.spde.make.A(   mesh = mesh_2d,   loc = loc_2d_mesh ) sigma.e <- 0.1 y <- A %*% u + rnorm(m) * sigma.e Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d) st.dat <- inla.stack(   data = list(y = as.vector(y)),   A = Abar,   effects = mesh.index ) rspde_model <- rspde.matern(   mesh = mesh_2d,   nu.upper.bound = 2 ) f <- y ~ -1 + f(field, model = rspde_model) rspde_fit <- inla(f,   data = inla.stack.data(st.dat),   family = \"gaussian\",   control.predictor =     list(A = inla.stack.A(st.dat)) ) result <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result) } #>             mean        sd 0.025quant 0.5quant 0.975quant     mode #> std.dev 0.809925 0.0596742   0.681127 0.816123   0.908777 0.843788 #> range   0.149956 0.0275966   0.102807 0.147590   0.210859 0.142802 #> nu      1.363350 0.3544970   0.718174 1.374800   1.935270 1.713390 #devel.tag"},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"Function change parameters CBrSPDEobj object","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"","code":"# S3 method for CBrSPDEobj update(   object,   user_nu = NULL,   user_kappa = NULL,   user_tau = NULL,   user_sigma = NULL,   user_range = NULL,   user_theta = NULL,   user_m = NULL,   compute_higher_order = object$higher_order,   type_rational_approximation = object$type_rational_approximation,   return_block_list = object$return_block_list,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"object covariance-based rational SPDE approximation, computed using matern.operators() user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_tau non-null, update parameter tau. user_sigma non-null, update standard deviation covariance function. user_range non-null, update range parameter covariance function. user_theta non-stationary models. non-null, update vector parameters. user_m non-null, update order rational approximation, needs positive integer. compute_higher_order Logical. higher order finite element matrices computed? type_rational_approximation type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\". return_block_list Logical. type = \"covariance\", block parts precision matrix returned separately list? ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"returns object class \"CBrSPDEobj. object contains quantities listed output matern.operators().","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"","code":"# Compute the covariance-based rational approximation of a # Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 op_cov <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2 ) op_cov #> Type of approximation:  Covariance-Based Matern SPDE Approximation  #> Type of rational approximation:  chebfun  #> Parameters of covariance function: kappa =  10 , sigma =  1 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101  #> Stationary Model  # Update the range parameter of the model: op_cov <- update(op_cov, user_kappa = 20) op_cov #> Type of approximation:  Covariance-Based Matern SPDE Approximation  #> Type of rational approximation:  chebfun  #> Parameters of covariance function: kappa =  20 , sigma =  0.5743492 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101  #> Stationary Model"},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Update parameters of rSPDEobj objects — update.rSPDEobj","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"Function change parameters rSPDEobj object","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"","code":"# S3 method for rSPDEobj update(   object,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_range = NULL,   user_tau = NULL,   user_theta = NULL,   user_m = NULL,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"object operator-based rational SPDE approximation, computed using matern.operators() type=\"operator\" user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_range non-null, update range parameter covariance function. user_tau non-null, update parameter tau. user_theta non-null, update parameter theta, connects tau kappa model matrices. user_m non-null, update order rational approximation, needs positive integer. ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"returns object class \"rSPDEobj. object contains quantities listed output matern.operators().","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"","code":"# Compute the operator-based rational approximation of a # Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  # create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  # compute rational approximation of covariance function at 0.5 op <- matern.operators(   C = fem$C, G = fem$G, nu = nu,   kappa = kappa, sigma = sigma, d = 1, m = 2, type = \"operator\" ) op #> Type of approximation:  Matern approximation  #> Parameters of covariance function: kappa =  10 , sigma =  1 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101  #> Stationary Model  # Update the range parameter of the model: op <- update(op, user_kappa = 20) op #> Type of approximation:  Matern approximation  #> Parameters of covariance function: kappa =  20 , sigma =  0.5743492 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101  #> Stationary Model"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-220","dir":"Changelog","previous_headings":"","what":"rSPDE 2.2.0","title":"rSPDE 2.2.0","text":"CRAN release: 2023-04-12 Adding new parameterization (variance range-like parameter) Posterior sampling predict method. Added cross_validation function several scoring rules implemented (MSE, CRPS, SCRPS, DSS) based inlabru implementation rational SPDE approach.","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-210","dir":"Changelog","previous_headings":"","what":"rSPDE 2.1.0","title":"rSPDE 2.1.0","text":"CRAN release: 2023-01-19 Expanded parameterization options matern.operators spde.matern.operators, along associated functions. Implementation precision method inla_rspde objects. Implementation covariance-based spde.matern.operators function associated functions. Adjusts compatibility forthcoming MetricGraph package.","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-200","dir":"Changelog","previous_headings":"","what":"rSPDE 2.0.0","title":"rSPDE 2.0.0","text":"Added cgeneric versions nonstationary models Added support metric graphs (depends MetricGraph package) Added cgeneric versions stationary models Replaced rgeneric models cgeneric counterparts Added new parameterization (range std. dev) Created new method gg_df help posterior plotting ggplot2","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-120","dir":"Changelog","previous_headings":"","what":"rSPDE 1.2.0","title":"rSPDE 1.2.0","text":"CRAN release: 2022-09-16 Added inlabru interface Added “rational.order” “rational.type” functions Added BRASIL rational approximation Improved covariance-based operator objects Improved log-likelihood computation Created 2d folded Matern different boundary conditions Implemented different boundary conditions 1d folded Matern","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-111","dir":"Changelog","previous_headings":"","what":"rSPDE 1.1.1","title":"rSPDE 1.1.1","text":"CRAN release: 2022-01-14 Adjusts donttest examples CRAN","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-110","dir":"Changelog","previous_headings":"","what":"rSPDE 1.1.0","title":"rSPDE 1.1.0","text":"Minor typos vignettes man pages corrected examples changed improve numerical stability","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-100","dir":"Changelog","previous_headings":"","what":"rSPDE 1.0.0","title":"rSPDE 1.0.0","text":"CRAN release: 2021-12-13 Implementation covariance-based rational approximation stationary Matérn models R-INLA implementation rational SPDE approach Added introduction rSPDE vignette previous vignette updated became operator-based rational approximation vignette Added vignette R-INLA implementation SPDE approach Added vignette present rational approximation using rSPDE package Backward compatibility maintained","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-063","dir":"Changelog","previous_headings":"","what":"rSPDE 0.6.3","title":"rSPDE 0.6.3","text":"CRAN release: 2021-10-14 Change inline citations Vignette avoid problems CRAN","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-062","dir":"Changelog","previous_headings":"","what":"rSPDE 0.6.2","title":"rSPDE 0.6.2","text":"CRAN release: 2021-02-23","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-061","dir":"Changelog","previous_headings":"","what":"rSPDE 0.6.1","title":"rSPDE 0.6.1","text":"Add rgdal suggested package","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-050","dir":"Changelog","previous_headings":"","what":"rSPDE 0.5.0","title":"rSPDE 0.5.0","text":"Remove dependency INLA Vignette CRAN Update citation","code":""}]
