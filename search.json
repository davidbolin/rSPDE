[{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"An introduction to the rSPDE package","text":"vignette provide brief introduction rSPDE package. begin using package generate simple data set. , analyze data set using rSPDE package. two main “families” functions inside rSPDE package: R-INLA implementation rational SPDE approach (Bolin Kirchner 2020)(https://www.tandfonline.com/doi/full/10.1080/10618600.2019.1665537); rational SPDE approach. analyze data set using approaches. also specific vignettes aforementioned family. precisely, following additional vignettes: R-INLA implementation rational SPDE approach Rational approximation rSPDE package also separate group functions performing operator-based rational approximations. useful performing rational approximations fractional SPDE models non-Gaussian noise. example approximation suitable one -called type-G Lévy noises. refer reader (Wallin Bolin 2015)(https://onlinelibrary.wiley.com/doi/full/10.1111/sjos.12141), (Bolin 2013)(https://onlinelibrary.wiley.com/doi/abs/10.1111/sjos.12046) (Asar et al. 2020)(https://rss.onlinelibrary.wiley.com/doi/pdf/10.1111/rssc.12405) examples models driven type-G Lévy noises. also refer reader ngme package one can fit models. explore functions performing operator-based rational approximation vignette: Operator-based rational approximation rSPDE package","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"a-toy-data-set","dir":"Articles","previous_headings":"","what":"A toy data set","title":"An introduction to the rSPDE package","text":"begin generating toy data set. illustration, simulate data set two-dimensional spatial domain. end, need construct mesh domain interest compute matrices needed define operator. use R-INLA package create mesh obtain matrices interest. begin defining mesh \\([0,1]\\times [0, 1]\\):  now use matern.operators() function construct rational SPDE approximation order \\(m=2\\) Gaussian random field Matérn covariance function \\([0,1]\\times [0, 1]\\). choose \\(\\nu=0.5\\) corresponds exponential covariance. also set \\(\\sigma=1\\) range \\(0.2\\). now position simulate latent field \\(u\\): Let us consider simple Gaussian linear model latent spatial field \\(u(\\mathbf{s})\\), observed \\(m\\) locations, \\(\\{\\mathbf{s}_1 , \\ldots , \\mathbf{s}_m \\}\\). \\(= 1,\\ldots,m,\\) \\[ \\begin{align}  y_i &= u(\\mathbf{s}_i)+\\varepsilon_i\\\\ \\end{align}, \\] \\(\\varepsilon_1,\\ldots,\\varepsilon_{m}\\) iid normally distributed mean 0 standard deviation 0.1. now obtain realization \\(y\\). use R-INLA function inla.spde.make.() construct observation matrix. observed data can seen following image.  simulated random field shown following figure.","code":"library(INLA) n_loc = 2000 loc_2d_mesh = matrix(runif(n_loc*2),n_loc,2) mesh_2d = inla.mesh.2d(   loc=loc_2d_mesh,   cutoff=0.05,   max.edge=c(0.1,0.5) ) plot(mesh_2d, main = \"\") library(rSPDE) sigma <- 1 range <- 0.2 nu <- 0.5 kappa <- sqrt(8*nu)/range op <- matern.operators(mesh=mesh_2d,nu=nu,                                    kappa=kappa,sigma=sigma,m=2) u <- simulate(op) A <- inla.spde.make.A(   mesh=mesh_2d,   loc=loc_2d_mesh) sigma.e <- 0.1 y = A %*% u + rnorm(n_loc) * sigma.e"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"fitting-the-model-with-r-inla-implementation-of-the-rational-spde-approach","dir":"Articles","previous_headings":"","what":"Fitting the model with R-INLA implementation of the rational SPDE approach","title":"An introduction to the rSPDE package","text":"now fit model toy data set using R-INLA implementation rational SPDE approach. details implementation can found R-INLA implementation rational SPDE approach. begin creating \\(\\) matrix, index, inla.stack object. now create model object. need set upper bound smoothness parameter \\(\\nu\\). increase upper bound \\(\\nu\\) also increase computational cost. example set nu_upper_bound=1. See R-INLA implementation rational SPDE approach details. Finally, create formula fit: can get summary: summary user’s scale:","code":"Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d)  st.dat=inla.stack(   data=list(y=as.vector(y)),   A=Abar,   effects=mesh.index) rspde_model <- rspde.matern(mesh = mesh_2d,                             nu_upper_bound = 2) f =   y ~ -1 + f(field, model=rspde_model) rspde_fit =   rspde.inla(f,        data=inla.stack.data(st.dat),        family=\"gaussian\",        control.predictor=          list(A=inla.stack.A(st.dat))) summary(rspde_fit) #>  #> Call: #>    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  #>    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  #>    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  #>    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  #>    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  #>    = control.compute, \", \" control.predictor = control.predictor,  #>    control.family = control.family, \", \" control.inla = control.inla,  #>    control.fixed = control.fixed, \", \" control.mode = control.mode,  #>    control.expert = control.expert, \", \" control.hazard = control.hazard,  #>    control.lincomb = control.lincomb, \", \" control.update =  #>    control.update, control.lp.scale = control.lp.scale, \", \"  #>    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  #>    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  #>    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  #>    working.directory = working.directory, \", \" silent = silent, inla.mode  #>    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  #>    .parent.frame)\")  #> Time used: #>     Pre = 3.06, Running = 9.45, Post = 0.0874, Total = 12.6  #> Random effects: #>   Name     Model #>     field RGeneric2 #>  #> Model hyperparameters: #>                                           mean    sd 0.025quant 0.5quant #> Precision for the Gaussian observations 101.78 3.542     94.974  101.720 #> Theta1 for field                         -3.49 0.356     -4.226   -3.482 #> Theta2 for field                          2.61 0.133      2.352    2.603 #> Theta3 for field                         -0.22 0.184     -0.572   -0.224 #>                                         0.975quant    mode #> Precision for the Gaussian observations    108.929 101.605 #> Theta1 for field                            -2.809  -3.445 #> Theta2 for field                             2.879   2.590 #> Theta3 for field                             0.161  -0.243 #>  #> Marginal log-Likelihood:  1032.84  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result_fit) #>             mean        sd 0.025quant   0.5quant 0.975quant       mode #> tau    0.0324602 0.0114985  0.0148623  0.0308799  0.0595326  0.0278085 #> kappa 13.6580000 1.8237700 10.5469000 13.4876000 17.6937000 13.1116000 #> nu     0.8910560 0.0897713  0.7244870  0.8873460  1.0757200  0.8772430 tau <- op$tau result_df <- data.frame(parameter = c(\"tau\",\"kappa\",\"nu\"),                         true = c(tau, kappa, nu), mean = c(result_fit$summary.tau$mean,                                                             result_fit$summary.kappa$mean,                                                            result_fit$summary.nu$mean),                         mode = c(result_fit$summary.tau$mode,                                                             result_fit$summary.kappa$mode,                                                            result_fit$summary.nu$mode)) print(result_df) #>   parameter       true        mean        mode #> 1       tau  0.1261566  0.03246021  0.02780853 #> 2     kappa 10.0000000 13.65800098 13.11158293 #> 3        nu  0.5000000  0.89105590  0.87724337"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"kringing-with-r-inla-implementation-of-the-rational-spde-approach","dir":"Articles","previous_headings":"","what":"Kringing with R-INLA implementation of the rational SPDE approach","title":"An introduction to the rSPDE package","text":"Let us now obtain predictions (.e., kriging) latent field dense grid region. begin creating grid want predictions. end, can use rspde.mesh.projector() function. function arguments function inla.mesh.projector() difference rSPDE version also argument nu argument rspde_order. Thus, proceed fashion R-INLA’s standard SPDE implementation: lattice contains 100 × 100 locations (default). Let us plot locations prediction:  Let us now calculate predictions jointly estimation. end, first, begin linking prediction coordinates mesh nodes \\(\\) matrix now make stack prediction locations. data prediction locations, set y= NA. join stack estimation stack. joint estimation takes , therefore turn computation certain things interested , marginals random effect. also use simplified integration strategy (actually using posterior mode hyper-parameters) command control.inla = list(int.strategy = \"eb\"), .e. empirical Bayes: extract indices prediction nodes extract mean standard deviation response: Finally, plot results. First mean:  , std. deviations:","code":"projgrid <- rspde.mesh.projector(mesh_2d, xlim = c(0,1),  ylim = c(0,1)) coord.prd <- projgrid$lattice$loc plot(coord.prd, type = \"p\", cex = 0.1) A.prd <- projgrid$proj$A ef.prd = list(c(mesh.index)) st.prd <- inla.stack(data = list(y = NA),      A = list(A.prd), tag = \"prd\",      effects = ef.prd) st.all <- inla.stack(st.dat, st.prd) rspde_fitprd <- rspde.inla(f, family = \"Gaussian\",               data = inla.stack.data(st.all),               control.predictor = list(A = inla.stack.A(st.all),                                       compute = TRUE, link = 1),              control.compute = list(return.marginals = FALSE,                                      return.marginals.predictor = FALSE),              control.inla = list(int.strategy = \"eb\")) id.prd <- inla.stack.index(st.all, \"prd\")$data m.prd<- matrix(rspde_fitprd$summary.fitted.values$mean[id.prd],100,100) sd.prd <- matrix(rspde_fitprd$summary.fitted.values$sd[id.prd],100,100)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"fitting-the-model-with-rspde","dir":"Articles","previous_headings":"","what":"Fitting the model with rSPDE","title":"An introduction to the rSPDE package","text":"now fit model toy data set without using R-INLA. end use rational approximation functions rSPDE package. details can found vignette Rational approximation rSPDE package. now use function rSPDE.matern.loglike() define likelihood. function object-based, sense obtains several quantities needs rSPDE model object. Notice already created rSPDE model object simulate data. , , use model object. Recall rSPDE model object created op. also already \\(\\) matrix connecting observation locations mesh, simply called . simplify parameter estimation, create objective function minimize negative log-likelihood, parametrized using logarithm parameter avoid constrained optimization. can now estimate parameter using optimParallel() (one can also use optim()):","code":"mlik <- function(theta, Y, A, op) {   sigma = exp(theta[1])   kappa = exp(theta[2])   nu = exp(theta[3])   return(-rSPDE::rSPDE.matern.loglike(object = op, Y=Y,                                   A = A, user_kappa=kappa, user_sigma = sigma,                                  user_nu=nu, sigma.e = exp(theta[4]))) } library(optimParallel) #Preparing the parallel  #Checking if we have a limit to the number of cores chk <- Sys.getenv(\"_R_CHECK_LIMIT_CORES_\", \"\") if (nzchar(chk) && chk == \"TRUE\") {     n_cores <- 2L } else {     n_cores <- parallel::detectCores() - 1 }  cl <- makeCluster(n_cores) setDefaultCluster(cl=cl)  #Fitting the model theta0 = c(get.inital.values.rSPDE(mesh=mesh_2d),               log(0.1*sqrt(var(as.vector(y))))) start_time <- Sys.time() pars <- optimParallel(theta0, mlik, Y = y, A = A, op=op) end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(sigma = c(sigma, exp(pars$par[1])),                        kappa = c(kappa, exp(pars$par[2])),                       nu = c(nu, exp(pars$par[3])),                       sigma.e = c(sigma.e, exp(pars$par[4])),                       row.names = c(\"True\", \"Estimate\")) print(results) #>             sigma     kappa        nu    sigma.e #> True     1.000000 10.000000 0.5000000 0.10000000 #> Estimate 1.014695  9.377185 0.5480289 0.09913223 #Total time print(total_time) #> Time difference of 11.76671 secs"},{"path":"https://davidbolin.github.io/rSPDE/articles/rSPDE.html","id":"kringing-with-rspde","dir":"Articles","previous_headings":"","what":"Kringing with rSPDE","title":"An introduction to the rSPDE package","text":"now kringing dense grid R-INLA-based rational SPDE approach, now using rSPDE functions. end use predict method rSPDE model object. Observe need \\(\\) matrix connecting mesh prediction locations. Let us now create \\(\\) matrix prediction locations used previous case (using R-INLA implementation): now use predict() method rSPDE model object argument compute.variances set TRUE can plot standard deviations. Let us also update values rSPDE model object fitted ones, also save estimated value sigma.e. Finally, plot results. First mean:  , std. deviations:","code":"predgrid <- inla.mesh.projector(mesh_2d, xlim = c(0,1),  ylim = c(0,1)) A.prd2 <- predgrid$proj$A sigma.e.est <- exp(pars$par[4]) op.prd <- update(op, user_sigma = exp(pars$par[1]),                  user_kappa = exp(pars$par[2]),                  user_nu = exp(pars$par[3]))  pred.rspde <- predict(op.prd, A = A, Aprd = A.prd2, Y = y,                        sigma.e = sigma.e.est,                       compute.variances = TRUE)"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Operator-based rational approximation","text":"Several popular Gaussian random field models can represented solutions stochastic partial differential equations (SPDEs) form \\[ L^{\\beta} (\\tau u) = \\mathcal{W}. \\] \\(\\mathcal{W}\\) Gaussian white noise, \\(L\\) second-order differential operator, fractional power \\(\\beta>0\\) determines smoothness \\(u\\), \\(\\tau>0\\) scales variance \\(u\\). \\(2\\beta\\) integer domain \\(\\mathcal{D}\\) model defined bounded, \\(u\\) can approximated Gaussian Markov random field (GMRF) \\(\\boldsymbol{\\mathrm{u}}\\) via finite element method (FEM) SPDE. Specifically, approximation can written \\[ u_h(s) = \\sum_{=1}^n u_i \\varphi_i(s). \\] \\(\\{\\varphi_i\\}\\) piecewise linear basis functions defined triangulation \\(\\mathcal{D}\\) vector weights \\(\\boldsymbol{\\mathrm{u}} = (u_1,\\ldots,u_n)^T\\) normally distributed, \\(N(\\boldsymbol{\\mathrm{u}},\\tilde{\\boldsymbol{\\mathrm{Q}}}^{-1})\\), \\(\\tilde{\\boldsymbol{\\mathrm{Q}}}\\) sparse. See (Lindgren, Rue, Lindström 2011)(https://rss.onlinelibrary.wiley.com/doi/full/10.1111/j.1467-9868.2011.00777.x) details. vignette focus operator-based rational approximation. approach, introduced (Bolin Kirchner 2020)(https://www.tandfonline.com/doi/full/10.1080/10618600.2019.1665537), results approximation original SPDE form \\(P_l x = P_r \\mathcal{W}\\), \\(P_l\\) \\(P_r\\) non-fractional operators defined terms polynomials \\(p_l\\) \\(p_r\\). order \\(p_r\\) given \\(m\\) order \\(p_l\\) \\(m + m_{\\beta}\\) \\(m_{\\beta}\\) integer part \\(\\beta\\) \\(\\beta>1\\) \\(m_{\\beta} = 1\\) otherwise. combination rational approximation operator FEM discretization yields approximation \\(u_h\\) \\(u\\) basis expansion form . difference non-fractional case vector stochastic weights now \\(\\boldsymbol{\\mathrm{u}} \\sim N(\\boldsymbol{\\mathrm{0}},\\boldsymbol{\\mathrm{P}}_r\\boldsymbol{\\mathrm{Q}}^{-1}\\boldsymbol{\\mathrm{P}}_r^T)\\) \\(\\boldsymbol{\\mathrm{Q}}\\) \\(\\boldsymbol{\\mathrm{P}}_r\\) sparse matrices. Alternatively, \\(\\boldsymbol{\\mathrm{u}}\\) can represented \\(\\boldsymbol{\\mathrm{u}} = \\boldsymbol{\\mathrm{P}}_r \\boldsymbol{\\mathrm{x}}\\) \\(\\boldsymbol{\\mathrm{x}} \\sim N(\\boldsymbol{\\mathrm{0}},\\boldsymbol{\\mathrm{Q}}^{-1})\\), means discrete approximation latent GMRF. can used computationally efficient inference simulation. See Bolin Kirchner (2020) details.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"using-the-package-to-perform-operator-based-rational-approximations","dir":"Articles","previous_headings":"","what":"Using the package to perform operator-based rational approximations","title":"Operator-based rational approximation","text":"main purpose rSPDE package provide functions creating rational approximation. vignette focus operator-based rational approximation, means assembling matrices \\(\\boldsymbol{\\mathrm{Q}}\\) \\(\\boldsymbol{\\mathrm{P}}_r\\). three functions computing rational approximation. general function fractional.operators(), works wide class models general differential operator \\(L\\). stationary Matérn case, \\(L = \\kappa^2 - \\Delta\\), function matern.operators() provides simplified model specification. generalized non-stationary Matérn model, defined SPDE \\[ (\\kappa(s)^2 - \\Delta)^\\beta (\\tau(s)u(s)) = \\mathcal{W}, \\] function spde.matern.operators() can used. covariance-based rational approximation, refer reader Rational approximation rSPDE package vignette. noteworthy covariance-based rational approximation applies fractional SPDE models Gaussian noise, whereas operator-based rational approximation can used general noises type-G Lévy noises. refer reader (Wallin Bolin 2015)(https://onlinelibrary.wiley.com/doi/full/10.1111/sjos.12141), (Bolin 2013)(https://onlinelibrary.wiley.com/doi/abs/10.1111/sjos.12046) (Asar et al. 2020)(https://rss.onlinelibrary.wiley.com/doi/pdf/10.1111/rssc.12405) examples models driven type-G Lévy noises. also refer reader ngme package one can fit models. approximation constructed, can included manually statistical models just non-fractional case. package built-functions basic use approximation, simulate() can applied simulation field. also functions likelihood evaluation kriging prediction geostatistical models Gaussian measurement noise \\(u\\) included. following sections, illustrate usage functions.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"constructing-the-approximation","dir":"Articles","previous_headings":"Using the package to perform operator-based rational approximations","what":"Constructing the approximation","title":"Operator-based rational approximation","text":"section, explain different main functions can used constructing rational approximation. first step constructing rational SPDE approximation define FEM mesh. illustration purposes, rSPDE package contains simple FEM implementation models \\(\\mathbb{R}\\) use first. illustrate spatial models can constructed, FEM implementation R-INLA package used instead. Assume want define model interval \\([0,1]\\). start defining vector mesh nodes \\(s_i\\) basis functions \\(\\varphi_i\\) centered. Based nodes, use built-function rSPDE.fem1d() assemble two matrices needed creating approximation basic Matérn model. matrices mass matrix \\(\\boldsymbol{\\mathrm{C}}\\), elements \\(C_{ij} = \\int \\varphi_j(s) \\varphi_i(s) ds\\), stiffness matrix \\(\\boldsymbol{\\mathrm{G}}\\), elements \\(G_{ij} = \\int \\nabla\\varphi_j(s) \\cdot \\nabla\\varphi_i(s) ds\\). can now use matern.operators() construct rational SPDE approximation degree \\(m=1\\) Gaussian random field Matérn covariance function interval. Since using operator-based approximation, must set type \"operator\". object op contains matrices needed evaluating distribution stochastic weights \\(\\boldsymbol{\\mathrm{u}}\\). want evaluate \\(u_h(s)\\) locations \\(s_1,\\ldots, s_n\\), need multiply weights basis functions \\(\\varphi_i(s)\\) evaluated locations. , can construct observation matrix \\(\\boldsymbol{\\mathrm{}}\\) elements \\(A_{ij} = \\varphi_j(s_i)\\), links FEM basis functions locations. matrix can constructed using function rSPDE.A1d(). evaluate accuracy approximation, let us compute covariance function process \\(s=0.5\\) locations s compare true Matérn covariance function, folded Matérn, see Theorem 1 explicit link Gaussian fields Gaussian Markov random fields: stochastic partial differential equation approach details. covariances can calculated \\[ \\boldsymbol{\\mathrm{}} \\boldsymbol{\\mathrm{P}}_r \\boldsymbol{\\mathrm{Q}}^{-1}\\boldsymbol{\\mathrm{P}}_r^T\\boldsymbol{\\mathrm{v}}. \\] \\(\\boldsymbol{\\mathrm{}}\\) identity matrix since evaluating approximation nodes FEM mesh \\(\\boldsymbol{\\mathrm{v}}\\) vector basis functions evaluated \\(s=0.5\\). covariance function error compared Matérn covariance shown following figure. improve approximation can increase degree polynomials, increasing \\(m\\), /increase number basis functions used FEM approximation. Let us, example, compute approximation \\(m=2\\) using mesh, well approximation increase number basis functions use \\(m=1\\) \\(m=2\\). resulting errors shown following figure.  Since error induced rational approximation decreases exponentially \\(m\\), general rarely need approximation large value \\(m\\). good number non-zero elements \\(\\boldsymbol{\\mathrm{P}}_r\\) \\(\\boldsymbol{\\mathrm{Q}}\\) increases \\(m\\), makes approximation computationally costly use. , condition number \\(\\boldsymbol{\\mathrm{P}}_r\\) \\(\\boldsymbol{\\mathrm{Q}}\\) increases \\(m\\), can cause numerical problems working matrices. illustrate , let us compute norm approximation error different \\(m\\). see error decreases increasing \\(m\\) \\(1\\) \\(2\\), large \\(m=3\\) \\(m=4\\). reason approximation bad, numerical accuracy product \\(\\boldsymbol{\\mathrm{P}}_r\\boldsymbol{\\mathrm{Q}}^{-1}\\boldsymbol{\\mathrm{P}}_rv\\) low due high condition numbers matrices. important notice covariance-based rational approximation numerically stable, main reason clever decomposition latent field vector random fields remove need higher order finite element matrices higher order rational approximations. refer reader Rational approximation rSPDE package vignette details. solve issue operator-based rational approximation, package contains functions performing operations \\(\\boldsymbol{\\mathrm{P}}_rv\\) \\(\\boldsymbol{\\mathrm{P}}_r^{-1}v\\) takes advantage structure \\(\\boldsymbol{\\mathrm{P}}_r\\) avoid numerical issues. complete list function can seen typing ?operator.operations. One functions Sigma.mult(), performs multiplication \\(\\boldsymbol{\\mathrm{P}}_r\\boldsymbol{\\mathrm{Q}}^{-1}\\boldsymbol{\\mathrm{P}}_rv\\) numerically stable way. Let us use function compute errors approximations see indeed get better approximations \\(m\\) increases.","code":"s <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(s) kappa <- 20 sigma <- 2 nu <- 0.8 op <- matern.operators(kappa = kappa, sigma = sigma, nu = nu,                        G = fem$G, C = fem$C, d = 1, m = 1,                        type=\"operator\") v <- t(rSPDE.A1d(s,0.5)) c.approx <- op$Pr %*% solve(op$Q, op$Pr %*% v) c.true <- folded.matern.covariance.1d(rep(0.5,length(s)),abs(s), kappa, nu, sigma) op2 <- matern.operators(kappa = kappa, sigma = sigma, nu = nu,                        G = fem$G, C = fem$C, d = 1, m = 2,                        type=\"operator\") c.approx2 <- op2$Pr %*% solve(op2$Q, op2$Pr %*% v)  s2 <- seq(from = 0, to = 1, length.out = 501) fem2 <- rSPDE.fem1d(s2) op <- matern.operators(kappa = kappa, sigma = sigma, nu = nu,                        G = fem2$G, C = fem2$C, d = 1, m=1,                        type=\"operator\") A <- rSPDE.A1d(s2,s) v <- t(rSPDE.A1d(s2,0.5)) c.approx3 <- A%*%op$Pr %*% solve(op$Q, op$Pr %*% v) op <- matern.operators(kappa = kappa, sigma = sigma, nu = nu,                        G = fem2$G, C = fem2$C, d = 1, m=2,                        type=\"operator\") c.approx4 <- A%*%op$Pr %*% solve(op$Q, op$Pr %*% v) errors <- rep(0,4) for(i in 1:4){   op <- matern.operators(kappa = kappa, sigma = sigma, nu = nu,                        G = fem2$G, C = fem2$C, d = 1, m = i,                        type = \"operator\")   c.app <- A%*%op$Pr %*% solve(op$Q, op$Pr %*% v)   errors[i] <- norm(c.true-c.app) } print(errors) #> [1]  1.0120165  0.1100542 52.4841240 54.6499071 errors2 <- rep(0,4) for(i in 1:4){   op <- matern.operators(kappa = kappa, sigma = sigma, nu = nu,                        G = fem2$G, C = fem2$C, d = 1, m = i,                        type=\"operator\")   c.app <- A%*%Sigma.mult(op, v)   errors2[i] <- norm(c.true-c.app) } print(errors2) #> [1] 1.01201540 0.10479953 0.02474815 0.01788324"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"a-non-stationary-model","dir":"Articles","previous_headings":"","what":"A non-stationary model","title":"Operator-based rational approximation","text":"Let us now examine non-stationary model \\((\\kappa(s)^2 - \\Delta)^\\beta (\\tau(s)u(s)) = \\mathcal{W}\\) \\(\\kappa(s) = 10(1+2s^2)\\) \\(\\tau(s) = 0.1(1 - 0.7s^2)\\). can use spde.matern.operators(), currently available operator-based rational approximation, create rational approximation \\(m=1\\) follows. Let us compute covariance function \\(C(s,s_i)\\) non-stationary model locations \\(s_1=0.1, s_2 = 0.5,\\) \\(s_3 = 0.9\\). three covariances shown following figure. see choice \\(\\kappa(s)\\) \\(\\tau(s)\\) results model longer range small values \\(s\\) smaller variance middle domain. can also apply general function fractional.operators() construct approximation. function requires one supplies discretization non-fractional operator \\(L\\), well scaling factor \\(c>0\\) lower bound smallest eigenvalue \\(L\\). case \\(L = \\kappa(s)^2 - \\Delta\\), eigenvalues operator bounded \\(c = \\min_s \\kappa(s)^2\\). compute constant discrete operator. Another difference fractional.operators() previous functions constructing approximation, requires specifying \\(\\beta\\) instead smoothness parameter \\(\\nu\\) Matérn covariance. two parameters related \\(2\\beta = \\nu + d/2\\). Let’s make sure approximation comparing previously computed covariances. Obviously, simpler use spde.matern.operators() case, advantage fractional.operators() also can used general models one \\(L = \\kappa(s)^2 - \\nabla \\cdot (\\boldsymbol{\\mathrm{H}}(s) \\nabla)\\) matrix-valued function \\(\\boldsymbol{\\mathrm{H}}(s)\\).","code":"s <- seq(from = 0, to = 1, length.out = 501) fem <- rSPDE.fem1d(s) kappa <-  10*(1+2*s^2) tau <-  0.1*(1 - 0.7*s^2) op <- spde.matern.operators(kappa = kappa, tau = tau, nu = nu,                              G = fem$G, C = fem$C, d = 1, m=1) v <- t(rSPDE.A1d(s, c(0.1,0.5,0.9))) covs <- Sigma.mult(op, v) c = min(kappa)^2 L = fem$G + fem$C %*% Diagonal(501, kappa^2) op <- fractional.operators(L = L, beta = (nu + 1/2)/2, C = fem$C,                             scale.factor = c, tau = tau, m = 1) covs2 <- Sigma.mult(op,v) norm(covs-covs2) #> [1] 0"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"using-the-approximation","dir":"Articles","previous_headings":"A non-stationary model","what":"Using the approximation","title":"Operator-based rational approximation","text":"approximation, constructed using functions fractional.operators(), matern.operators(), spde.matern.operators(), can simulate model using simulate(). also built-support kriging prediction. illustrate , use simulation create noisy observations process. , first construct observation matrix linking FEM basis functions locations want simulate. first randomly generate observation locations construct matrix. now generate observations \\(Y_i = u(s_i) + \\varepsilon_i\\), \\(\\varepsilon_i \\sim N(0,\\sigma_e^2)\\) Gaussian measurement noise. Finally, compute kriging prediction process \\(u\\) locations s based observations. specify locations predicted, argument Aprd used. argument observation matrix links mesh locations prediction locations. process simulation, observed data, kriging prediction shown following figure.","code":"u <- simulate(op) n.obs <- 20 obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(s, obs.loc) sigma.e <- 0.3 Y <- as.vector(A %*% u + sigma.e * rnorm(n.obs)) A.krig <- rSPDE.A1d(s, s) u.krig <- predict(op, A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_base.html","id":"spatial-data-and-parameter-estimation","dir":"Articles","previous_headings":"","what":"Spatial data and parameter estimation","title":"Operator-based rational approximation","text":"functions used previous examples also work spatial models. need construct mesh domain interest compute matrices needed define operator. tasks can performed, example, using R-INLA package. Let us start defining mesh \\([0,1]\\times [0, 1]\\) compute mass stiffness matrices mesh.  can now use matrices define rational SPDE approximation degree \\(m=1\\) Matérn model . now simulate latent process standard deviation \\(\\sigma=1\\) range \\(0.1\\). use \\(\\nu=0.5\\) model exponential covariance function. Now let us simulate noisy data use estimate parameters model. construct observation matrix, use R-INLA function inla.spde.make.(). sample 30 replicates latent field. first replicate simulated random field well observation locations shown following figure. type rational approximation degree \\(m\\), corresponding likelihood function can used likelihood-based parameter estimation. Since constructed model spde.matern.operators(), can use function spde.matern.loglike() define likelihood. simplify parameter estimation, create objective function minimize negative log-likelihood, parametrized using logarithm parameter avoid constrained optimization. can now estimate parameter using optim().","code":"library(INLA) m = 100 loc_2d_mesh = matrix(runif(m*2),m,2) mesh_2d = inla.mesh.create.helper(   points=loc_2d_mesh,   cutoff=0.05,   offset=c(0.1,0.4),   max.edge=c(0.05,0.5) ) plot(mesh_2d, main= \"\") points(loc_2d_mesh[,1],loc_2d_mesh[,2]) fem_mesh_2d <- inla.mesh.fem(mesh_2d) C = fem_mesh_2d$c0 G <- fem_mesh_2d$g1 nu = 0.5 sigma = 1  range = 0.1 kappa = sqrt(8*nu)/range tau = 1/(sqrt(4*pi)*kappa*sigma) op <- spde.matern.operators(kappa = kappa, tau = tau, nu = nu, G = G, C = C, d = 2, m = 1) n.rep = 30 u <- simulate(op, nsim=n.rep) A <- inla.spde.make.A(   mesh=mesh_2d,   loc=loc_2d_mesh) sigma.e<- 0.1 Y = A %*% u + matrix(rnorm(m*n.rep),ncol=n.rep) * sigma.e mlik <- function(theta, Y, G, C, A) {   return(-spde.matern.loglike(tau=exp(theta[1]), kappa=exp(theta[2]),                                nu=exp(theta[3]), sigma.e=exp(theta[4]),                               Y = Y, G = G, C = C, A = A, d = 2, m=1)) } theta0 = c(get.inital.values.rSPDE(mesh=mesh_2d, include.tau = TRUE),               log(0.1*sqrt(var(as.vector(Y))))) start_time <- Sys.time() pars <- optim(theta0, mlik, Y = Y, G = G, C = C, A = A, method = \"L-BFGS-B\") end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(tau = c(tau, exp(pars$par[1])),                       kappa = c(kappa, exp(pars$par[2])),                        nu = c(nu, exp(pars$par[3])),                       sigma.e = c(sigma.e, exp(pars$par[4])),                       row.names = c(\"True\", \"Estimate\")) print(results) #>                  tau    kappa        nu    sigma.e #> True     0.014104740 20.00000 0.5000000 0.10000000 #> Estimate 0.002885492 25.69506 0.8895145 0.08292449  #Total time print(total_time) #> Time difference of 1.205326 mins"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Rational approximation with the rSPDE package","text":"vignette illustrate statistical inference covariance-based rational SPDE approach. covariance-based rational approximation related operator-based (rational approximation Bolin Kirchner 2020)(https://www.tandfonline.com/doi/full/10.1080/10618600.2019.1665537). covariance-based rational approximation efficient alternative operator-based rational approximation one SPDE driven Gaussian white noise. dealing fractional SPDE models driven non-Gaussian white noises, operator-based rational approximations might useful. instance, consider SPDE: \\[L^{\\alpha/2}(\\tau u) = \\widetilde{\\mathcal{W}},\\] \\(L = -\\Delta +\\kappa^2 \\) \\(\\widetilde{\\mathcal{W}}\\) non-Gaussian white noise. example operator-based rational approximation suitable, one SPDE white noise -called type-G Lévy noises. refer reader (Wallin Bolin 2015)(https://onlinelibrary.wiley.com/doi/full/10.1111/sjos.12141), (Bolin 2013)(https://onlinelibrary.wiley.com/doi/abs/10.1111/sjos.12046) (Asar et al. 2020)(https://rss.onlinelibrary.wiley.com/doi/pdf/10.1111/rssc.12405) examples models driven type-G Lévy noises. also refer reader ngme package one can fit models. explore functions performing operator-based rational approximation vignette: Operator-based rational approximation R-INLA implementation rational SPDE approach refer reader R-INLA implementation rational SPDE approach vignette.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"covariance-based-rational-spde-approach","dir":"Articles","previous_headings":"","what":"Covariance-based rational SPDE approach","title":"Rational approximation with the rSPDE package","text":"Let us first present basic setup. want model precipitation two-dimensional random field \\(u\\) within bounded domain, location domain associates random variable describe local precipitation. SPDE approach, introduced (Lindgren, Rue, Lindström 2011)(https://rss.onlinelibrary.wiley.com/doi/full/10.1111/j.1467-9868.2011.00777.x) model \\(u\\) solution following SPDE: \\[L^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(L = -\\Delta +\\kappa^2 \\) \\(\\mathcal{W}\\) standard Gaussian white noise. , \\(\\alpha\\), \\(\\kappa\\) \\(\\tau\\) three parameters want estimate. standard SPDE approach, write, general dimension \\(d\\), \\(\\alpha = \\nu + d/2\\) assume \\(\\nu\\) fixed. rational SPDE approach able estimate general smoothness \\(\\nu\\) data. Now let us briefly describe covariance based rational SPDE approach works statistical inference. central idea perform rational approximation directly covariance operator, given \\(L^{-\\alpha}\\), instead solution \\(u\\). end, begin obtaining approximation random field \\(u\\), solution SPDE written , using finite element method (FEM): \\[u_h(\\mathbf{s}_i)=\\sum_{j=1}^{n_h} \\hat{u}_j \\varphi_j(\\mathbf{s}_i),\\] \\(\\{\\hat{u}_j\\}_{j = 1}^{n_h}\\) stochastic weights \\(\\{\\varphi_j(\\mathbf{s}_i)\\}_{j = 1}^{n_h}\\) fixed basis functions. obtain finite element approximation operator \\(L\\), given \\(L_h\\), covariance operator \\(u_h\\) given \\(L_h^{-\\alpha}\\). Now, using rational approximation \\(L_h\\), can approximate covariance operator \\(L_h^{-\\alpha}\\) \\[L_{h,m}^{-\\alpha} = L_h^{-m_\\alpha} p(L_h^{-1})q(L_h^{-1})^{-1},\\] \\(m_{\\alpha} = \\lfloor\\alpha\\rfloor\\), \\(m\\) order rational approximation, \\(p(L_h^{-1}) = \\sum_{=0}^m a_i L_h^{m-}\\) \\(q(L_h^{-1}) = \\sum_{j=0}^m b_j L_h^{m-}\\), \\(\\{a_i\\}_{= 0}^m\\) \\(\\{b_j\\}_{j = 0}^m\\) known coefficients obtained rational approximation. next step obtain decomposition \\(p(L_h^{-1})q(L_h^{-1})^{-1}\\) partial fractions get new representation: \\[L_{h,m}^{-\\alpha} =L_h^{-m_\\alpha} \\left(\\sum_{=1}^{m}  r_i  (L_h-p_i )^{-1} +k\\right).\\] Based operator equation, can write covariance matrix stochastic weights \\(\\hat{\\textbf{u}}\\), \\(\\hat{\\textbf{u}}=[\\hat{u}_1,...,\\hat{u}_{n_h}]^\\top\\), \\[\\mathbf{\\Sigma}_{\\hat{\\textbf{u}}} = (\\textbf{L}^{-1}\\textbf{C})^{m_{\\alpha}} \\sum_{=1}^{m}r_i(\\textbf{L}-p_i\\textbf{C})^{-1}+\\textbf{K}, \\] \\(\\textbf{C} = \\{C_{ij}\\}_{,j=1}^{n_h}\\), \\(C_{ij} = (\\varphi_i,\\varphi_j)_{L_2(\\mathcal{D})}\\), mass matrix, \\(\\textbf{L} = \\kappa^2\\textbf{C}+\\textbf{G}\\), \\(\\textbf{G} = \\{G_{ij}\\}_{,j=1}^{n_h}\\), \\(G_{ij}=(\\nabla\\varphi_i,\\nabla\\varphi_j)_{L_2(\\mathcal{D})}\\), stiffness matrix, \\[\\textbf{K}=\\left\\{     \\begin{array}{lcl}         k\\textbf{C}      &      & {m_{\\alpha}=0}\\\\         k\\textbf{L}^{-1}(\\textbf{C}\\textbf{L}^{-1})^{m_{\\alpha}-1}    &      & {m_{\\alpha}>=1}\\\\     \\end{array} \\right. .\\] representation shows can express \\(\\hat{\\textbf{u}}\\) \\[\\hat{\\textbf{u}}=\\sum_{k=1}^{m+1}\\textbf{x}_k,\\] \\(\\textbf{x}_k = (x_{k,1}, \\ldots, x_{k,n_h})\\), \\[\\textbf{x}_i \\sim N(\\textbf{0},\\textbf{Q}_i^{-1}),\\] \\(\\textbf{Q}_i\\) precision matrix \\(\\textbf{x}_i\\), given \\[\\textbf{Q}_i=\\left \\{     \\begin{array}{lcl}         (\\textbf{L}-p_i\\textbf{C})(\\textbf{C}^{-1}\\textbf{L})^{m_{\\alpha}}/r_i,      &      & {= 1,...,m}\\\\          \\textbf{K}^{-1},   &      & {= m+1}\\\\     \\end{array}. \\right.\\] , , replace Matérn latent field latent vector given , precision matrix given \\[\\textbf{Q}=\\begin{bmatrix}\\textbf{Q}_1& &\\\\&\\ddots&\\\\& &\\textbf{Q}_{m+1}\\end{bmatrix}.\\] Now, assume observe \\[y_i = u_h(\\mathbf{s}_i) + \\varepsilon_i,\\quad =1,\\ldots, N,\\] \\(\\varepsilon_i\\sim N(0,\\sigma_\\varepsilon^2)\\) iid measurement noise. , \\[y_i = u_h(\\mathbf{s}_i) + \\varepsilon_i = \\sum_{j=1}^{n_h} \\hat{u}_j \\varphi_j(\\mathbf{s}_i) + \\varepsilon_i = \\sum_{k=1}^{m+1} \\sum_{j=1}^{n_h} x_{k,j} \\varphi(\\mathbf{s}_i) + \\varepsilon_i.\\] can written matrix form \\[\\textbf{y} = \\overline{\\textbf{}} \\textbf{X} + \\boldsymbol{\\varepsilon},\\] \\(\\textbf{y} = [y_1,\\ldots,y_N]^\\top, \\textbf{X} = [\\textbf{x}_1^\\top,\\ldots,\\textbf{x}_{m+1}^\\top]^\\top\\), \\(\\boldsymbol{\\varepsilon} = [\\varepsilon_1,\\ldots,\\varepsilon_N]^\\top\\), \\[\\overline{\\textbf{}}=\\begin{bmatrix}\\textbf{}&\\cdots&\\textbf{}\\end{bmatrix}_{n\\times n_h(m+1)},\\] \\[\\textbf{}=\\begin{bmatrix}\\varphi_1(s_1)&\\cdots&\\varphi_{n_h}(s_1)\\\\\\vdots&\\vdots&\\vdots\\\\\\varphi_1(s_n)&\\cdots&\\varphi_{n_h}(s_n)\\end{bmatrix}.\\] arrive following hierarchical model: \\[\\begin{align} \\textbf{y}\\mid \\textbf{X} &\\sim N(0,\\sigma_\\varepsilon\\textbf{})\\\\ \\textbf{X}&\\sim N(0,\\textbf{Q}^{-1}) \\end{align}.\\] elements, can use R-INLA compute posterior distribution three parameters want estimate. covariance-based method computational advantage compared standard rational approximation: computational cost covariance-based rational approximation order \\(m\\) approximately standard rational approximation order \\(m/2\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"constructing-the-approximation","dir":"Articles","previous_headings":"","what":"Constructing the approximation","title":"Rational approximation with the rSPDE package","text":"section, explain use function matern.operators() default argument type, , type=\"covariance\", constructs covariance-based rational approximation. also illustrate usage several methods functions related covariance-based rational approximation. use functions sample Gaussian fields stationary Matérn covariance function, compute log-likelihood function, perform predicitions (.e., kringing), etc. first step performing covariance-based rational SPDE approximation define FEM mesh. illustration purposes, rSPDE package contains simple FEM implementation models \\(\\mathbb{R}\\) use first. also illustrate spatial models can constructed FEM implementation R-INLA package used instead. using R-INLA package, also recommend usage R-INLA implementation rational SPDE approach. details see R-INLA implementation rational SPDE approach vignette. begin loading rSPDE package: Assume want define model interval \\([0,1]\\). start defining vector mesh nodes \\(s_i\\) basis functions \\(\\varphi_i\\) centered. Based nodes, use built-function rSPDE.fem1d() assemble two matrices needed creating approximation basic Matérn model. matrices mass matrix \\(\\boldsymbol{\\mathrm{C}}\\), elements \\(C_{ij} = \\int \\varphi_j(s) \\varphi_i(s) ds\\), stiffness matrix \\(\\boldsymbol{\\mathrm{G}}\\), elements \\(G_{ij} = \\int \\nabla\\varphi_j(s) \\cdot \\nabla\\varphi_i(s) ds\\). can now use matern.operators() construct rational SPDE approximation order \\(m=2\\) Gaussian random field Matérn covariance function interval. also refer reader Operator-based rational approximation similar comparison made operator-based rational approximation. object op_cov contains matrices needed evaluating distribution stochastic weights \\(\\boldsymbol{\\mathrm{u}}\\). want evaluate \\(u_h(s)\\) locations \\(s_1,\\ldots, s_n\\), need multiply weights basis functions \\(\\varphi_i(s)\\) evaluated locations. , can construct observation matrix \\(\\boldsymbol{\\mathrm{}}\\), elements \\(A_{ij} = \\varphi_j(s_i)\\), links FEM basis functions locations. matrix can constructed using function rSPDE.A1d(). However, observed introduction vignette, decomposed stochastic weights \\(\\boldsymbol{\\mathrm{u}}\\) vector latent variables. Thus, \\(\\) matrix covariance-based rational approximation, denote \\(\\overline{}\\), actually given \\(m+1\\)-fold horizontal concatenation \\(\\) matrices, \\(m\\) order rational approximation. compute precision matrix covariance-based rational approximation one can use precision() method CBrSPDEobj object (object returned matern.operators() function default type, type=\"covariance\"): evaluate accuracy approximation, let us compute covariance function process \\(s=0.5\\) locations s compare true Matérn covariance function. covariances can calculated \\[ \\overline{\\boldsymbol{\\mathrm{}}} \\boldsymbol{\\mathrm{Q}}^{-1}\\overline{\\boldsymbol{\\mathrm{v}}}. \\] , \\(\\boldsymbol{\\mathrm{Q}}\\) precision matrix obtained covariance-based rational approximation, \\(\\boldsymbol{\\mathrm{}}\\) identity matrix since evaluating approximation nodes FEM mesh, \\(\\overline{\\boldsymbol{\\mathrm{v}}}\\) \\((m+1)\\)-fold vertical concatenation vector \\(\\boldsymbol{\\mathrm{v}}\\), \\(\\boldsymbol{\\mathrm{v}}\\) vector basis functions evaluated \\(s=0.5\\). Let us now compute true Matérn covariance function interval \\((0,1)\\), folded Matérn, see Theorem 1 explicit link Gaussian fields Gaussian Markov random fields: stochastic partial differential equation approach details. covariance function error compared Matérn covariance shown following figure. improve approximation can increase degree polynomials, increasing \\(m\\), /increase number basis functions used FEM approximation. Let us, example, compute approximation \\(m=4\\) using mesh, well approximation increase number basis functions use \\(m=2\\) \\(m=4\\). resulting errors shown following figure.  Since error induced rational approximation decreases exponentially \\(m\\), general rarely need approximation large value \\(m\\). good size \\(\\boldsymbol{\\mathrm{Q}}\\) increases \\(m\\), makes approximation computationally costly use. illustrate , let us compute norm approximation error different \\(m\\). see error decreases fast increase \\(m\\) \\(1\\) \\(4\\), without numerical instability. advantage covariance-based rational approximation compared operator-based rational approximation. See Operator-based rational approximation details numerical instability operator-based rational approximation. main reason numerical stability covariance-based method clever decomposition latent field vector random fields (see introduction details) remove need higher order finite element matrices higher order rational approximations.","code":"library(rSPDE) s <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(s) kappa <- 20 sigma <- 2 nu <- 0.8 op_cov <- matern.operators(C=fem$C, G=fem$G,nu=nu,                                    kappa=kappa,sigma=sigma,d=1,m=2) Q <- precision(op_cov) v <- t(rSPDE.A1d(s,0.5)) v_bar <- kronecker(matrix(1,nrow=3),v) A <- Diagonal(101) A_bar <- kronecker(matrix(1,ncol=3),A) c_cov.approx <- (A_bar)%*%solve(Q,v_bar) c.true <- folded.matern.covariance.1d(rep(0.5,length(s)),abs(s), kappa, nu, sigma) op_cov2 <- matern.operators(kappa = kappa, sigma = sigma, nu = nu,                        G = fem$G, C = fem$C, d = 1, m = 4) Q2 <- precision(op_cov2) v_bar2 <- kronecker(matrix(1,nrow=5),v) A_bar2 <- kronecker(matrix(1,ncol=5),A) c_cov.approx2 <- (A_bar2)%*%solve(Q2,v_bar2)  s2 <- seq(from = 0, to = 1, length.out = 501) fem2 <- rSPDE.fem1d(s2) op_cov <- matern.operators(kappa = kappa, sigma = sigma, nu = nu,                        G = fem2$G, C = fem2$C, d = 1, m=2) Q3 <- precision(op_cov) A2 <- rSPDE.A1d(s2,s) v2 <- t(rSPDE.A1d(s2,0.5)) v2_bar <- kronecker(matrix(1,nrow=3),v2) A2_bar <- kronecker(matrix(1,ncol=3),A2) c_cov.approx3 <- (A2_bar)%*%solve(Q3,v2_bar)  op_cov <- matern.operators(kappa = kappa, sigma = sigma, nu = nu,                        G = fem2$G, C = fem2$C, d = 1, m=4) Q4 <- precision(op_cov) v2_bar2 <- kronecker(matrix(1,nrow=5),v2) A2_bar2 <- kronecker(matrix(1,ncol=5),A2) c_cov.approx4 <- (A2_bar2)%*%solve(Q4,v2_bar2) errors <- rep(0,4) for(i in 1:4){   op_cov <- matern.operators(kappa = kappa, sigma=sigma, nu = nu,                        G = fem2$G, C = fem2$C, d = 1, m = i)   Q = precision(op_cov)   v_bar <- kronecker(matrix(1,nrow=i+1),v2)   A_bar <- kronecker(matrix(1,ncol=i+1),A2)   c_cov.approx <- (A_bar)%*%solve(Q,v_bar)   errors[i] <- norm(c.true-c_cov.approx) } print(errors) ## [1] 0.977500618 0.086659188 0.017335545 0.008432137"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"using-the-approximation","dir":"Articles","previous_headings":"","what":"Using the approximation","title":"Rational approximation with the rSPDE package","text":"use function matern.operators(), can simulate model using simulate() method. end simply apply simulate() method object returned matern.operators() function: want replicates, simply set argument nsim desired number replicates. instance, generate two replicates model, simply :","code":"u <- simulate(op_cov) u.rep <- simulate(op_cov, nsim=2)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"fitting-a-model","dir":"Articles","previous_headings":"Using the approximation","what":"Fitting a model","title":"Rational approximation with the rSPDE package","text":"also built-support computing loglikelihood function performing kriging prediction. illustrate , use simulation create noisy observations process. , first construct observation matrix linking FEM basis functions locations want simulate. first randomly generate observation locations construct matrix. now generate observations \\(Y_i = u(s_i) + \\varepsilon_i\\), \\(\\varepsilon_i \\sim N(0,\\sigma_e^2)\\) Gaussian measurement noise. assume latent process Matérn covariance \\(\\kappa=20, \\sigma=2\\) \\(\\nu=0.8\\): Let us now fit model. end first must compute loglikelihood function function parameters want estimate. define loglikelihood function parametrized using logarithm parameter avoid constrained optimization. now get suitable initial values optimization using get.inital.values.rSPDE(). add initial guess sigma.e. can also speed optimization using optimParallel() function optimParallel package. end, simply replace optim() function optimParallel() set number cores want use:","code":"set.seed(1) s <- seq(from = 0, to = 1, length.out = 501) n.obs <- 200 obs.loc <- runif(n.obs) fem <- rSPDE.fem1d(s) A <- rSPDE.A1d(s, obs.loc) kappa <- 20 sigma <- 2 nu <- 0.8 op_cov <- matern.operators(C=fem$C, G=fem$G,nu=nu,                                    kappa=kappa,sigma=sigma,d=1,m=2) u <- simulate(op_cov)  sigma.e <- 0.3 Y <- as.vector(A %*% u + sigma.e * rnorm(n.obs)) mlik_cov <- function(theta, Y, A, op_cov){ sigma = exp(theta[1]) kappa = exp(theta[2]) nu = exp(theta[3]) return(-rSPDE::rSPDE.matern.loglike(object = op_cov, Y=Y,                                   A = A, user_kappa=kappa, user_sigma = sigma,                                  user_nu=nu, sigma.e = exp(theta[4]))) } theta0 <- c(get.inital.values.rSPDE(mesh.range = 1, dim = 1),             log(0.1*sqrt(var(as.vector(Y)))))  start_time <- Sys.time() theta <- optim(theta0, mlik_cov, Y = Y, A = A, op_cov = op_cov, method = \"L-BFGS-B\") end_time <- Sys.time()  time_optim <- end_time - start_time  print(data.frame(sigma = c(sigma,exp(theta$par[1])), kappa = c(kappa,exp(theta$par[2])),                   nu = c(nu,exp(theta$par[3])), sigma.e = c(sigma.e,exp(theta$par[4])),                   row.names = c(\"Truth\",\"Estimates\"))) ##              sigma    kappa        nu   sigma.e ## Truth     2.000000 20.00000 0.8000000 0.3000000 ## Estimates 2.476834 19.09341 0.8468107 0.3323609 #Total time print(time_optim) ## Time difference of 8.277187 secs library(optimParallel) #Preparing the parallel  #Checking if we have a limit to the number of cores chk <- Sys.getenv(\"_R_CHECK_LIMIT_CORES_\", \"\") if (nzchar(chk) && chk == \"TRUE\") {     n_cores <- 2L } else {     n_cores <- parallel::detectCores() - 1 }  cl <- makeCluster(n_cores) setDefaultCluster(cl=cl)  start_time <- Sys.time() theta_parallel <- optimParallel(theta0, mlik_cov,                                                 Y = Y, A = A,                                                 op_cov = op_cov) end_time <- Sys.time()  time_optim <- end_time - start_time  print(data.frame(sigma = c(sigma,exp(theta_parallel$par[1])),                   kappa = c(kappa,exp(theta_parallel$par[2])),                   nu = c(nu,exp(theta_parallel$par[3])),                   sigma.e = c(sigma.e,exp(theta_parallel$par[4])),                   row.names = c(\"Truth\",\"Estimates\"))) ##              sigma    kappa        nu   sigma.e ## Truth     2.000000 20.00000 0.8000000 0.3000000 ## Estimates 2.476834 19.09341 0.8468107 0.3323609 #Total time print(time_optim) ## Time difference of 5.777112 secs"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"kringing","dir":"Articles","previous_headings":"Using the approximation","what":"Kringing","title":"Rational approximation with the rSPDE package","text":"Finally, compute kriging prediction process \\(u\\) locations s based observations. specify locations predicted, argument Aprd used. argument observation matrix links mesh locations prediction locations. Let us update CBrSPDEobj object (returned matern.operators() function) fitted parameters: can now perform kringing predict() method: simulated process, observed data, kriging prediction shown following figure.","code":"A.krig <- rSPDE.A1d(s, s) sigma_est = exp(theta$par[1]) kappa_est = exp(theta$par[2]) nu_est = exp(theta$par[3])  op_cov <- update(op_cov, user_kappa=kappa_est,                  user_sigma = sigma_est,                  user_nu = nu_est) u.krig <- predict(op_cov, A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"fitting-a-model-with-replicates","dir":"Articles","previous_headings":"","what":"Fitting a model with replicates","title":"Rational approximation with the rSPDE package","text":"Let us illustrate simulate dataset replicates. , show fit parameters dataset. Recall simulate latent model replicates, set nsim argument number replicates. Let us simulate dataset. use CBrSPDEobj object (returned matern.operators() function) previous example, namely op_cov. Now, let us generate observed values \\(Y\\): Notice \\(Y\\) matrix 20 columns, column containing replicate. Now, remaining code identical previous case. rSPDE.matern.loglike() function automatically identifies replicates fact \\(Y\\) matrix one column.","code":"set.seed(123) n.rep = 20 u.rep <- simulate(op_cov, nsim=n.rep) sigma.e <- 0.3 Y.rep <- A %*% u.rep + sigma.e * matrix(rnorm(n.obs*n.rep), ncol=n.rep) theta0 <- c(get.inital.values.rSPDE(mesh.range = 1, dim = 1),             log(0.1*sqrt(var(as.vector(Y)))))  start_time <- Sys.time() theta <- optimParallel(theta0, mlik_cov, Y = Y.rep, A = A, op_cov = op_cov, method = \"L-BFGS-B\") end_time <- Sys.time()  time_optim <- end_time - start_time  print(data.frame(sigma = c(sigma,exp(theta$par[1])), kappa = c(kappa,exp(theta$par[2])),                   nu = c(nu,exp(theta$par[3])), sigma.e = c(sigma.e,exp(theta$par[4])),                   row.names = c(\"Truth\",\"Estimates\"))) ##              sigma    kappa       nu   sigma.e ## Truth     2.000000 20.00000 0.800000 0.3000000 ## Estimates 2.379152 18.40182 0.810289 0.2931603 #Total time print(time_optim) ## Time difference of 4.102944 secs"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_cov.html","id":"spatial-data-and-parameter-estimation","dir":"Articles","previous_headings":"","what":"Spatial data and parameter estimation","title":"Rational approximation with the rSPDE package","text":"functions used previous examples also work spatial models. need construct mesh domain interest compute matrices needed define operator. tasks can performed, example, using R-INLA package. Let us start defining mesh \\([0,1]\\times [0, 1]\\) compute mass stiffness matrices mesh. important mention using R-INLA package recommend usage R-INLA implementation rational SPDE approach. Let us consider simple Gaussian linear model 30 independent replicates latent spatial field \\(u(\\mathbf{s})\\), observed \\(m\\) locations, \\(\\{\\mathbf{s}_1 , \\ldots , \\mathbf{s}_m \\}\\), replicate. \\(= 1,\\ldots,m,\\) \\[\\begin{align}  y_i &= u_1(\\mathbf{s}_i)+\\varepsilon_i,\\\\ \\vdots &= \\vdots\\\\  y_{+29m} &= u_{30}(\\mathbf{s}_i) + \\varepsilon_{+29m}, \\end{align}\\] \\(\\varepsilon_1,\\ldots,\\varepsilon_{30m}\\) iid normally distributed mean 0 standard deviation 0.1. Let us create FEM mesh:  can now use mesh define rational SPDE approximation order \\(m=2\\) Matérn model fashion one-dimensional case. now simulate latent process standard deviation \\(\\sigma=1\\) range \\(0.1\\). use \\(\\nu=0.5\\) model exponential covariance function. end create model object matern.operators() function: Now let us simulate noisy data use estimate parameters model. construct observation matrix, use R-INLA function inla.spde.make.(). Recall simulate data 30 replicates. first replicate simulated random field well observation locations shown following figure.  now use function rSPDE.matern.loglike() define likelihood. function object-based, sense obtains several quantities needs rSPDE model object. case, example, object op_cov_2d. simplify parameter estimation, create objective function minimize negative log-likelihood, parametrized using logarithm parameter avoid constrained optimization. can now estimate parameter using optimParallel():","code":"library(INLA) n_loc =500 loc_2d_mesh = matrix(runif(n_loc*2),n_loc,2) mesh_2d = inla.mesh.2d(   loc=loc_2d_mesh,   cutoff=0.05,   offset=c(0.1,0.4),   max.edge=c(0.05,0.5) ) plot(mesh_2d, main = \"\") points(loc_2d_mesh[,1],loc_2d_mesh[,2]) nu = 0.5 sigma = 1  range = 0.1 kappa = sqrt(8*nu)/range d = 2 op_cov_2d = matern.operators(mesh=mesh_2d,                                  nu=nu,                                  kappa=kappa,                                  sigma=sigma,                                  m=2) n.rep = 30 u <- simulate(op_cov_2d, nsim=n.rep) A <- inla.spde.make.A(   mesh=mesh_2d,   loc=loc_2d_mesh) sigma.e <- 0.1 Y = A %*% u + matrix(rnorm(n_loc*n.rep),ncol=n.rep) * sigma.e mlik_2d <- function(theta, Y, A, op_cov_2d) {   sigma = exp(theta[1])   kappa = exp(theta[2])   nu = exp(theta[3])   return(-rSPDE::rSPDE.matern.loglike(object = op_cov_2d, Y=Y,                                   A = A, user_kappa=kappa, user_sigma = sigma,                                  user_nu=nu, sigma.e = exp(theta[4]))) } theta0_2d = c(get.inital.values.rSPDE(mesh=mesh_2d),               log(0.1*sqrt(var(as.vector(Y))))) start_time <- Sys.time() pars <- optimParallel(theta0_2d, mlik_2d, Y = Y, A = A, op_cov_2d=op_cov_2d) end_time <- Sys.time() total_time <- end_time - start_time results <- data.frame(sigma = c(sigma, exp(pars$par[1])),                        kappa = c(kappa, exp(pars$par[2])),                       nu = c(nu, exp(pars$par[3])),                       sigma.e = c(sigma.e, exp(pars$par[4])),                       row.names = c(\"True\", \"Estimate\")) print(results) ##             sigma    kappa        nu   sigma.e ## True     1.000000 20.00000 0.5000000 0.1000000 ## Estimate 1.032911 19.18672 0.4259368 0.1004302 #Total time print(total_time) ## Time difference of 12.54402 secs"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"R-INLA implementation of the rational SPDE approach","text":"vignette present R-INLA implementation rational SPDE approach. theoretical details refer reader Rational approximation rSPDE package vignette (Bolin Kirchner 2020)(https://www.tandfonline.com/doi/full/10.1080/10618600.2019.1665537). begin providing step--step illustration use implementation. end consider real world data set consists precipitation measurements Paraná region Brazil. initial model fitting, show change parameters model. end, also provide example replicates. important mention one can improve performance using PARDISO solver. Please, go https://www.pardiso-project.org/r-inla/#license apply license. Also, use inla.pardiso() instructions enable PARDISO sparse library.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"example-with-real-data","dir":"Articles","previous_headings":"","what":"Example with real data","title":"R-INLA implementation of the rational SPDE approach","text":"illustrate implementation rSPDE R-INLA consider dataset available R-INLA. data also used illustrate SPDE approach, see instance book Advanced Spatial Modeling Stochastic Partial Differential Equations Using R INLA also vignette Spatial Statistics using R-INLA Gaussian Markov random fields. See also (Lindgren, Rue, Lindström 2011)(https://rss.onlinelibrary.wiley.com/doi/full/10.1111/j.1467-9868.2011.00777.x) theoretical details standard SPDE approach. data consist precipitation measurements Paraná region Brazil provided Brazilian National Water Agency. data collected 616 gauge stations Paraná state, south Brazil, day 2011.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"an-rspde-model-for-precipitation","dir":"Articles","previous_headings":"Example with real data","what":"An rSPDE model for precipitation","title":"R-INLA implementation of the rational SPDE approach","text":"follow vignette Spatial Statistics using R-INLA Gaussian Markov random fields. precipitation data always positive, assume Gamma distributed. R-INLA uses following parameterization Gamma distribution, \\[\\Gamma(\\mu, c\\phi): \\pi (y) = \\frac{1}{\\Gamma(c\\phi)} \\left(\\frac{c\\phi}{\\mu}\\right)^{c\\phi} y^{c\\phi - 1} \\exp\\left(-\\frac{c\\phi y}{\\mu}\\right) .\\] parameterization, distribution expected value \\(E(x) = \\mu\\) variance \\(V(x) = \\mu^2/(c\\phi)\\), \\(c\\) fixed (known) scaling parameter \\(1/\\phi\\) dispersion parameter. example \\(\\mu\\) modelled using stochastic model includes covariates spatial structure, resulting latent Gaussian model precipitation measurements \\[\\begin{align} y_i\\mid \\mu(s_i), \\theta &\\sim \\Gamma(\\mu(s_i),c\\phi)\\\\ \\log (\\mu(s)) &= \\eta(s) = \\sum_k f_k(c_k(s))+u(s)\\\\ \\theta &\\sim \\pi(\\theta) \\end{align},\\] \\(y_i\\) denotes measurement taken location \\(s_i\\), \\(c_k(s)\\) covariates, \\(u(s)\\) mean-zero Gaussian Matérn field, \\(\\theta\\) vector containing parameters model, including smoothness field. , using rSPDE model also able estimate smoothness latent field.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"examining-the-data","dir":"Articles","previous_headings":"Example with real data","what":"Examining the data","title":"R-INLA implementation of the rational SPDE approach","text":"using R-INLA. install R-INLA go R-INLA Project. begin loading libraries need get data build plots. Let us load data border region data frame contains daily measurements 616 stations year 2011, well coordinates altitude information measurement stations. analyze full spatio-temporal data set, instead look total precipitation January, calculate next snippet code, extract coordinates altitudes remove locations missing values. Let us build plot precipitations:  red line figure shows coast line, expect distance coast good covariate precipitation. covariate available, let us calculate observation location: Now, let us plot precipitation function possible covariates:","code":"library(gridExtra) library(ggplot2) library(lattice) library(INLA) library(splancs) library(fields) data(PRprec) data(PRborder) Y <- rowMeans(PRprec[, 3 + 1:31]) ind <- !is.na(Y) Y <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) alt <- PRprec$Altitude[ind] seaDist <- apply(spDists(coords, PRborder[1034:1078, ],                           longlat = TRUE), 1, min) par(mfrow = c(2, 2)) plot(coords[, 1], Y, cex = 0.5, xlab = \"Longitude\") plot(coords[, 2], Y, cex = 0.5, xlab = \"Latitude\") plot(seaDist, Y, cex = 0.5, xlab = \"Distance to sea\") plot(alt, Y, cex = 0.5, xlab = \"Altitude\") par(mfrow = c(1, 1))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"creating-the-rspde-model","dir":"Articles","previous_headings":"Example with real data","what":"Creating the rSPDE model","title":"R-INLA implementation of the rational SPDE approach","text":"use R-INLA implementation rSPDE model need load functions: rSPDE-INLA implementation reminiscent R-INLA, usage straightforward R-INLA users. instance, create rSPDE model, one rspde.matern() place inla.spde2.matern(). create index, one use rspde.make.index() place inla.spde.make.index(). create matrix, one use rspde.make.() place inla.spde.make.(), . main differences comparing arguments rSPDE-INLA implementation standard SPDE implementation R-INLA, nu rspde_order arguments, present rSPDE-INLA implementation. see use arguments.","code":"library(rSPDE)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"mesh","dir":"Articles","previous_headings":"Example with real data > Creating the rSPDE model","what":"Mesh","title":"R-INLA implementation of the rational SPDE approach","text":"can use R-INLA creating mesh. Let us create mesh based non-convex hull avoid adding many small triangles outside domain interest:","code":"prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2) plot(prmesh, asp = 1, main = \"\") lines(PRborder, col = 3) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\")"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"the-observation-matrix-a","dir":"Articles","previous_headings":"Example with real data > Creating the rSPDE model","what":"The observation matrix (A)","title":"R-INLA implementation of the rational SPDE approach","text":"now create \\(\\) matrix, connects mesh observation locations create rSPDE model. task, mentioned earlier, need use rSPDEspecific function, whose name reminiscent R-INLA’s standard SPDE approach, namely rspde.make.() (place R-INLA’s inla.spde.make.()). reason need specific function size \\(\\) matrix depends order rational approximation. details can found introduction Rational approximation rSPDE package vignette. default order 2 covariance-based rational approximation. mentioned introduction Rational approximation rSPDE package vignette, approximation order 2 covariance-based rational approximation approximately computational cost standard rational approximation order 1. Recall latent process \\(u\\) solution \\[(\\kappa^2 -\\Delta)^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(\\alpha = \\nu + d/2\\). want estimate \\(\\tau,\\kappa\\) \\(\\nu\\). also option fix smoothness parameter \\(\\nu\\) predefined value estimate \\(\\tau\\) \\(\\kappa\\). default rSPDE-INLA implementation estimates three parameters. first example assume want rational approximation order 2, also want estimate smoothness parameter \\(\\nu\\). end can use rspde.make.() function. Since assume order 2 want estimate smoothness, default options function, required parameters simply mesh locations:","code":"Abar <- rspde.make.A(mesh = prmesh, loc = coords)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"setting-up-the-rspde-model","dir":"Articles","previous_headings":"Example with real data > Creating the rSPDE model","what":"Setting up the rSPDE model","title":"R-INLA implementation of the rational SPDE approach","text":"set rSPDEmodel, need mesh. default assume want estimate smoothness parameter \\(\\nu\\) covariance-based rational approximation order 2. Later vignette also see options setting rSPDE models keeping smoothness parameter fixed /increasing order covariance-based rational approximation. Therefore, set model use rspde.matern() function: Notice function reminiscent R-INLA’s inla.spde2.matern() function. pattern tried keep consistent. rSPDE versions R-INLA function either replace inla inla.spde inla.spde2 rspde.","code":"rspde_model <- rspde.matern(mesh = prmesh)"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"the-inla-stack","dir":"Articles","previous_headings":"Example with real data > Creating the rSPDE model","what":"The inla.stack","title":"R-INLA implementation of the rational SPDE approach","text":"Since covariates already evaluated observation locations, want apply \\(\\) matrix spatial effect fixed effects. can use inla.stack() function. difference, however, need use function rspde.make.index() (place standard inla.spde.make.index()) create index. one using default options, , estimate smoothness parameter \\(\\nu\\) rational approximation order 2, usage rspde.make.index() identical usage inla.spde.make.index(): can create stack standard manner: observation matrix \\(\\) applied spatial effect intercept identity observation matrix, denoted \\(1\\), applied covariates. means covariates unaffected observation matrix. observation matrices \\(=list(Abar,1)\\) used link corresponding elements effects-list observations. Thus model latent spatial field mesh.index intercept linked log-expectation observations, .e. \\(\\eta(s)\\), \\(\\)-matrix. covariates, hand, linked directly \\(\\eta(s)\\). stk.dat object defined implies following principal linkage model components observations \\[\\eta(s) \\sim x(s) + \\text{ Intercept} + \\text{long} + \\text{lat}+ \\text{seaDist}.\\] \\(\\eta(s)\\) used observation-likelihood, \\[y_i\\mid \\eta(s_i),\\theta \\sim \\Gamma(\\exp(\\eta (s_i)), c\\phi).\\]","code":"mesh.index <- rspde.make.index(name = \"field\", mesh = prmesh) stk.dat <- inla.stack(   data = list(y = Y), A = list(Abar, 1), tag = \"est\",    effects = list(c(mesh.index,                     list(Intercept = 1)),                   list(long = inla.group(coords[, 1]),                        lat = inla.group(coords[,2]),                       seaDist = inla.group(seaDist))))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"model-fitting","dir":"Articles","previous_headings":"Example with real data","what":"Model fitting","title":"R-INLA implementation of the rational SPDE approach","text":"build model using distance sea \\(x_i\\) covariate improper CAR(1) model \\(\\beta_{ij}=1(\\sim j)\\), R-INLA calls random walk order 1. -1 added remove R’s implicit intercept, replaced explicit +Intercept created stack. fit model proceed standard SPDE approach simply call inla().","code":"f.s <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +    f(field, model = rspde_model) rspde_fit <-rspde.inla(f.s, family = \"Gamma\", data = inla.stack.data(stk.dat),              verbose = FALSE,              control.inla=list(int.strategy='eb'),             control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"inla-results","dir":"Articles","previous_headings":"Example with real data","what":"INLA results","title":"R-INLA implementation of the rational SPDE approach","text":"can look summaries posterior distributions parameters, example fixed effects (.e. intercept) hyper-parameters (.e. dispersion gamma likelihood, precision RW1, parameters spatial field): Let \\(\\theta_1 = \\textrm{Theta1}\\), \\(\\theta_2=\\textrm{Theta2}\\) \\(\\theta_3=\\textrm{Theta3}\\). terms SPDE \\[(\\kappa^2 - \\Delta)^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(\\alpha = \\nu + d/2\\), \\[\\tau = \\exp(\\theta_1),\\quad \\kappa = \\exp(\\theta_2), \\] default \\[\\nu = 4\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] number 4 comes upper bound \\(\\nu\\), discussed later vignette. general, \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big),\\] \\(\\nu_{UB}\\) value upper bound smoothness parameter \\(\\nu\\). Another choice prior \\(\\nu\\) truncated lognormal distribution also discussed later vignette.","code":"summary(rspde_fit) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.23, Running = 17, Post = 0.0763, Total = 20.3  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant mode   kld ## Intercept 0.647 0.019       0.61    0.647      0.685   NA 0.005 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.182    0.919     11.453 ## Precision for seaDist                          9248.647 6452.631   2172.223 ## Theta1 for field                                 -1.291    0.399     -2.106 ## Theta2 for field                                  1.112    0.260      0.601 ## Theta3 for field                                 -0.815    0.333     -1.447 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.155     15.071   13.108 ## Precision for seaDist                          7594.274  26081.725 5084.713 ## Theta1 for field                                 -1.277     -0.539   -1.230 ## Theta2 for field                                  1.111      1.627    1.108 ## Theta3 for field                                 -0.825     -0.138   -0.859 ##  ## Marginal log-Likelihood:  -1264.18  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"rspde-inla-results","dir":"Articles","previous_headings":"Example with real data","what":"rSPDE-INLA results","title":"R-INLA implementation of the rational SPDE approach","text":"can obtain outputs respect parameters original scale using function rspde.result(): can also plot posterior densities:  function reminiscent inla.spde.result() function main difference summary() plot() methods implemented.","code":"result_fit <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result_fit) ##           mean       sd 0.025quant 0.5quant 0.975quant    mode ## tau   0.297227 0.118383   0.122420 0.278925   0.580672 0.24177 ## kappa 3.143130 0.827709   1.831590 3.036870   5.063810 2.83546 ## nu    1.243840 0.280839   0.764391 1.218320   1.857600 1.15525 par(mfrow=c(1,3)) plot(result_fit, caption=c(\"tau\",\"kappa\",\"nu\"))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"predictions","dir":"Articles","previous_headings":"Example with real data","what":"Predictions","title":"R-INLA implementation of the rational SPDE approach","text":"Let us now obtain predictions (.e. kriging) expected precipitation dense grid region. begin creating grid want predictions. end, can use rspde.mesh.projector() function. function arguments function inla.mesh.projector(), difference rSPDE version also argument nu argument rspde_order. Thus, proceed fashion R-INLA’s standard SPDE implementation: lattice contains 150 × 100 locations. One can easily change resolution kriging prediction changing nxy. Let us find cells outside region interest plot estimates . Let us plot locations prediction:  Now, ways calculate kriging prediction. simplest way evaluate mean individual random effects linear predictor calculate exponential sum (since \\(\\mu(s)=\\exp(\\eta(s))\\) ). accurate way calculate prediction jointly estimation, unfortunately quite computationally expensive prediction fine grid. However, illustration, proceed option show one can . end, first, link prediction coordinates mesh nodes \\(\\) matrix Since using distance sea covariate, also calculate covariate prediction locations. now make stack prediction locations. data prediction locations, set y= NA. join stack estimation stack. joint estimation takes , therefore turn computation certain things interested , marginals random effect. also use simplified integration strategy (actually using posterior mode hyper-parameters) command control.inla = list(int.strategy = \"eb\"), .e. empirical Bayes. extract indices prediction nodes extract mean standard deviation response: Finally, plot results:","code":"nxy <- c(150, 100) projgrid <- rspde.mesh.projector(prmesh, xlim = range(PRborder[, 1]),  ylim = range(PRborder[,2]), dims = nxy) xy.in <- inout(projgrid$lattice$loc, cbind(PRborder[, 1], PRborder[, 2])) coord.prd <- projgrid$lattice$loc[xy.in, ] plot(coord.prd, type = \"p\", cex = 0.1) lines(PRborder) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\") A.prd <- projgrid$proj$A[xy.in, ] seaDist.prd <- apply(spDists(coord.prd,      PRborder[1034:1078, ], longlat = TRUE), 1, min) ef.prd = list(c(mesh.index, list(Intercept = 1)),      list(long = inla.group(coord.prd[,      1]), lat = inla.group(coord.prd[, 2]),      seaDist = inla.group(seaDist.prd))) stk.prd <- inla.stack(data = list(y = NA),      A = list(A.prd, 1), tag = \"prd\",      effects = ef.prd) stk.all <- inla.stack(stk.dat, stk.prd) rspde_fitprd <-rspde.inla(f.s, family = \"Gamma\",               data = inla.stack.data(stk.all),               control.predictor = list(A = inla.stack.A(stk.all),                                       compute = TRUE, link = 1),              control.compute = list(return.marginals = FALSE,                                      return.marginals.predictor = FALSE),              control.inla = list(int.strategy = \"eb\")) id.prd <- inla.stack.index(stk.all, \"prd\")$data sd.prd <- m.prd <- matrix(NA, nxy[1], nxy[2]) m.prd[xy.in] <- rspde_fitprd$summary.fitted.values$mean[id.prd] sd.prd[xy.in] <- rspde_fitprd$summary.fitted.values$sd[id.prd] #Plot the predictions grid.arrange(levelplot(m.prd, col.regions = tim.colors(99),               xlab = \"\", ylab = \"\", main = \"mean\",                         scales = list(draw = FALSE)),               levelplot(sd.prd, col.regions = topo.colors(99),               xlab = \"\", ylab = \"\", scales = list(draw = FALSE),                         main = \"standard deviation\"))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"further-options-of-the-rspde-inla-implementation","dir":"Articles","previous_headings":"","what":"Further options of the rSPDE-INLA implementation","title":"R-INLA implementation of the rational SPDE approach","text":"now discuss arguments introduced R-INLA implementation rational approximation present R-INLA’s standard SPDE implementation. case provide illustrative example.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-upper-bound-for-the-smoothness-parameter","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the upper bound for the smoothness parameter","title":"R-INLA implementation of the rational SPDE approach","text":"fit rspde.matern() model need provide upper bound smoothness parameter \\(\\nu\\). reason sparsity precision matrix kept fixed R-INLA’s estimation higher value \\(\\nu\\) denser precision matrix gets. means higher value \\(\\nu\\), higher computational cost fit model. Therefore, ideally, want choose upper bound \\(\\nu\\) small possible. change value upper bound smoothness parameter, must change argument nu_upper_bound. default value nu_upper_bound 4. common choices nu_upper_bound 2 1. clear discussion smaller value nu_upper_bound faster estimation procedure . However, choose value nu_upper_bound low, “correct” value \\(\\nu\\) might belong interval \\((0,\\nu_{UB})\\), \\(\\nu_{UB}\\) value nu_upper_bound. Hence, one might forced increase nu_upper_bound estimate , , obviously increase computational cost need one estimation. Let us illustrate considering model considered precipitation Paraná region Brazil consider nu_upper_bound equal 2, generally good choice nu_upper_bound. simply use function rspde.matern() argument nu_upper_bound set 2: Since considering default rspde_order, \\(\\) matrix mesh index objects previous ones. Let us update formula fit model: Let us see summary fit: Let us compare cost previous fit, default value nu_upper_bound 4: can see fit nu_upper_bound equal 2 considerably faster. Finally, let us get result user’s scale see estimate \\(\\nu\\):","code":"rspde_model_2 <- rspde.matern(mesh = prmesh, nu_upper_bound = 2) f.s.2 <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +    f(field, model = rspde_model_2)   rspde_fit_2 <-rspde.inla(f.s.2, family = \"Gamma\", data = inla.stack.data(stk.dat),              verbose = FALSE,              control.inla=list(int.strategy='eb'),             control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE)) summary(rspde_fit_2) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.09, Running = 17.7, Post = 0.253, Total = 21  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant mode   kld ## Intercept 0.648 0.018      0.613    0.648      0.683   NA 0.006 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.127    0.955     11.308 ## Precision for seaDist                          9242.615 6990.905   2388.153 ## Theta1 for field                                 -1.708    0.378     -2.485 ## Theta2 for field                                  1.205    0.268      0.659 ## Theta3 for field                                  0.943    0.590     -0.124 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.107     15.070   13.093 ## Precision for seaDist                          7298.100  27903.885 4874.285 ## Theta1 for field                                 -1.695     -0.998   -1.645 ## Theta2 for field                                  1.212      1.715    1.239 ## Theta3 for field                                  0.909      2.192    0.774 ##  ## Marginal log-Likelihood:  -1261.38  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') # nu_upper_bound = 4 rspde_fit$cpu.used ##         Pre     Running        Post       Total  ##  3.23150206 17.02211785  0.07628417 20.32990408 #nu_upper_bound = 2 rspde_fit_2$cpu.used ##        Pre    Running       Post      Total  ##  3.0882590 17.6862991  0.2525401 21.0270982 result_fit_2 <- rspde.result(rspde_fit_2, \"field\", rspde_model_2) summary(result_fit_2) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## tau   0.194296 0.0727502  0.0840478 0.184018   0.365972 0.162321 ## kappa 3.457360 0.9188240  1.9439700 3.364550   5.527340 3.180800 ## nu    1.410710 0.2244030  0.9436770 1.423260   1.796650 1.454030"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-order-of-the-rational-approximation","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the order of the rational approximation","title":"R-INLA implementation of the rational SPDE approach","text":"change order rational approximation set argument rspde_order desired value. current available possibilities 1,2,3,…, 8. higher order rational approximation, accurate results , however, higher computational cost . default rspde_order 2 generally good choice reasonably accurate. See vignette Rational approximation rSPDE package details order rational approximation comparison Matérn covariance. Let us fit model covariance-based rational approximation order 3. Notice since changing order rational approximation, , changing rspde_order argument, need recompute \\(\\) matrix mesh index. Therefore, proceed follows: build new model: create new \\(\\) matrix: create new index: Now remaining standard: Let us see summary: can see summary computational cost significantly increased. Let us compare cost rspde_order=3 nu_upper_bound=2 cost rspde_order=2 nu_upper_bound=4: Let us now see summary original scale: Let us see plots posterior marginal densities:","code":"rspde_model_order_3 <- rspde.matern(mesh = prmesh, rspde_order = 3,                                nu_upper_bound = 2) Abar_3 <- rspde.make.A(mesh = prmesh, loc = coords, rspde_order = 3) mesh.index.3 <- rspde.make.index(name = \"field\", mesh = prmesh,                                   rspde_order = 3) stk.dat.3 <- inla.stack(   data = list(y = Y), A = list(Abar_3, 1), tag = \"est\",    effects = list(c(mesh.index.3,                     list(Intercept = 1)),                   list(long = inla.group(coords[, 1]),                        lat = inla.group(coords[,2]),                       seaDist = inla.group(seaDist))))  f.s.3 <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_order_3)  rspde_fit_order_3 <-rspde.inla(f.s.3, family = \"Gamma\", data = inla.stack.data(stk.dat.3),                      verbose = FALSE,              control.inla=list(int.strategy='eb'),             control.predictor = list(A = inla.stack.A(stk.dat.3), compute = TRUE)) summary(rspde_fit_order_3) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.07, Running = 25.4, Post = 0.0775, Total = 28.5  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant mode   kld ## Intercept 0.486 0.013       0.46    0.486      0.512   NA 0.006 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                   mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.16    0.888     11.488 ## Precision for seaDist                          9148.15 6870.741   2240.575 ## Theta1 for field                                 -1.63    0.498     -2.615 ## Theta2 for field                                  1.21    0.299      0.609 ## Theta3 for field                                  0.80    0.417      0.005 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.128     14.986   13.074 ## Precision for seaDist                          7249.258  27282.466 4818.098 ## Theta1 for field                                 -1.628     -0.657   -1.618 ## Theta2 for field                                  1.213      1.785    1.230 ## Theta3 for field                                  0.791      1.645    0.754 ##  ## Marginal log-Likelihood:  -1262.90  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') # nu_upper_bound = 4 rspde_fit$cpu.used ##         Pre     Running        Post       Total  ##  3.23150206 17.02211785  0.07628417 20.32990408 #nu_upper_bound = 2 rspde_fit_order_3$cpu.used ##         Pre     Running        Post       Total  ##  3.07285690 25.39377809  0.07751679 28.54415178 result_fit_order_3 <- rspde.result(rspde_fit_order_3, \"field\", rspde_model_order_3) summary(result_fit_order_3) ##           mean       sd 0.025quant 0.5quant 0.975quant     mode ## tau   0.221366 0.115118  0.0736039 0.196437   0.515309 0.152885 ## kappa 3.497730 1.047800  1.8472800 3.364420   5.930730 3.109960 ## nu    1.366740 0.172857  1.0054400 1.375530   1.674610 1.391930 par(mfrow=c(1,3)) plot(result_fit_order_3, caption=c(\"tau\",\"kappa\",\"nu\"))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"estimating-models-with-fixed-smoothness","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Estimating models with fixed smoothness","title":"R-INLA implementation of the rational SPDE approach","text":"can fix smoothness, say \\(\\nu\\), model providing non-NULL positive value nu. smoothness, \\(\\nu\\), fixed, can two possibilities: \\(\\alpha = \\nu + d/2\\) integer; \\(\\alpha = \\nu + d/2\\) integer. first case, .e., \\(\\alpha\\) integer, much less computational cost. Furthermore, \\(\\) matrix different \\(\\) matrix non-integer \\(\\alpha\\). \\(\\) matrix values \\(\\nu\\) \\(\\alpha\\) integer. , \\(\\) matrix cases need computed . holds index obtained rspde.make.index() function. second case \\(\\) matrix depends order rational approximation \\(\\nu\\). Therefore, matrix \\(\\) already computed rspde_order, \\(\\) matrix values \\(\\nu\\) \\(\\alpha\\) non-integer rspde_order. holds index obtained rspde.make.index() function. \\(\\nu\\) fixed, parameters returned R-INLA \\[\\kappa = \\exp(\\theta_1)\\quad\\hbox{}\\quad\\tau = \\exp(\\theta_2).\\] now provide illustrations scenarios. also noteworthy just case estimate \\(\\nu\\), can also change order rational approximation changing value rspde_order. illustrations fixed \\(\\nu\\) , consider order rational approximation 2, , default order.","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"estimating-models-with-fixed-smoothness-and-non-integer-alpha","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation > Estimating models with fixed smoothness","what":"Estimating models with fixed smoothness and non-integer \\(\\alpha\\)","title":"R-INLA implementation of the rational SPDE approach","text":"Recall : \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] Thus, illustrate, let us consider fixed \\(\\nu\\) given mean \\(\\nu\\) obtained first model considered vignette, namely, fit given rspde_fit, approximately \\(\\nu = 1.21\\). Notice \\(\\nu\\), value \\(\\alpha\\) non-integer, can use \\(\\) matrix index first fitted model, also order 2. Therefore, build new model set nu 1.21: Let us now fit model: summary: Now, summary original scale:","code":"rspde_model_fix <- rspde.matern(mesh = prmesh, rspde_order = 2,                                        nu = 1.21) f.s.fix <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_fix)  rspde_fix <-rspde.inla(f.s.fix, family = \"Gamma\", data = inla.stack.data(stk.dat),                  verbose = FALSE,                control.inla=list(int.strategy='eb'),               control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE)) summary(rspde_fix) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.08, Running = 12.8, Post = 0.0621, Total = 15.9  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant mode   kld ## Intercept 0.648 0.018      0.612    0.648      0.684   NA 0.006 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                   mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.24    0.932     11.498 ## Precision for seaDist                          8839.45 5889.419   2453.823 ## Theta1 for field                                 -1.33    0.309     -1.946 ## Theta2 for field                                  1.18    0.267      0.654 ##                                                0.5quant 0.975quant    mode ## Precision parameter for the Gamma observations    13.21     15.175   13.14 ## Precision for seaDist                           7303.41  24404.247 5154.92 ## Theta1 for field                                  -1.33     -0.726   -1.32 ## Theta2 for field                                   1.18      1.710    1.17 ##  ## Marginal log-Likelihood:  -1261.28  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fix <- rspde.result(rspde_fix, \"field\", rspde_model_fix) summary(result_fix) ##           mean        sd 0.025quant 0.5quant 0.975quant    mode ## tau   0.276892 0.0863789   0.143978 0.264717   0.480494 0.24157 ## kappa 3.365200 0.9117330   1.934630 3.243130   5.493670 3.01060"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"estimating-models-with-fixed-smoothness-and-integer-alpha","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation > Estimating models with fixed smoothness","what":"Estimating models with fixed smoothness and integer \\(\\alpha\\)","title":"R-INLA implementation of the rational SPDE approach","text":"Since dimension \\(d=2\\), \\(\\nu>0\\), smallest value \\(\\nu\\) makes \\(\\alpha = \\nu + 1\\) integer \\(\\nu=1\\). value also close estimated mean first model fitted enclosed posterior marginal density \\(\\nu\\) first fit. Therefore, let us fit model \\(\\nu=1\\). end need compute new \\(\\) matrix: new index: create new model (remember set nu=1): remaining standard: Let us check summary: check summary user’s scale:","code":"Abar.int <- rspde.make.A(mesh = prmesh, loc = coords,                        nu = 1) mesh.index.int <- rspde.make.index(name = \"field\", mesh = prmesh,                                   nu = 1) rspde_model_fix_int1 <- rspde.matern(mesh = prmesh,                                      nu = 1) stk.dat.int <- inla.stack(   data = list(y = Y), A = list(Abar.int, 1), tag = \"est\",    effects = list(c(mesh.index.int,                     list(Intercept = 1)),                   list(long = inla.group(coords[, 1]),                        lat = inla.group(coords[,2]),                       seaDist = inla.group(seaDist))))  f.s.fix.int.1 <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_fix_int1)  rspde_fix_int_1 <-rspde.inla(f.s.fix.int.1, family = \"Gamma\",                        data = inla.stack.data(stk.dat.int), verbose = FALSE,                    control.inla=list(int.strategy='eb'),                   control.predictor = list(A = inla.stack.A(stk.dat.int),                                             compute = TRUE)) summary(rspde_fix_int_1) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.08, Running = 3.68, Post = 0.0416, Total = 6.8  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant mode   kld ## Intercept 1.944 0.056      1.835    1.944      2.053   NA 0.006 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                    mean       sd 0.025quant ## Precision parameter for the Gamma observations   13.278    0.902     11.582 ## Precision for seaDist                          9943.670 7982.016   2472.218 ## Theta1 for field                                 -0.911    0.278     -1.461 ## Theta2 for field                                  1.079    0.301      0.488 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations    13.25     15.133   13.202 ## Precision for seaDist                           7641.44  31034.463 4992.712 ## Theta1 for field                                  -0.91     -0.366   -0.906 ## Theta2 for field                                   1.08      1.675    1.074 ##  ## Marginal log-Likelihood:  -1261.48  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') rspde_result_int <- rspde.result(rspde_fix_int_1, \"field\", rspde_model_fix_int1) summary(rspde_result_int) ##           mean       sd 0.025quant 0.5quant 0.975quant     mode ## tau   0.417869 0.117139   0.233198 0.402718   0.690245 0.374201 ## kappa 3.076280 0.942519   1.637260 2.938410   5.310160 2.672890"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-priors","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the priors","title":"R-INLA implementation of the rational SPDE approach","text":"begin recalling fitted rSPDE model R-INLA contains parameters \\(\\textrm{Theta1}\\), \\(\\textrm{Theta2}\\) \\(\\textrm{Theta3}\\). Let, , \\(\\theta_1 = \\textrm{Theta1}\\), \\(\\theta_2=\\textrm{Theta2}\\) \\(\\theta_3=\\textrm{Theta3}\\). terms SPDE \\[(\\kappa^2 - \\Delta)^{\\alpha/2}(\\tau u) = \\mathcal{W},\\] \\(\\alpha = \\nu + d/2\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-priors-of-tau-and-kappa","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation > Changing the priors","what":"Changing the priors of \\(\\tau\\) and \\(\\kappa\\)","title":"R-INLA implementation of the rational SPDE approach","text":"begin dealing \\(\\tau\\) \\(\\kappa\\). \\[\\tau = \\exp(\\theta_1),\\quad \\kappa = \\exp(\\theta_2).\\] rspde.matern() function assumes lognormal prior distribution \\(\\tau\\) \\(\\kappa\\). prior distribution obtained assuming \\(\\theta_1\\) \\(\\theta_2\\) follow normal distributions. default assume \\(\\theta_1\\) \\(\\theta_2\\) independent follow normal distributions \\(\\theta_1\\sim N(\\log(\\tau_0), 1)\\) \\(\\theta_2\\sim N(\\log(\\kappa_0), 1)\\). \\(\\kappa_0\\) suitably defined terms mesh \\(\\tau_0\\) defined terms \\(\\kappa_0\\) prior smoothness parameter. one wants define prior \\[\\theta_1 \\sim N(\\text{mean_theta_1}, \\text{sd_theta_1}),\\] one can simply set argument prior.tau = list(meanlog=mean_theta_1, sdlog=sd_theta_1). Analogously, define prior \\[\\theta_2 \\sim N(\\text{mean_theta_2}, \\text{sd_theta_2}),\\] one can set argument prior.kappa = list(meanlog=mean_theta_2, sdlog=sd_theta_2). important mention , default, initial values \\(\\tau\\) \\(\\kappa\\) \\(\\exp(\\text{mean_theta_1})\\) \\(\\exp(\\text{mean_theta_2})\\), respectively. , user change parameters, also change initial values, initial values \\(\\tau\\) \\(\\kappa\\) , respectively, \\(\\tau_0\\) \\(\\kappa_0\\). one sets prior.tau = list(meanlog=mean_theta_1), prior \\(\\theta_1\\) \\[\\theta_1 \\sim N(\\text{mean_theta_1}, 1),\\] whereas, one sets, prior.tau = list(sdlog=sd_theta_1), prior \\[\\theta_1 \\sim N(\\log(\\tau_0), \\text{sd_theta_1}).\\] Analogously, one sets prior.kappa = list(meanlog=mean_theta_2), prior \\(\\theta_2\\) \\[\\theta_2 \\sim N(\\text{mean_theta_2}, 1),\\] whereas, one sets, prior.kappa = list(sdlog=sd_theta_2), prior \\[\\theta_2 \\sim N(\\log(\\kappa_0), \\text{sd_theta_2}).\\]","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-prior-of-nu","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation > Changing the priors","what":"Changing the prior of \\(\\nu\\)","title":"R-INLA implementation of the rational SPDE approach","text":"Finally, let us consider smoothness parameter \\(\\nu\\). default, assume \\(\\nu\\) follows beta distribution interval \\((0,\\nu_{UB})\\), \\(\\nu_{UB}\\) upper bound \\(\\nu\\), mean \\(\\nu_0=\\min\\{1, \\nu_{UB}/2\\}\\) variance \\(\\frac{\\nu_0(\\nu_{UB}-\\nu_0)}{1+\\phi_0}\\), call \\(\\phi_0\\) precision parameter, whose default value \\[\\phi_0 = \\max\\Big\\{\\frac{\\nu_{UB}}{\\nu_0}, \\frac{\\nu_{UB}}{\\nu_{UB}-\\nu_0}\\Big\\} + \\phi_{inc}.\\] parameter \\(\\phi_{inc}\\) increment ensure prior beta density boundary values equal zero (boundary values defined either continuity limits). default value \\(\\phi_{inc}\\) 1. value \\(\\phi_{inc}\\) can changed changing argument nu.prec.inc rspde.matern() function. higher value \\(\\phi_{inc}\\) (, value nu.prec.inc) informative prior distribution becomes. Let us denote beta distribution support \\((0,\\nu_{UB})\\), mean \\(\\mu\\) precision parameter \\(\\phi\\) \\(\\mathcal{B}_{\\nu_{UB}}(\\mu,\\phi)\\). want \\(\\nu\\) prior \\[\\nu \\sim \\mathcal{B}_{\\nu_{UB}}(\\text{nu_1},\\text{prec_1}),\\] one simply needs set prior.nu = list(mean=nu_1, prec=prec_1). one sets prior.nu = list(mean=nu_1), \\(\\nu\\) prior \\[\\nu \\sim \\mathcal{B}_{\\nu_{UB}}(\\text{nu_1},\\phi_1),\\] \\[\\phi_1 = \\max\\Big\\{\\frac{\\nu_{UB}}{\\text{nu_1}}, \\frac{\\nu_{UB}}{\\nu_{UB}-\\text{nu_1}}\\Big\\} + \\text{nu.prec.inc}.\\] one sets prior.nu = list(prec=prec_1), \\(\\nu\\) prior \\[\\nu\\sim \\mathcal{B}_{\\nu_{UB}}(\\nu_0, \\text{prec_1}).\\] also noteworthy , terms R-INLA’s parameters, \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] important mention , default, beta prior distribution chosen smoothness parameter \\(\\nu\\), initial value \\(\\nu\\) mean prior beta distribution. , user change parameter, also change initial value, initial value \\(\\nu\\) \\(\\min\\{1,\\nu_{UB}/2\\}\\). can another possibility prior distribution \\(\\nu\\), namely, truncated lognormal distribution. truncated lognormal distribution defined following sense. assume \\(\\log(\\nu)\\) prior distribution given truncated normal distribution support \\((-\\infty,\\log(\\nu_{UB}))\\), \\(\\nu_{UB}\\) upper bound \\(\\nu\\), location parameter \\(\\mu_0 =\\log(\\nu_0)= \\log\\Big(\\min\\{1,\\nu_{UB}/2\\}\\Big)\\) scale parameter \\(\\sigma_0 = 1\\). precisely, let \\(\\Phi(\\cdot; \\mu,\\sigma)\\) stand cumulative distribution function (CDF) normal distribution mean \\(\\mu\\) standard deviation \\(\\sigma\\). , \\(\\log(\\nu)\\) cumulative distribution function given \\[F_{\\log(\\nu)}(x) = \\frac{\\Phi(x;\\mu_0,\\sigma_0)}{\\Phi(\\nu_{UB})},\\quad x\\leq \\nu_{UB},\\] \\(F_{\\log(\\nu)}(x) = 1\\) \\(x>\\nu_{UB}\\). call \\(\\mu_0\\) \\(\\sigma_0\\) log-location log-scale parameters \\(\\nu\\), respectively, say \\(\\log(\\nu)\\) follows truncated normal distribution location parameter \\(\\mu_0\\) scale parameter \\(\\sigma_0\\). also assume , terms R-INLA’s parameters, \\[\\nu = \\nu_{UB}\\Big(\\frac{\\exp(\\theta_3)}{1+\\exp(\\theta_3)}\\Big).\\] change prior distribution \\(\\nu\\) truncated lognormal distribution, need set argument prior.nu.dist=\"lognormal\". change parameters prior distribution , say, log_nu_1 log_sigma_1, one can simply set prior.nu = list(loglocation=log_nu_1, logscale=sigma_1). one sets prior.nu = list(loglocation=log_nu_1), prior \\(\\theta_3\\) truncated normal normal distribution location parameter log_nu_1 scale parameter 1. Analogously, one sets, prior.nu = list(logscale=sigma_1), prior \\(\\theta_3\\) truncated normal distribution location parameter \\(\\log(\\nu_0)= \\log\\Big(\\min\\{1,\\nu_{UB}/2\\}\\Big)\\) scale parameter sigma_1. important mention , default, truncated lognormal prior distribution chosen smoothness parameter \\(\\nu\\), initial value \\(\\nu\\) exponential log-location parameter \\(\\nu\\). , user change parameter, also change initial value, initial value \\(\\nu\\) \\(\\min\\{1,\\nu_{UB}/2\\}\\). Let us consider example dataset used first model vignette change prior distribution \\(\\nu\\) beta lognormal. Let us also set nu_upper_bound 2. Since change rspde_order fixing \\(\\nu\\), can use \\(\\) matrix index first example. Therefore, update formula fit model: summary: Also, can summary user’s scale: plot posterior marginal densities","code":"rspde_model_ln <- rspde.matern(mesh = prmesh, prior.nu.dist = \"lognormal\",                             nu_upper_bound = 2) f.s.ln <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +    f(field, model = rspde_model_ln)   rspde_fit_ln <-rspde.inla(f.s.ln, family = \"Gamma\", data = inla.stack.data(stk.dat),              verbose = FALSE,              control.inla=list(int.strategy='eb'),             control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE)) summary(rspde_fit_ln) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.14, Running = 15, Post = 0.0573, Total = 18.2  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant mode   kld ## Intercept 0.647 0.018      0.611    0.647      0.683   NA 0.006 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                    mean      sd 0.025quant ## Precision parameter for the Gamma observations   13.310   0.157     13.024 ## Precision for seaDist                          9092.409 913.632   7374.434 ## Theta1 for field                                 -1.206   0.203     -1.249 ## Theta2 for field                                  1.153   0.059      0.996 ## Theta3 for field                                  0.259   0.256     -0.836 ##                                                 0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations    13.528     13.785   13.274 ## Precision for seaDist                          10208.710  11979.708 8775.637 ## Theta1 for field                                  -0.691     -0.342   -1.291 ## Theta2 for field                                   1.099      1.291    1.168 ## Theta3 for field                                  -0.394      0.313    0.368 ##  ## Marginal log-Likelihood:  -1259.97  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit_ln <- rspde.result(rspde_fit_ln, \"field\", rspde_model_ln) summary(result_fit_ln) ##           mean        sd 0.025quant 0.5quant 0.975quant     mode ## tau   0.292982 0.0720957   0.187623 0.281334   0.468466 0.262569 ## kappa 3.171890 0.1840880   2.781020 3.182700   3.506710 3.203860 ## nu    1.154170 0.1407280   0.846764 1.165720   1.401790 1.195230 par(mfrow=c(1,3)) plot(result_fit_ln, caption=c(\"tau\",\"kappa\",\"nu\"))"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"changing-the-initial-values","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Changing the initial values","title":"R-INLA implementation of the rational SPDE approach","text":"inital values used R-INLA’s optimization algorithm can changed setting arguments start.ltau, start.lkappa start.nu. start.ltau initial value \\(\\log(\\tau)\\), , logarithm \\(\\tau\\). start.lkappa inital value \\(\\log(\\kappa)\\), , logarithm \\(\\kappa\\). start.nu initial value \\(\\nu\\). Notice initial value log scale. One can change initial value one parameters. instance, let us consider example precipitation data, rspde_order=3, change initial values ones close fitted value considering default rspde_order (2): Since already computed \\(\\) matrix index rspde_order=3, update formula fit: summary:","code":"rspde_model_order_3_start <- rspde.matern(mesh = prmesh, rspde_order = 3,                                nu_upper_bound = 2,                               start.lkappa = result_fit$summary.log.kappa$mean,                               start.ltau = result_fit$summary.log.tau$mean,                               start.nu = result_fit$summary.nu$mean) f.s.3.start <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +   f(field, model = rspde_model_order_3_start)  rspde_fit_order_3_start <-rspde.inla(f.s.3.start, family = \"Gamma\",                                  data = inla.stack.data(stk.dat.3),                      verbose = FALSE,              control.inla=list(int.strategy='eb'),             control.predictor = list(A = inla.stack.A(stk.dat.3),                                       compute = TRUE)) summary(rspde_fit_order_3_start) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.12, Running = 19.9, Post = 0.0655, Total = 23.1  ## Fixed effects: ##            mean    sd 0.025quant 0.5quant 0.975quant mode   kld ## Intercept 0.486 0.013      0.461    0.486      0.511   NA 0.007 ##  ## Random effects: ##   Name     Model ##     seaDist RW1 model ##    field RGeneric2 ##  ## Model hyperparameters: ##                                                     mean       sd 0.025quant ## Precision parameter for the Gamma observations    13.209    0.937     11.424 ## Precision for seaDist                          10258.694 7831.461   2968.295 ## Theta1 for field                                  -1.674    0.565     -2.836 ## Theta2 for field                                   1.150    0.303      0.503 ## Theta3 for field                                   0.894    0.728     -0.396 ##                                                0.5quant 0.975quant     mode ## Precision parameter for the Gamma observations   13.190     15.113   13.176 ## Precision for seaDist                          8003.984  31133.574 5364.011 ## Theta1 for field                                 -1.651     -0.621   -1.569 ## Theta2 for field                                  1.171      1.687    1.252 ## Theta3 for field                                  0.842      2.444    0.646 ##  ## Marginal log-Likelihood:  -1262.31  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"choosing-between-the-optimized-and-non-optimized-versions","dir":"Articles","previous_headings":"Further options of the rSPDE-INLA implementation","what":"Choosing between the optimized and non-optimized versions","title":"R-INLA implementation of the rational SPDE approach","text":"rspde.matern() function optimized version, default non-optimized version. take less time fit optimized object fit non-optimized one. However requires sparsity analysis creating model object. size data small might happen time analyze sparsity plus time fit model larger time fit non-optimized model, require sparsity analysis creating model object. also another option optimized model, sharp argument. sharp argument used optimize TRUE. sharp=TRUE time fit model less time fit model sharp=FALSE. However, sparsity analysis takes time sharp=TRUE sharp=FALSE. Let us create three model objects rspde_order=1 precipitation data compare times. begin creating \\(\\) matrix, index inla.stack object three models use: Now, let us create three models compute time took create model objects: Now, let us fit models: Finally, let us compare times: Therefore, see example one benefits using optimized version.","code":"Abar.1 <- rspde.make.A(mesh = prmesh, loc = coords, rspde_order=1) mesh.index.1 <- rspde.make.index(name = \"field\", mesh = prmesh, rspde_order=1) stk.dat.1 <- inla.stack(   data = list(y = Y), A = list(Abar.1, 1), tag = \"est\",    effects = list(c(mesh.index.1,                     list(Intercept = 1)),                   list(long = inla.group(coords[, 1]),                        lat = inla.group(coords[,2]),                       seaDist = inla.group(seaDist)))) #Creating the optimized and sharp model start_time <- Sys.time() rspde_model_opt_sharp <- rspde.matern(mesh = prmesh,                                        rspde_order = 1) end_time <- Sys.time() time_opt_sharp <- end_time - start_time  #Creating the optimized non-sharp model start_time <- Sys.time() rspde_model_opt_notsharp <- rspde.matern(mesh = prmesh,                                           rspde_order = 1,                                          sharp=FALSE) end_time <- Sys.time() time_opt_notsharp <- end_time - start_time  #Creating the non-optimized model start_time <- Sys.time() rspde_model_nonopt <- rspde.matern(mesh = prmesh,                                     rspde_order = 1,                                     optimize = FALSE) end_time <- Sys.time() time_nonopt <- end_time - start_time f.s.opt.sharp <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +    f(field, model = rspde_model_opt_sharp)   rspde_fit_opt_sharp <-rspde.inla(f.s.opt.sharp, family = \"Gamma\",                             data = inla.stack.data(stk.dat.1),                              verbose = FALSE,                              control.inla=list(int.strategy='eb'),                             control.predictor=list(A=inla.stack.A(stk.dat.1),                                                       compute = FALSE))  f.s.opt.notsharp <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +    f(field, model = rspde_model_opt_notsharp)   rspde_fit_opt_notsharp <-rspde.inla(f.s.opt.notsharp, family = \"Gamma\",                                 data = inla.stack.data(stk.dat.1),                                 verbose = FALSE,                                 control.inla=list(int.strategy='eb'),                                control.predictor=list(A=inla.stack.A(stk.dat.1),                                                          compute = FALSE))  f.s.nonopt <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +    f(field, model = rspde_model_nonopt)   rspde_fit_nonopt <-rspde.inla(f.s.nonopt, family = \"Gamma\",                           data = inla.stack.data(stk.dat.1),                           verbose = FALSE,                           control.inla=list(int.strategy='eb'),                          control.predictor=list(A=inla.stack.A(stk.dat.1),                                                    compute = FALSE)) `Time to create model` <- c(time_opt_sharp, time_opt_notsharp, time_nonopt) `Time to fit the model` <- c(rspde_fit_opt_sharp$cpu.used[[2]],                               rspde_fit_opt_notsharp$cpu.used[[2]],                              rspde_fit_nonopt$cpu.used[[2]]) `Total time` <- `Time to create model` + `Time to fit the model` Model <- c(\"Opt & sharp\", \"Opt & not sharp\", \"Non-opt\") result_table <- data.frame(Model, `Time to create model`,                             `Time to fit the model`,                             `Total time`) result_table ##             Model Time.to.create.model Time.to.fit.the.model    Total.time ## 1     Opt & sharp        1.210711 secs              9.550103 10.76081 secs ## 2 Opt & not sharp        1.125997 secs             10.585880 11.71188 secs ## 3         Non-opt        0.848007 secs             17.243756 18.09176 secs"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"an-example-with-replicates","dir":"Articles","previous_headings":"","what":"An example with replicates","title":"R-INLA implementation of the rational SPDE approach","text":"example simulate data replicates. use example considered Rational approximation rSPDE package vignette (difference way data organized). also refer reader vignette description function matern.operators(), along methods (instance, simulate() method).","code":""},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"simulating-the-data","dir":"Articles","previous_headings":"An example with replicates","what":"Simulating the data","title":"R-INLA implementation of the rational SPDE approach","text":"Let us consider simple Gaussian linear model 30 independent replicates latent spatial field \\(x(\\mathbf{s})\\), observed \\(m\\) locations, \\(\\{\\mathbf{s}_1 , \\ldots , \\mathbf{s}_m \\}\\), replicate. \\(= 1,\\ldots,m,\\) \\[\\begin{align}  y_i &= x_1(\\mathbf{s}_i)+\\varepsilon_i,\\\\ \\vdots &= \\vdots\\\\  y_{+29m} &= x_{30}(\\mathbf{s}_i) + \\varepsilon_{+29m}, \\end{align}\\] \\(\\varepsilon_1,\\ldots,\\varepsilon_{30m}\\) iid normally distributed mean 0 standard deviation 0.1. use basis function representation \\(x(\\cdot)\\) define \\(\\) matrix linking point locations mesh. also need account fact 30 replicates locations. end, \\(\\) matrix need can generated inla.spde.make.() function. reason sampling \\(x(\\cdot)\\) directly latent vector described introduction Rational approximation rSPDE package vignette. begin creating mesh:  compute \\(\\) matrix, needed simulation, connects observation locations mesh: Notice simulated data, use \\(\\) matrix inla.spde.make.() function. now simulate latent process standard deviation \\(\\sigma=1\\) range \\(0.1\\). use \\(\\nu=0.5\\) model exponential covariance function. end create model object matern.operators() function: details function can found Rational approximation rSPDE package vignette. simulate latent process need use simulate() method operator_information object. obtain simulated data \\(y\\) connecting \\(\\) matrix adding gaussian noise. first replicate simulated random field well observation locations shown following figure.","code":"m = 200 loc_2d_mesh = matrix(runif(m*2),m,2) mesh_2d = inla.mesh.2d(   loc=loc_2d_mesh,   cutoff=0.05,   offset=c(0.1,0.4),   max.edge=c(0.05,0.5) ) plot(mesh_2d, main=\"\") points(loc_2d_mesh[,1],loc_2d_mesh[,2]) n.rep = 30 A=inla.spde.make.A(   mesh=mesh_2d,   loc=loc_2d_mesh,   index=rep(1:m,times=n.rep),   repl=rep(1:n.rep,each=m)) nu = 0.5 sigma = 1  range = 0.1 kappa = sqrt(8*nu)/range tau = sqrt(gamma(nu) / (sigma^2 * kappa^(2*nu) * (4*pi) * gamma(nu + 1))) d=2 operator_information = matern.operators (mesh=mesh_2d,                                  nu=nu,                                  kappa=kappa,                                  sigma=sigma,                                  m=2) set.seed(1) u = simulate(operator_information, nsim=n.rep) y = as.vector(A %*% as.vector(u)) +   rnorm(m*n.rep)*0.1"},{"path":"https://davidbolin.github.io/rSPDE/articles/rspde_inla.html","id":"fitting-the-r-inla-rspde-model","dir":"Articles","previous_headings":"An example with replicates","what":"Fitting the R-INLA rSPDE model","title":"R-INLA implementation of the rational SPDE approach","text":"Let us use rational SPDE approach fit data. begin creating \\(\\) matrix index replicates, inla.stack object. important notice since replicates provide index repl arguments rspde.make.() function, also argument n.repl rspde.make.index() function. behave identically R-INLA’s counterparts, namely, inla.spde.make.() inla.make.index(). now create model object. illustration purposes, use “BRASIL” rational approximation algorithm fit model. Finally, create formula fit. extremely important forget replicate argument building formula inla() function produce warning might fit meaningless model. can get summary: summary user’s scale:","code":"Abar.rep <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh, index=rep(1:m,times=n.rep),                      repl=rep(1:n.rep,each=m) ) mesh.index.rep <- rspde.make.index(name = \"field\", mesh = mesh_2d,                                 n.repl=n.rep)  st.dat.rep=inla.stack(   data=list(y=y),   A=Abar.rep,   effects=mesh.index.rep) rspde_model.rep <- rspde.matern(mesh = mesh_2d, type.rational.approx=\"brasil\") f.rep =   y ~ -1 + f(field, model=rspde_model.rep,     replicate=field.repl) rspde_fit.rep =  rspde.inla(f.rep,        data=inla.stack.data(st.dat.rep),        family=\"gaussian\",        control.predictor=          list(A=inla.stack.A(st.dat.rep))) summary(rspde_fit.rep) ##  ## Call: ##    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  ##    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  ##    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  ##    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  ##    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  ##    = control.compute, \", \" control.predictor = control.predictor,  ##    control.family = control.family, \", \" control.inla = control.inla,  ##    control.fixed = control.fixed, \", \" control.mode = control.mode,  ##    control.expert = control.expert, \", \" control.hazard = control.hazard,  ##    control.lincomb = control.lincomb, \", \" control.update =  ##    control.update, control.lp.scale = control.lp.scale, \", \"  ##    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  ##    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  ##    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  ##    working.directory = working.directory, \", \" silent = silent, inla.mode  ##    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  ##    .parent.frame)\")  ## Time used: ##     Pre = 3.4, Running = 142, Post = 1.34, Total = 146  ## Random effects: ##   Name     Model ##     field RGeneric2 ##  ## Model hyperparameters: ##                                          mean    sd 0.025quant 0.5quant ## Precision for the Gaussian observations 89.48 3.596      81.88    89.55 ## Theta1 for field                        -3.45 0.518      -4.67    -3.35 ## Theta2 for field                         3.07 0.018       3.04     3.07 ## Theta3 for field                        -1.69 0.053      -1.79    -1.69 ##                                         0.975quant  mode ## Precision for the Gaussian observations      97.52 89.04 ## Theta1 for field                             -2.74 -2.85 ## Theta2 for field                              3.11  3.07 ## Theta3 for field                             -1.58 -1.70 ##  ## Marginal log-Likelihood:  -4364.02  ##  is computed  ## Posterior summaries for the linear predictor and the fitted values are computed ## (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') result_fit_rep <- rspde.result(rspde_fit.rep, \"field\", rspde_model.rep) summary(result_fit_rep) ##             mean        sd  0.025quant   0.5quant 0.975quant       mode ## tau    0.0358432 0.0154998  0.00947369  0.0351112  0.0644975  0.0286177 ## kappa 21.6191000 0.3769090 20.91290000 21.6061000 22.3919000 21.5727000 ## nu     0.6237200 0.0279001  0.57363500  0.6219030  0.6829250  0.6167650 result_df <- data.frame(parameter = c(\"tau\",\"kappa\",\"nu\"),                       true = c(tau, kappa, nu),                        mean = c(result_fit_rep$summary.tau$mean,                                result_fit_rep$summary.kappa$mean,                               result_fit_rep$summary.nu$mean),                         mode = c(result_fit_rep$summary.tau$mode,                                   result_fit_rep$summary.kappa$mode,                                  result_fit_rep$summary.nu$mode)) print(result_df) ##   parameter        true        mean        mode ## 1       tau  0.08920621  0.03584315  0.02861768 ## 2     kappa 20.00000000 21.61914846 21.57271202 ## 3        nu  0.50000000  0.62371998  0.61676539"},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Bolin. Maintainer, author. Alexandre Simas. Author.","code":""},{"path":"https://davidbolin.github.io/rSPDE/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"David Bolin, Kristin Kirchner (2020), rational SPDE approach Gaussian random fields general smoothness Journal Computational Graphical Statistics, 29:2, 274-285.","code":"@Article{,   title = {The rational {SPDE} approach for {Gaussian} random fields with general smoothness},   author = {David Bolin and Kristin Kirchner},   journal = {Journal of Computational and Graphical Statistics},   year = {2020},   volume = {29},   number = {2},   pages = {274--285},   doi = {10.1080/10618600.2019.1665537}, }"},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"the-rspde-package-","dir":"","previous_headings":"","what":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"rSPDE R package used computing rational approximations fractional SPDEs. rational approximations can used computatially efficient statistical inference. Basic statistical operations likelihood evaluations kriging predictions using fractional approximations also implemented. package also contains interface R-INLA.","code":""},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"Several popular Gaussian random field models can represented solutions stochastic partial differential equations (SPDEs) form \\[ L^{\\beta}(\\tau u) = \\mathcal{W}. \\] \\(\\mathcal{W}\\) Gaussian white noise, \\(L\\) second-order differential operator, fractional power \\(\\beta>0\\) determines smoothness \\(u\\), \\(\\tau>0\\) scales variance \\(u\\). simplest example model \\(\\mathbb {R}^d\\) \\(L = \\kappa^2 - \\Delta\\), results Gaussian random field \\(u\\) Matérn covariance function \\[ C(h) = \\dfrac{ \\sigma^2 }{ 2 ^ {\\nu-1} \\Gamma (\\nu)} (\\kappa h) ^ {\\nu} K_{\\nu} (\\kappa h). \\] \\(2 \\beta\\) integer domain \\(\\mathcal {D}\\) model defined bounded, \\(u\\) can approximated Gaussian Markov random field (GMRF) \\(\\mathbf { \\mathrm{u} }\\) via finite element method (FEM) SPDE. Specifically, approximation can written \\[ u_h (s) = \\sum _ { =1 } ^ n u_i \\varphi_i (s). \\] \\(\\{\\varphi_i\\}\\) piecewise linear basis functions defined triangulation \\(\\mathcal {D}\\) vector weights \\( \\mathbf { \\mathrm { u } } = (u_1,\\ldots,u_n)^\\top \\) normally distributed, \\(N(\\mathbf { \\mathrm{u} }, \\tilde{ \\mathbf { \\mathrm{Q} } }^{-1})\\), \\(\\tilde{ \\mathbf{ \\mathrm{Q} } }\\) sparse. See explicit link Gaussian fields Gaussian Markov random fields: stochastic partial differential equation approach details. rSPDE package provides corresponding computationally efficient approximations case \\(\\beta\\) general fractional power. main idea combine FEM approximation rational approximation fractional operator. result, one can easily inference prediction using fractional SPDE models \\[ ( \\kappa^2-\\Delta )^\\beta u = \\mathcal{ W }. \\] particular, allows bayesian inference model parameters, including fractional parameter \\(\\beta\\). illustration purposes, package contains simple FEM implementation models R. See introduction rSPDE package vignette introduction package. Rational approximation rSPDE package Operator-based rational approximation vignettes provide introductions create fit rSPDE models. introduction R-INLA implementation rSPDE models see R-INLA implementation rational SPDE approach. rSPDE documentation contains descriptions examples functions rSPDE package.","code":""},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"installation-instructions","dir":"","previous_headings":"","what":"Installation instructions","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"latest CRAN release package can installed directly CRAN install.packages(\"rSPDE\"). latest stable version (sometimes slightly recent CRAN version), can installed using command R. development version can installed using command want install package using remotes::install_github-method Windows, first need install Rtools add paths Rtools gcc Windows PATH environment variable. can done current R session using commands variables rtools gcc need changed Rtools installed directly C:, gcc’s version might need changed depending version Rtools.","code":"remotes::install_github(\"davidbolin/rspde\", ref = \"stable\") remotes::install_github(\"davidbolin/rspde\", ref = \"devel\") rtools = \"C:\\\\Rtools\\\\bin\" gcc = \"C:\\\\Rtools\\\\gcc-4.6.3\\\\bin\" Sys.setenv(PATH = paste(c(gcc, rtools, Sys.getenv(\"PATH\")), collapse = \";\"))"},{"path":"https://davidbolin.github.io/rSPDE/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Rational Approximations of Fractional Stochastic Partial\n        Differential Equations","text":"illustrate rSPDE package kriging example. data consist precipitation measurements Paraná region Brazil provided Brazilian National Water Agency. data collected 616 gauge stations Paraná state, south Brazil, day 2011. analyse full spatio-temporal data set, instead look total precipitation January details dataset commands refer reader rSPDE-INLA Vignette.","code":"library(rSPDE) library(ggplot2) library(INLA) library(fields) library(splancs) library(gridExtra) library(lattice)  #Load the data data(PRprec) data(PRborder)  #Get the precipitation in January Y <- rowMeans(PRprec[, 3 + 1:31])  #Treat the data and plot ind <- !is.na(Y) Y <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) alt <- PRprec$Altitude[ind]  ggplot() + geom_point(aes(x = coords[, 1], y = coords[, 2], colour = Y),                       size = 2,                       alpha = 1) +    scale_colour_gradientn(colours = tim.colors(100)) +    geom_path(aes(x = PRborder[, 1], y = PRborder[, 2])) +    geom_path(aes(x = PRborder[1034:1078, 1],                  y = PRborder[1034:1078, 2]), colour = \"red\") #Get distance from the sea seaDist <- apply(spDists(coords, PRborder[1034:1078, ], longlat = TRUE), 1,                   min)                   #Create the mesh prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2) plot(prmesh, asp = 1, main = \"\") lines(PRborder, col = 3) points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = \"red\") #Create the observation matrix Abar <- rspde.make.A(mesh = prmesh, loc = coords)  #Create the rspde model object rspde_model <- rspde.matern(mesh = prmesh)  #Create the index and inla.stack object mesh.index <- rspde.make.index(name = \"field\", mesh = prmesh) stk.dat <- inla.stack(   data = list(y = Y), A = list(Abar, 1), tag = \"est\",    effects = list(c(mesh.index,                     list(Intercept = 1)),                   list(long = inla.group(coords[, 1]),                        lat = inla.group(coords[,2]),                       seaDist = inla.group(seaDist))))                        #Create the formula object and fit the model f.s <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +    f(field, model = rspde_model)     rspde_fit <- inla(f.s, family = \"Gamma\", data = inla.stack.data(stk.dat),              verbose = FALSE,              control.inla=list(int.strategy='eb'),             control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE))              summary(rspde_fit) #> #>  #> Call: #>    c(\"inla(formula = f.s, family = \\\"Gamma\\\", data = inla.stack.data(stk.dat), \", #>\" verbose = FALSE, control.predictor = list(A = inla.stack.A(stk.dat), \", \"  #>compute = TRUE), control.inla = list(int.strategy = \\\"eb\\\"))\" )  #> Time used: #>     Pre = 4.4, Running = 28.1, Post = 0.106, Total = 32.7  #> Fixed effects: #>            mean    sd 0.025quant 0.5quant 0.975quant  mode kld #> Intercept 0.648 0.019      0.611    0.648      0.686 0.648   0 #>  #> Random effects: #>   Name     Model #>     seaDist RW1 model #>    field RGeneric2 #>  #> Model hyperparameters: #>                                                    mean       sd 0.025quant 0.5quant 0.975quant     mode #> Precision parameter for the Gamma observations   13.200    0.876     11.548   13.177     14.990   13.139 #> Precision for seaDist                          9378.627 6990.227   2651.630 7372.387  27837.501 5025.442 #> Theta1 for field                                 -1.147    0.311     -1.788   -1.157     -0.521   -1.174 #> Theta2 for field                                  1.089    0.116      0.846    1.090      1.315    1.099 #> Theta3 for field                                 -0.899    0.179     -1.293   -0.898     -0.531   -0.884 #>  #> Marginal log-Likelihood:  -1261.74  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)')  #Get the summary on the user's scale result_fit <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result_fit) #> #>          mean       sd 0.025quant 0.5quant 0.975quant     mode #>tau   0.332668 0.106630   0.176185 0.315581   0.595938 0.282519 #>kappa 2.988480 0.344316   2.355250 2.979790   3.711410 2.962190 #>nu    1.161300 0.145758   0.884741 1.160160   1.457410 1.159710  #Plot the posterior densities par(mfrow=c(1,3)) plot(result_fit) #Create a grid to predict nxy <- c(150, 100) projgrid <- rspde.mesh.projector(prmesh, xlim = range(PRborder[, 1]),  ylim = range(PRborder[,2]), dims = nxy) xy.in <- inout(projgrid$lattice$loc, cbind(PRborder[, 1], PRborder[, 2])) coord.prd <- projgrid$lattice$loc[xy.in, ]  #Compute A matrix and seaDist at predict locations and build the stack A.prd <- projgrid$proj$A[xy.in, ] seaDist.prd <- apply(spDists(coord.prd,      PRborder[1034:1078, ], longlat = TRUE), 1, min) ef.prd = list(c(mesh.index, list(Intercept = 1)),      list(long = inla.group(coord.prd[,      1]), lat = inla.group(coord.prd[, 2]),      seaDist = inla.group(seaDist.prd))) stk.prd <- inla.stack(data = list(y = NA),      A = list(A.prd, 1), tag = \"prd\",      effects = ef.prd) stk.all <- inla.stack(stk.dat, stk.prd)  rspde_fitprd <- inla(f.s, family = \"Gamma\",               data = inla.stack.data(stk.all),               control.predictor = list(A = inla.stack.A(stk.all),              compute = TRUE, link = 1))  id.prd <- inla.stack.index(stk.all, \"prd\")$data sd.prd <- m.prd <- matrix(NA, nxy[1], nxy[2]) m.prd[xy.in] <- rspde_fitprd$summary.fitted.values$mean[id.prd] sd.prd[xy.in] <- rspde_fitprd$summary.fitted.values$sd[id.prd]  #Plot the predictions grid.arrange(levelplot(m.prd, col.regions = tim.colors(99),               xlab = \"\", ylab = \"\", main = \"mean\",                         scales = list(draw = FALSE)),               levelplot(sd.prd, col.regions = topo.colors(99),               xlab = \"\", ylab = \"\", scales = list(draw = FALSE),                         main = \"standard deviation\"))"},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":null,"dir":"Reference","previous_headings":"","what":"The 1d folded Matern covariance function — folded.matern.covariance.1d","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"folded.matern.covariance.1d evaluates 1d folded Matern covariance function interval \\([0,L]\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"","code":"folded.matern.covariance.1d(   h,   m,   kappa,   nu,   sigma,   L = 1,   N = 10,   boundary = c(\"neumann\", \"dirichlet\", \"periodic\") )"},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"h, m Vectors arguments covariance function. kappa Range parameter. nu Shape parameter. sigma Standard deviation. L upper bound interval [0,L]. default, L=1. N truncation parameter. boundary boundary condition. possible conditions \"neumann\" (default), \"dirichlet\" \"periodic\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"matrix corresponding covariance values.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"folded.matern.covariance.1d evaluates 1d folded Matern covariance function interval \\([0,L]\\) different boundary conditions. periodic boundary conditions $$C_{\\mathcal{P}}(h,m) = \\sum_{k=-\\infty}^{\\infty} (C(h-m+2kL),$$ Neumann boundary conditions $$C_{\\mathcal{N}}(h,m) = \\sum_{k=-\\infty}^{\\infty} (C(h-m+2kL)+C(h+m+2kL)),$$ Dirichlet boundary conditions: $$C_{\\mathcal{D}}(h,m) = \\sum_{k=-\\infty}^{\\infty} (C(h-m+2kL)-C(h+m+2kL)),$$ \\(C(\\cdot)\\) Matern covariance function: $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h).$$ consider truncation: $$C_{{\\mathcal{P}},N}(h,m) = \\sum_{k=-N}^{N} C(h-m+2kL), C_{\\mathcal{N},N}(h,m) = \\sum_{k=-\\infty}^{\\infty} (C(h-m+2kL)+C(h+m+2kL)),$$ $$C_{\\mathcal{D},N}(h,m) = \\sum_{k=-N}^{N} (C(h-m+2kL)-C(h+m+2kL)).$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.1d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The 1d folded Matern covariance function — folded.matern.covariance.1d","text":"","code":"x = seq(from = 0, to = 1, length.out = 101) plot(x, folded.matern.covariance.1d(rep(0.5,length(x)),x, kappa = 10, nu = 1/5, sigma = 1),      type = \"l\", ylab = \"C(h)\", xlab = \"h\")"},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":null,"dir":"Reference","previous_headings":"","what":"The 2d folded Matern covariance function — folded.matern.covariance.2d","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"folded.matern.covariance.2d evaluates 2d folded Matern covariance function interval \\([0,L]\\times [0,L]\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"","code":"folded.matern.covariance.2d(   h,   m,   kappa,   nu,   sigma,   L = 1,   N = 10,   boundary = c(\"neumann\", \"dirichlet\", \"periodic\", \"R2\") )"},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"h, m Vectors two coordinates. kappa Range parameter. nu Shape parameter. sigma Standard deviation. L upper bound square \\([0,L]\\times [0,L]\\). default, L=1. N truncation parameter. boundary boundary condition. possible conditions \"neumann\" (default), \"dirichlet\", \"periodic\" \"R2\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"correspoding covariance.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"folded.matern.covariance.2d evaluates 1d folded Matern covariance function interval \\([0,L]\\times [0,L]\\) different boundary conditions. periodic boundary conditions $$C_{\\mathcal{P}}((h_1,h_2),(m_1,m_2)) = \\sum_{k_2=-\\infty}^\\infty \\sum_{k_1=-\\infty}^{\\infty} (C(\\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\\|),$$ Neumann boundary conditions $$C_{\\mathcal{N}}((h_1,h_2),(m_1,m_2)) = \\sum_{k_2=-\\infty}^\\infty \\sum_{k_1=-\\infty}^{\\infty} (C(\\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\\|)+C(\\|(h_1-m_1+2k_1L,h_2+m_2+2k_2L)\\|)+C(\\|(h_1+m_1+2k_1L,h_2-m_2+2k_2L)\\|)+C(\\|(h_1+m_1+2k_1L,h_2+m_2+2k_2L)\\|)),$$ Dirichlet boundary conditions: $$C_{\\mathcal{D}}((h_1,h_2),(m_1,m_2)) = \\sum_{k_2=-\\infty}^\\infty \\sum_{k_1=-\\infty}^{\\infty} (C(\\|(h_1-m_1+2k_1L,h_2-m_2+2k_2L)\\|)-C(\\|(h_1-m_1+2k_1L,h_2+m_2+2k_2L)\\|)-C(\\|(h_1+m_1+2k_1L,h_2-m_2+2k_2L)\\|)+C(\\|(h_1+m_1+2k_1L,h_2+m_2+2k_2L)\\|)),$$ \\(C(\\cdot)\\) Matern covariance function: $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h).$$ consider truncation \\(k_1,k_2\\) \\(-N\\) \\(N\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/folded.matern.covariance.2d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The 2d folded Matern covariance function — folded.matern.covariance.2d","text":"","code":"h = c(0.5,0.5) m = c(0.5,0.5) folded.matern.covariance.2d(h,m, kappa = 10, nu = 1/5, sigma = 1) #> [1] 1.000043"},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational approximations of fractional operators — fractional.operators","title":"Rational approximations of fractional operators — fractional.operators","text":"fractional.operators used computing approximation, can used inference simulation, fractional SPDE $$L^\\beta (\\tau u(s)) = W.$$ \\(L\\) differential operator, \\(\\beta>0\\) fractional power, \\(\\tau\\) positive scalar vector scales variance solution \\(u\\), \\(W\\) white noise.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational approximations of fractional operators — fractional.operators","text":"","code":"fractional.operators(L, beta, C, scale.factor, m = 1, tau = 1)"},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rational approximations of fractional operators — fractional.operators","text":"L finite element discretization operator \\(L\\). beta positive fractional power. C mass matrix finite element discretization. scale.factor constant \\(c\\) lower bound smallest eigenvalue non-discretized operator \\(L\\). m order rational approximation, needs positive integer. default value 1. Higer values gives accurate approximation, computationally expensive use inference. Currently, largest value m implemented 4. tau constant vector scales variance solution. default value 1.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rational approximations of fractional operators — fractional.operators","text":"fractional.operators returns object class \"rSPDEobj\". object contains following quantities: Pl operator \\(P_l\\). Pr operator \\(P_r\\). C mass lumped mass matrix. Ci inverse C. m order rational approximation. beta fractional power. type String indicating type approximation. Q matrix t(Pl)%*%solve(C,Pl). type String indicating type approximation. Pl.factors List elements can used assemble \\(P_l\\). Pr.factors List elements can used assemble \\(P_r\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational approximations of fractional operators — fractional.operators","text":"approximation based rational approximation fractional operator, resulting approximate model form $$P_l u(s) = P_r W,$$ \\(P_j = p_j(L)\\) non-fractional operators defined terms polynomials \\(p_j\\) \\(j=l,r\\). order \\(p_r\\) given m order \\(p_l\\) \\(m + m_\\beta\\) \\(m_\\beta\\) integer part \\(\\beta\\) \\(\\beta>1\\) \\(m_\\beta = 1\\) otherwise. discrete approximation can written \\(u = P_r x\\) \\(x \\sim N(0,Q^{-1})\\) \\(Q = P_l^T C^{-1} P_l\\). Note matrices \\(P_r\\) \\(Q\\) may ill-conditioned \\(m>1\\). case, methods operator.operations used operations involving matrices, since methods numerically stable.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/fractional.operators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rational approximations of fractional operators — fractional.operators","text":"","code":"#Compute rational approximation of a Gaussian process with a  #Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  #create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  #compute rational approximation of covariance function at 0.5 tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2*nu) * (4*pi)^(1/2) * gamma(nu+1/2))) op <- fractional.operators(L = fem$G + kappa^2*fem$C, beta = (nu + 1/2)/2,                            C=fem$C, scale.factor = kappa^2, tau = tau)  v = t(rSPDE.A1d(x,0.5)) c.approx = Sigma.mult(op,v)  #plot the result and compare with the true Matern covariance plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma), type = \"l\", ylab = \"C(h)\",      xlab=\"h\", main = \"Matern covariance and rational approximations\") lines(x, c.approx, col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/get.inital.values.rSPDE.html","id":null,"dir":"Reference","previous_headings":"","what":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.inital.values.rSPDE","title":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.inital.values.rSPDE","text":"Auxiliar function obtain domain-based initial values log-likelihood optimization rSPDE models latent stationary Gaussian Matern model","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/get.inital.values.rSPDE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.inital.values.rSPDE","text":"","code":"get.inital.values.rSPDE(   mesh = NULL,   mesh.range = NULL,   dim = NULL,   include.nu = TRUE,   log.scale = TRUE,   include.tau = FALSE,   nu_upper_bound = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/get.inital.values.rSPDE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.inital.values.rSPDE","text":"mesh INLA mesh mesh.range range mesh. dim dimension domain. include.nu also provide initial guess nu? log.scale results provided log scale? include.tau tau returned instead sigma? nu_upper_bound upper bound nu considered?","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/get.inital.values.rSPDE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Initial values for log-likelihood optimization in rSPDE models\nwith a latent stationary Gaussian Matern model — get.inital.values.rSPDE","text":"vector form (theta_1,theta_2,theta_3) theta_1 initial guess tau, theta_2 initial guess kappa theta_3 initial guess nu.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/get.sparsity.graph.rspde.html","id":null,"dir":"Reference","previous_headings":"","what":"Sparsity graph for rSPDE models — get.sparsity.graph.rspde","title":"Sparsity graph for rSPDE models — get.sparsity.graph.rspde","text":"Creates sparsity graph rSPDE models","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/get.sparsity.graph.rspde.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sparsity graph for rSPDE models — get.sparsity.graph.rspde","text":"","code":"get.sparsity.graph.rspde(   mesh = NULL,   fem_mesh_matrices = NULL,   nu,   force_non_integer = FALSE,   rspde_order = 2,   sharp = TRUE,   dim = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/get.sparsity.graph.rspde.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sparsity graph for rSPDE models — get.sparsity.graph.rspde","text":"mesh INLA mesh, optional fem_mesh_matrices list containing FEM-related matrices. list contain elements C, G, G_2, G_3, etc. Optional, provided mesh provided. nu smoothness parameter force_non_integer nu treated non_integer? rspde_order order covariance-based rational SPDE approach. sharp graph correct sparsity (costs perform sparsity analysis) upper bound sparsity? dim dimension, optional. provided mesh provided.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/get.sparsity.graph.rspde.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sparsity graph for rSPDE models — get.sparsity.graph.rspde","text":"sparsity graph rSPDE models used R-INLA interface.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":null,"dir":"Reference","previous_headings":"","what":"The Matern covariance function — matern.covariance","title":"The Matern covariance function — matern.covariance","text":"matern.covariance evaluates Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h).$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"The Matern covariance function — matern.covariance","text":"","code":"matern.covariance(h, kappa, nu, sigma)"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"The Matern covariance function — matern.covariance","text":"h Distances evaluate covariance function . kappa Range parameter. nu Shape parameter. sigma Standard deviation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"The Matern covariance function — matern.covariance","text":"vector values C(h).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.covariance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"The Matern covariance function — matern.covariance","text":"","code":"x = seq(from = 0, to = 1, length.out = 101) plot(x, matern.covariance(abs(x - 0.5), kappa = 10, nu = 1/5, sigma = 1),      type = \"l\", ylab = \"C(h)\", xlab = \"h\")"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter-based log-likelihood for a latent Gaussian Matern model using a rational SPDE approximation — matern.loglike","title":"Parameter-based log-likelihood for a latent Gaussian Matern model using a rational SPDE approximation — matern.loglike","text":"function evaluates log-likelihood function Gaussian process Matern covariance function, observed Gaussian measurement noise: \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables. latent model approximated using rational approximation fractional SPDE model corresponding Gaussian process.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameter-based log-likelihood for a latent Gaussian Matern model using a rational SPDE approximation — matern.loglike","text":"","code":"matern.loglike(   kappa,   sigma,   nu,   sigma.e,   Y,   G,   C,   A,   mu = 0,   d = 2,   m = 1,   type = c(\"covariance\", \"operator\"),   pivot = TRUE )"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameter-based log-likelihood for a latent Gaussian Matern model using a rational SPDE approximation — matern.loglike","text":"kappa Range parameter latent process. sigma Standard deviation latent process. nu Shape parameter latent process. sigma.e standard deviation measurement noise. Y observations, either vector matrix columns correspond independent replicates observations. G stiffness matrix finite element discretization domain. C mass matrix finite element discretization domain. matrix linking measurement locations basis FEM approximation latent model. mu Expectation vector latent field (default = 0). d dimension domain. default value 2. m order rational approximation, needs positive integer. default value 1. type type rational approximation. options \"covariance\" \"operator\". default \"covariance\". pivot pivoting used Cholesky decompositions? Default TRUE","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameter-based log-likelihood for a latent Gaussian Matern model using a rational SPDE approximation — matern.loglike","text":"log-likelihood value.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parameter-based log-likelihood for a latent Gaussian Matern model using a rational SPDE approximation — matern.loglike","text":"","code":"#this example illustrates how the function can be used for maximum likelihood estimation set.seed(123) #Sample a Gaussian Matern process on R using the covariance-based rational approximation nu = 0.8 kappa = 5 sigma = 1 sigma.e = 0.1 n.rep = 10 n.obs = 100 n.x = 51  #create mass and stiffness matrices for a FEM discretization x = seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x)  tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2*nu) * (4*pi)^(1/2) * gamma(nu+1/2)))  #Compute the covariance-based rational approximation op_cov <- matern.operators(C=fem$C, G=fem$G,nu=nu, kappa=kappa,sigma=sigma,d=1,m=2)  #Sample the model u <- simulate(op_cov, n.rep)  #Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs*n.rep) dim(noise) <- c(n.obs, n.rep) Y = as.matrix(A%*%u + sigma.e*noise)  #Define the negative likelihood function for optimization using CBrSPDE.matern.loglike2 #Notice that we are also using sigma instead of tau, so it can be compared #to matern.loglike() mlik_cov2 <- function(theta, Y, A, C ,G){ kappa = exp(theta[1]) sigma = exp(theta[2]) nu = exp(theta[3]) return(-matern.loglike(kappa=kappa, sigma=sigma,  nu=nu, sigma.e=exp(theta[4]), Y=Y, A=A, C=fem$C, G=fem$G, d=1))}  #The parameters can now be estimated by minimizing mlik with optim # \\donttest{ #Choose some reasonable starting values depending on the size of the domain theta0 = log(c(sqrt(8), sqrt(var(c(Y))), 0.9, 0.01))  #run estimation and display the results theta <- optim(theta0, mlik_cov2, Y = Y, A = A, C = C, G = G, method = \"L-BFGS-B\")  print(data.frame(kappa = c(kappa,exp(theta$par[1])), sigma = c(sigma,exp(theta$par[2])),                  nu = c(nu,exp(theta$par[3])), sigma.e = c(sigma.e,exp(theta$par[4])),                  row.names = c(\"Truth\",\"Estimates\"))) #>              kappa     sigma       nu    sigma.e #> Truth     5.000000 1.0000000 0.800000 0.10000000 #> Estimates 7.675041 0.9686377 1.053539 0.09840749 # }  #this example illustrates how the function can be used for maximum likelihood estimation #when using the operator-based rational approximation set.seed(123) #Sample a Gaussian Matern process on R using a rational approximation nu = 0.8 kappa = 5 sigma = 1 sigma.e = 0.1 n.rep = 10 n.obs = 100 n.x = 51  #create mass and stiffness matrices for a FEM discretization x = seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x)  #compute rational approximation op <- matern.operators(kappa = kappa, sigma = sigma, nu = nu,                        G = fem$G, C = fem$C, d = 1,                         type=\"operator\")  #Sample the model u <- simulate(op, n.rep)  #Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs*n.rep) dim(noise) <- c(n.obs, n.rep) Y = as.matrix(A%*%u + sigma.e*noise)  #define negative likelihood function for optimization using matern.loglike mlik <- function(theta, Y, G, C, A){ return(-matern.loglike(exp(theta[1]), exp(theta[2]), exp(theta[3]), exp(theta[4]),                        Y = Y, G = G, C = C, A = A, d = 1,                        type=\"operator\")) }  #The parameters can now be estimated by minimizing mlik with optim # \\donttest{ #Choose some reasonable starting values depending on the size of the domain theta0 = log(c(sqrt(8), sqrt(var(c(Y))), 0.9, 0.01))  #run estimation and display the results theta <- optim(theta0, mlik, Y = Y, G = fem$G, C = fem$C, A = A, method = \"L-BFGS-B\")  print(data.frame(kappa = c(kappa,exp(theta$par[1])), sigma = c(sigma,exp(theta$par[2])),                  nu = c(nu,exp(theta$par[3])), sigma.e = c(sigma.e,exp(theta$par[4])),                  row.names = c(\"Truth\",\"Estimates\"))) #>              kappa     sigma        nu    sigma.e #> Truth     5.000000 1.0000000 0.8000000 0.10000000 #> Estimates 4.063431 0.8095477 0.5906243 0.09566357 # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"matern.operators used computing rational SPDE approximation stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h)$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"","code":"matern.operators(   kappa,   sigma,   nu,   G = NULL,   C = NULL,   d = NULL,   mesh = NULL,   m = 1,   type = c(\"covariance\", \"operator\"),   compute_higher_order = FALSE,   return_block_list = FALSE,   type_rational_approximation = c(\"chebfun\", \"brasil\", \"chebfunLB\") )"},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"kappa Range parameter covariance function. sigma Standard deviation covariance function. nu Shape parameter covariance function. G stiffness matrix finite element discretization domain interest. need given mesh used. C mass matrix finite element discretization domain interest. need given mesh used. d dimension domain. need given mesh used. mesh optional inla mesh. d, C G must given mesh given. m order rational approximation, needs positive integer. default value 1. type type rational approximation. options \"covariance\" \"operator\". default \"covariance\". compute_higher_order Logical. higher order finite element matrices computed? return_block_list Logical. type = \"covariance\", block parts precision matrix returned separately list? type_rational_approximation type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"type \"covariance\", matern.operators returns object class \"CBrSPDEobj\".  object list containing following quantities: C mass lumped mass matrix. Ci inverse C. GCi stiffness matrix G times Ci Gk stiffness matrix G along higher-order FEM-related matrices G2, G3, etc. fem_mesh_matrices list containing mass lumped mass matrix, stiffness matrix  higher-order FEM-related matrices. m order rational approximation. alpha fractional power precision operator. type String indicating type approximation. d dimension domain. nu Shape parameter covariance function. kappa Range parameter covariance function tau Scale parameter covariance function. sigma Standard deviation covariance function. type String indicating type approximation. type \"operator\", matern.operators returns object class \"rSPDEobj\". object contains quantities listed output fractional.operators, G matrix, dimension domain, well  parameters covariance function.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"type \"covariance\", use  covariance-based rational approximation fractional operator. SPDE approach, model \\(u\\) solution following SPDE:  $$L^{\\alpha/2}(\\tau u) = \\mathcal{W},$$  \\(L  = -\\Delta +\\kappa^2 \\) \\(\\mathcal{W}\\) standard Gaussian white noise.  covariance operator \\(u\\) given \\(L^{-\\alpha}\\).  Now, let \\(L_h\\) finite-element approximation \\(L\\). can use  rational approximation order \\(m\\) \\(L_h^{-\\alpha}\\) obtain following approximation: $$L_{h,m}^{-\\alpha} = L_h^{-m_\\alpha} p(L_h^{-1})q(L_h^{-1})^{-1},$$ \\(m_\\alpha = \\lfloor \\alpha\\rfloor\\), \\(p\\) \\(q\\) polynomials arising rational approximation. approximation construct approximate precision matrix \\(u\\). type \"operator\", approximation based  rational approximation fractional operator \\((\\kappa^2 -\\Delta)^\\beta\\), \\(\\beta = (\\nu + d/2)/2\\). results approximate model form $$P_l u(s) = P_r W,$$ \\(P_j = p_j(L)\\) non-fractional operators defined terms polynomials \\(p_j\\) \\(j=l,r\\). order \\(p_r\\) given m order \\(p_l\\) \\(m + m_\\beta\\) \\(m_\\beta\\) integer part \\(\\beta\\) \\(\\beta>1\\) \\(m_\\beta = 1\\) otherwise. discrete approximation can written \\(u = P_r x\\) \\(x \\sim N(0,Q^{-1})\\) \\(Q = P_l^T C^{-1} P_l\\). Note matrices \\(P_r\\) \\(Q\\) may ill-conditioned \\(m>1\\). case, methods operator.operations used operations involving matrices, since methods numerically stable.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/matern.operators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rational approximations of stationary Gaussian Matern random fields — matern.operators","text":"","code":"#Compute the covariance-based rational approximation of a  #Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  #create mass and stiffness matrices for a FEM discretization nobs = 101 x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  #compute rational approximation of covariance function at 0.5 op_cov <- matern.operators(C=fem$C, G=fem$G,nu=nu, kappa=kappa,sigma=sigma,d=1,m=2)  v = t(rSPDE.A1d(x,0.5)) #Compute the precision matrix Q <- op_cov$Q #A matrix here is the identity matrix A <- Diagonal(nobs) #We need to concatenate 3 A's since we are doing a covariance-based rational #approximation of order 2 Abar <- cbind(A,A,A) w <- rbind(v,v,v) #The approximate covariance function: c_cov.approx <- (Abar)%*%solve(Q,w) c.true <- folded.matern.covariance.1d(rep(0.5,length(x)),abs(x), kappa, nu, sigma)  #plot the result and compare with the true Matern covariance plot(x, c.true, type = \"l\", ylab = \"C(h)\",      xlab=\"h\", main = \"Matern covariance and rational approximations\") lines(x, c_cov.approx, col = 2)    #Compute the operator-based rational approximation of a Gaussian  #process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  #create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  #compute rational approximation of covariance function at 0.5 op <- matern.operators(kappa = kappa, sigma = sigma, nu = nu,                        G = fem$G, C = fem$C, d = 1,                        type=\"operator\")                         v = t(rSPDE.A1d(x,0.5)) c.approx = Sigma.mult(op,v) c.true <- folded.matern.covariance.1d(rep(0.5,length(x)),abs(x), kappa, nu, sigma)  #plot the result and compare with the true Matern covariance plot(x, c.true, type = \"l\", ylab = \"C(h)\",      xlab=\"h\", main = \"Matern covariance and rational approximation\") lines(x,c.approx,col=2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":null,"dir":"Reference","previous_headings":"","what":"Operations with the Pr and Pl operators — operator.operations","title":"Operations with the Pr and Pl operators — operator.operations","text":"Functions multiplying solving \\(P_r\\) \\(P_l\\) operators well latent precision matrix \\(Q = P_l C^{-1}P_l\\) covariance matrix \\(\\Sigma = P_r Q^{-1} P_r^T\\). operations done without first assembling \\(P_r\\), \\(P_l\\) order avoid numerical problems caused ill-conditioned matrices.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Operations with the Pr and Pl operators — operator.operations","text":"","code":"Pr.mult(obj, v, transpose = FALSE)  Pr.solve(obj, v, transpose = FALSE)  Pl.mult(obj, v, transpose = FALSE)  Pl.solve(obj, v, transpose = FALSE)  Q.mult(obj, v)  Q.solve(obj, v)  Qsqrt.mult(obj, v, transpose = FALSE)  Qsqrt.solve(obj, v, transpose = FALSE)  Sigma.mult(obj, v)  Sigma.solve(obj, v)"},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Operations with the Pr and Pl operators — operator.operations","text":"obj rSPDE object v vector apply operation transpose set TRUE operation performed transposed object","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Operations with the Pr and Pl operators — operator.operations","text":"vector values operation","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/operator.operations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Operations with the Pr and Pl operators — operator.operations","text":"Pl.mult, Pr.mult, Q.mult multiplies vector respective object. Changing mult solve function names multiplies vector inverse object. Qsqrt.mult Qsqrt.solve performs operations square-root type object \\(Q_r = C^{-1/2}P_l\\) defined \\(Q = Q_r^T Q_r\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/plot.rspde.result.html","id":null,"dir":"Reference","previous_headings":"","what":"Posterior plots for field parameters for an inla.rspde model from a rspde.result object — plot.rspde.result","title":"Posterior plots for field parameters for an inla.rspde model from a rspde.result object — plot.rspde.result","text":"Posterior plots rSPDE field parameters original scales.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/plot.rspde.result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Posterior plots for field parameters for an inla.rspde model from a rspde.result object — plot.rspde.result","text":"","code":"# S3 method for rspde.result plot(   x,   which = c(\"tau\", \"kappa\", \"nu\"),   caption = list(\"Posterior density for tau\", \"Posterior density for kappa\",     \"Posterior density for nu\"),   sub.caption = NULL,   type_plot = \"l\",   ask = prod(graphics::par(\"mfcol\")) < length(which) && grDevices::dev.interactive(),   main = \"\",   cex.oma.main = 1.25,   cex.caption = 1,   ylab = \"Density\",   xlab = \"x\",   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/plot.rspde.result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Posterior plots for field parameters for an inla.rspde model from a rspde.result object — plot.rspde.result","text":"x rspde.result object. parameters posterior plotted? caption captions appear plots; character vector list valid graphics annotations. Can set \"\" NA suppress captions. sub.caption common title-figures one. type_plot type plot drawn. default 'l'. ask logical; TRUE, user asked plot. main character; title placed plot additionally () captions. cex.oma.main controls size sub.caption figures one. cex.caption controls size caption. ylab Label y axis. xlab Label x axis. ... Additional arguments.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/plot.rspde.result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Posterior plots for field parameters for an inla.rspde model from a rspde.result object — plot.rspde.result","text":"Called side effects.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/plot.rspde.result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Posterior plots for field parameters for an inla.rspde model from a rspde.result object — plot.rspde.result","text":"","code":"#devel version library(INLA) #> Loading required package: foreach #> Loading required package: parallel #> Loading required package: sp #> This is INLA_22.07.15 built 2022-07-15 20:25:13 UTC. #>  - See www.r-inla.org/contact-us for how to get help. #>  - To enable PARDISO sparse library; see inla.pardiso() set.seed(123)  m = 100 loc_2d_mesh = matrix(runif(m*2),m,2) mesh_2d = inla.mesh.2d(loc=loc_2d_mesh,                        cutoff=0.05,                        max.edge=c(0.1,0.5) ) sigma <- 0.01 range <- 0.2 nu <- 0.8 kappa <- sqrt(8*nu)/range op <- matern.operators(mesh=mesh_2d,nu=nu,                        kappa=kappa,sigma=sigma,m=2) u <- simulate(op) A <- inla.spde.make.A(mesh=mesh_2d,                       loc=loc_2d_mesh) sigma.e <- 0.1 y = A %*% u + rnorm(m) * sigma.e Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d) st.dat=inla.stack(data=list(y=as.vector(y)),                   A=Abar,                   effects=mesh.index) rspde_model <- rspde.matern(mesh = mesh_2d,                             nu_upper_bound = 1) f = y ~ -1 + f(field, model=rspde_model) rspde_fit = rspde.inla(f,       data=inla.stack.data(st.dat),       family=\"gaussian\",       control.predictor=         list(A=inla.stack.A(st.dat))) #> Warning: Model 'rgeneric' in section 'latent' is marked as 'experimental'; changes may appear at any time. #>   Use this model with extra care!!! Further warnings are disabled. result <- rspde.result(rspde_fit, \"field\", rspde_model) plot(result)    #devel.tag"},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the precision matrix of CBrSPDEobj objects — precision","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"Function get precision matrix CBrSPDEobj object","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"","code":"precision(object, ...)  # S3 method for CBrSPDEobj precision(   object,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_m = NULL,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"object covariance-based rational SPDE approximation,  computed using matern.operators ... Currently used. user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_m non-null, update order rational approximation, needs positive integer.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"precision matrix.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/precision.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the precision matrix of CBrSPDEobj objects — precision","text":"","code":"#Compute the covariance-based rational approximation of a  #Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  #create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  #compute rational approximation of covariance function at 0.5 tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2*nu) * (4*pi)^(1/2) * gamma(nu+1/2))) op_cov <- matern.operators(C=fem$C, G=fem$G,nu=nu, kappa=kappa,sigma=sigma,d=1,m=2)  #Get the precision matrix: prec_matrix <- precision(op_cov)"},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction of a fractional SPDE using the covariance-based rational SPDE approximation — predict.CBrSPDEobj","title":"Prediction of a fractional SPDE using the covariance-based rational SPDE approximation — predict.CBrSPDEobj","text":"function used computing kriging predictions based data \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon\\) mean-zero Gaussian measurement noise \\(u(s)\\) defined fractional SPDE \\((\\kappa^2 - \\Delta)^{\\alpha/2} (\\tau u(s)) = W\\), \\(W\\) Gaussian white noise \\(\\alpha = \\nu + d/2\\), \\(d\\) dimension domain.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction of a fractional SPDE using the covariance-based rational SPDE approximation — predict.CBrSPDEobj","text":"","code":"# S3 method for CBrSPDEobj predict(   object,   A,   Aprd,   Y,   sigma.e,   mu = 0,   compute.variances = FALSE,   pivot = TRUE,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction of a fractional SPDE using the covariance-based rational SPDE approximation — predict.CBrSPDEobj","text":"object covariance-based rational SPDE approximation,  computed using matern.operators matrix linking measurement locations basis FEM approximation latent model. Aprd matrix linking prediction locations basis FEM approximation latent model. Y vector observed data, can also matrix columns observations independent replicates \\(u\\). sigma.e standard deviation Gaussian measurement noise. Put zero model measurement noise. mu Expectation vector latent field (default = 0). compute.variances Set also TRUE compute kriging variances. pivot pivoting used Cholesky decompositions? ... arguments passed methods.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction of a fractional SPDE using the covariance-based rational SPDE approximation — predict.CBrSPDEobj","text":"list elements mean kriging predictor (posterior mean u|Y). variance posterior variances (computed).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction of a fractional SPDE using the covariance-based rational SPDE approximation — predict.CBrSPDEobj","text":"","code":"set.seed(123) #Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8 sigma.e <- 0.3  #create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2*nu) * (4*pi)^(1/2) * gamma(nu+1/2)))  #Compute the covariance-based rational approximation op_cov <- matern.operators(C=fem$C, G=fem$G,nu=nu, kappa=kappa,sigma=sigma,d=1,m=2)  #Sample the model u <- simulate(op_cov)  #Create some data obs.loc <- runif(n = 10, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) Y <- as.vector(A%*%u + sigma.e*rnorm(10))  #compute kriging predictions at the FEM grid A.krig <- rSPDE.A1d(x, x) u.krig <- predict(op_cov, A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e,                   compute.variances= TRUE)  plot(obs.loc, Y, ylab = \"u(x)\", xlab = \"x\", main = \"Data and prediction\",      ylim = c(min(u.krig$mean - 2*sqrt(u.krig$variance)),               max(u.krig$mean + 2*sqrt(u.krig$variance)))) lines(x, u.krig$mean) lines(x, u.krig$mean + 2*sqrt(u.krig$variance), col = 2) lines(x, u.krig$mean - 2*sqrt(u.krig$variance), col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"function used computing kriging predictions based data \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon\\) mean-zero Gaussian measurement noise \\(u(s)\\) defined fractional SPDE \\(L^\\beta u(s) = W\\), \\(W\\) Gaussian white noise.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"","code":"# S3 method for rSPDEobj predict(object, A, Aprd, Y, sigma.e, compute.variances = FALSE, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"object rational SPDE approximation, computed using fractional.operators, matern.operators, spde.matern.operators. matrix linking measurement locations basis FEM approximation latent model. Aprd matrix linking prediction locations basis FEM approximation latent model. Y vector observed data, can also matrix columns observations independent replicates \\(u\\). sigma.e standard deviation Gaussian measurement noise. Put zero model measurement noise. compute.variances Set also TRUE compute kriging variances. ... arguments passed methods.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"list elements mean kriging predictor (posterior mean u|Y). variance posterior variances (computed).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/predict.rSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Prediction of a fractional SPDE using a rational SPDE approximation — predict.rSPDEobj","text":"","code":"#Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8 sigma.e <- 0.3  #create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  #compute rational approximation op <- matern.operators(kappa = kappa, sigma = sigma,                        nu = nu, G=fem$G, C = fem$C, d = 1)  #Sample the model u <- simulate(op)  #Create some data obs.loc <- runif(n = 10, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) Y <- as.vector(A%*%u + sigma.e*rnorm(10))  #compute kriging predictions at the FEM grid A.krig <- rSPDE.A1d(x, x) u.krig <- predict(op, A = A, Aprd = A.krig, Y = Y, sigma.e = sigma.e,                   compute.variances= TRUE)  plot(obs.loc, Y, ylab = \"u(x)\", xlab = \"x\", main = \"Data and prediction\",      ylim = c(min(u.krig$mean - 2*sqrt(u.krig$variance)),               max(u.krig$mean + 2*sqrt(u.krig$variance)))) lines(x, u.krig$mean) lines(x, u.krig$mean + 2*sqrt(u.krig$variance), col = 2) lines(x, u.krig$mean - 2*sqrt(u.krig$variance), col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":null,"dir":"Reference","previous_headings":"","what":"Observation matrix for finite element discretization on R — rSPDE.A1d","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"finite element discretization R can written \\(u(s) = \\sum_i^n u_i \\varphi_i(s)\\) \\(\\varphi_i(s)\\) piecewise linear \"hat function\" centered location \\(x_i\\). function computes \\(m\\times n\\) matrix \\(\\) links basis function expansion specified locations \\(s = (s_1,\\ldots, s_m)\\) domain \\(A_ij = \\varphi_j(s_i)\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"","code":"rSPDE.A1d(x, loc)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"x locations nodes FEM discretization. loc locations \\((s_1,\\ldots, s_m)\\)","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"sparse matrix .","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"David Bolin davidbolin@gmail.com","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.A1d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Observation matrix for finite element discretization on R — rSPDE.A1d","text":"","code":"#create mass and stiffness matrices for a FEM discretization on [0,1] x = seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  #create the observation matrix for some locations in the domain obs.loc <- runif(n = 10, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":null,"dir":"Reference","previous_headings":"","what":"Finite element calculations for problems on R — rSPDE.fem1d","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"function computes mass stiffness matrices FEM approximation R, assuming  Neumann boundary conditions. matrices needed discretizing operators rational approximations.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"","code":"rSPDE.fem1d(x)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"x Locations nodes FEM approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"function returns list following elements G stiffness matrix. C mass matrix.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"David Bolin davidbolin@gmail.com","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.fem1d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Finite element calculations for problems on R — rSPDE.fem1d","text":"","code":"#create mass and stiffness matrices for a FEM discretization on [0,1] x = seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational approximations of fractional SPDEs. — rSPDE","title":"Rational approximations of fractional SPDEs. — rSPDE","text":"rSPDE used approximating fractional elliptic SPDEs $$L^\\beta (\\tau u(s)) = W,$$ \\(L\\) differential operator \\(\\beta>0\\) general fractional power.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational approximations of fractional SPDEs. — rSPDE","text":"approximation based rational approximation fractional operator, allows computationally efficient inference simulation. main functions computing rational approximation objects : fractional.operatorsworks general rational operators matern.operators works random fields stationary Matern covariance functions spde.matern.operators works random fields defined solutions possibly non-stationary Matern-type SPDE model. rspde.matern R-INLA implementation covariance-based  rational approximation random fields stationary Matern covariance functions Basic statistical operations likelihood evaluations (see rSPDE.loglike, rSPDE.matern.loglike) kriging predictions (see predict.rSPDEobj, predict.CBrSPDEobj) using rational approximations also implemented. illustration purposes, package contains simple FEM implementation models R. spatial models, FEM implementation R-INLA package recommended. detailed introduction package, see rSPDE Vignettes.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Object-based log-likelihood function for latent Gaussian fractional SPDE model — rSPDE.loglike","title":"Object-based log-likelihood function for latent Gaussian fractional SPDE model — rSPDE.loglike","text":"function evaluates log-likelihood function fractional SPDE model \\(L^\\beta u(s) = W\\) observed Gaussian measurement noise: \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables \\(x(s) = \\mu(s) + u(s)\\),  \\(\\mu(s)\\) expectation vector latent field.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Object-based log-likelihood function for latent Gaussian fractional SPDE model — rSPDE.loglike","text":"","code":"rSPDE.loglike(obj, Y, A, sigma.e, mu = 0)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Object-based log-likelihood function for latent Gaussian fractional SPDE model — rSPDE.loglike","text":"obj rational SPDE approximation, computed using fractional.operators, matern.operators, spde.matern.operators. Y observations, either vector matrix columns correspond independent replicates observations. observation matrix links measurement location finite element basis. sigma.e standard deviation measurement noise. mu Expectation vector latent field (default = 0).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Object-based log-likelihood function for latent Gaussian fractional SPDE model — rSPDE.loglike","text":"log-likelihood value.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Object-based log-likelihood function for latent Gaussian fractional SPDE model — rSPDE.loglike","text":"example shows function can used evaluate likelihood latent Matern model. Se matern.loglike example can used maximum likelihood estimation.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Object-based log-likelihood function for latent Gaussian fractional SPDE model — rSPDE.loglike","text":"","code":"#Sample a Gaussian Matern process on R using a rational approximation kappa = 10 sigma = 1 nu = 0.8 sigma.e = 0.3  #create mass and stiffness matrices for a FEM discretization x = seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  #compute rational approximation op <- matern.operators(kappa = kappa, sigma = sigma, nu = nu,                        G = fem$G, C = fem$C, d = 1,                        type = \"operator\")  #Sample the model u <- simulate(op)  #Create some data obs.loc <- runif(n = 10, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) Y = as.vector(A%*%u + sigma.e*rnorm(10))  #compute log-likelihood of the data lik1 <- rSPDE.loglike(op, Y, A, sigma.e) cat(lik1) #> -8.96018"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Object-based log-likelihood function for latent Gaussian fractional SPDE model using\nthe rational approximations — rSPDE.matern.loglike","title":"Object-based log-likelihood function for latent Gaussian fractional SPDE model using\nthe rational approximations — rSPDE.matern.loglike","text":"function evaluates log-likelihood function Gaussian process Matern covariance function, observed Gaussian measurement noise: \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables. latent model approximated using  rational approximation fractional SPDE model corresponding Gaussian process.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Object-based log-likelihood function for latent Gaussian fractional SPDE model using\nthe rational approximations — rSPDE.matern.loglike","text":"","code":"rSPDE.matern.loglike(   object,   Y,   A,   sigma.e,   mu = 0,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_m = NULL,   pivot = TRUE )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Object-based log-likelihood function for latent Gaussian fractional SPDE model using\nthe rational approximations — rSPDE.matern.loglike","text":"object rational SPDE approximation,  computed using matern.operators Y observations, either vector matrix columns correspond independent replicates observations. observation matrix links measurement location finite element basis. sigma.e standard deviation measurement noise. mu Expectation vector latent field (default = 0). user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_m non-null, update order rational approximation, needs positive integer. pivot pivoting used Cholesky decompositions? Default TRUE","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Object-based log-likelihood function for latent Gaussian fractional SPDE model using\nthe rational approximations — rSPDE.matern.loglike","text":"log-likelihood value.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/rSPDE.matern.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Object-based log-likelihood function for latent Gaussian fractional SPDE model using\nthe rational approximations — rSPDE.matern.loglike","text":"","code":"#this example illustrates how the function can be used for maximum likelihood estimation set.seed(123) #Sample a Gaussian Matern process on R using a rational approximation nu = 0.8 kappa = 5 sigma = 1 sigma.e = 0.1 n.rep = 10 n.obs = 100 n.x = 51  #create mass and stiffness matrices for a FEM discretization x = seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x)  tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2*nu) * (4*pi)^(1/2) * gamma(nu+1/2)))  #Compute the covariance-based rational approximation op_cov <- matern.operators(C=fem$C, G=fem$G,nu=nu, kappa=kappa,sigma=sigma,d=1,m=2)  #Sample the model u <- simulate(op_cov, n.rep)  #Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs*n.rep) dim(noise) <- c(n.obs, n.rep) Y = as.matrix(A%*%u + sigma.e*noise)  #Define the negative likelihood function for optimization using CBrSPDE.matern.loglike #Notice that we are also using sigma instead of tau, so it can be compared #to matern.loglike() mlik_cov <- function(theta, Y, A, op_cov){ kappa = exp(theta[1]) sigma = exp(theta[2]) nu = exp(theta[3]) return(-rSPDE.matern.loglike(object = op_cov, Y=Y,                                  A = A, user_kappa=kappa, user_sigma = sigma,                                 user_nu=nu, sigma.e = exp(theta[4])))                                 }  #The parameters can now be estimated by minimizing mlik with optim # \\donttest{ #Choose some reasonable starting values depending on the size of the domain theta0 = log(c(sqrt(8), 1/sqrt(var(c(Y))), 0.9, 0.01))  #run estimation and display the results theta <- optim(theta0, mlik_cov, Y = Y, A = A, op_cov = op_cov, method = \"L-BFGS-B\")  print(data.frame(kappa = c(kappa,exp(theta$par[1])), sigma = c(sigma,exp(theta$par[2])),                  nu = c(nu,exp(theta$par[3])), sigma.e = c(sigma.e,exp(theta$par[4])),                  row.names = c(\"Truth\",\"Estimates\"))) #>              kappa     sigma        nu   sigma.e #> Truth     5.000000 1.0000000 0.8000000 0.1000000 #> Estimates 6.041191 0.9609707 0.8684637 0.0986706 # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order-set.html","id":null,"dir":"Reference","previous_headings":"","what":"Changing the order of the rational approximation — rational.order<-","title":"Changing the order of the rational approximation — rational.order<-","text":"Changing order rational approximation","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order-set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Changing the order of the rational approximation — rational.order<-","text":"","code":"rational.order(x) <- value"},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order-set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Changing the order of the rational approximation — rational.order<-","text":"x CBrSPDE rpsde.inla object value order rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.order-set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Changing the order of the rational approximation — rational.order<-","text":"object class new order rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type-set.html","id":null,"dir":"Reference","previous_headings":"","what":"Changing the type of the rational approximation — rational.type<-","title":"Changing the type of the rational approximation — rational.type<-","text":"Changing type rational approximation","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type-set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Changing the type of the rational approximation — rational.type<-","text":"","code":"rational.type(x) <- value"},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type-set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Changing the type of the rational approximation — rational.type<-","text":"x CBrSPDE rpsde.inla object value type rational approximation. current options \"chebfun\", \"brasil\" \"chebfunLB\"","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rational.type-set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Changing the type of the rational approximation — rational.type<-","text":"object class new rational approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":null,"dir":"Reference","previous_headings":"","what":"Warnings free loading of add-on packages — require.nowarnings","title":"Warnings free loading of add-on packages — require.nowarnings","text":"Turn warnings require(), allow clean completion examples require unavailable Suggested packages.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Warnings free loading of add-on packages — require.nowarnings","text":"","code":"require.nowarnings(package, lib.loc = NULL, character.only = FALSE)"},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Warnings free loading of add-on packages — require.nowarnings","text":"package name package, given character string. lib.loc character vector describing location R library trees search , NULL.  default value NULL corresponds libraries currently known .libPaths(). Non-existent library trees silently ignored. character.logical indicating whether package can assumed character string.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Warnings free loading of add-on packages — require.nowarnings","text":"require.nowarnings returns (invisibly) TRUE succeeds, otherwise FALSE","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Warnings free loading of add-on packages — require.nowarnings","text":"require(package) acts require(package, quietly = TRUE) warnings turned . particular, warning error given package unavailable. cases use requireNamespace(package, quietly = TRUE) instead, produce warnings.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/require.nowarnings.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Warnings free loading of add-on packages — require.nowarnings","text":"","code":"## This should produce no output: if (require.nowarnings(nonexistent)) {   message(\"Package loaded successfully\") }"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.inla.html","id":null,"dir":"Reference","previous_headings":"","what":"rSPDE wrapper to run INLA — rspde.inla","title":"rSPDE wrapper to run INLA — rspde.inla","text":"Wrapper run INLA","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.inla.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rSPDE wrapper to run INLA — rspde.inla","text":"","code":"rspde.inla(..., n.tries = 10)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.inla.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rSPDE wrapper to run INLA — rspde.inla","text":"... Arguments `inla` function. n.tries number tries","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":null,"dir":"Reference","previous_headings":"","what":"Observation/prediction matrices for rSPDE models. — rspde.make.A","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"Constructs observation/prediction weight matrices rSPDE models based  inla.mesh inla.mesh.1d objects.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"","code":"rspde.make.A(   mesh = NULL,   loc = NULL,   A = NULL,   dim = NULL,   rspde_order = 2,   nu = NULL,   index = NULL,   group = NULL,   repl = 1L,   n.group = NULL,   n.repl = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"mesh inla.mesh inla.mesh.1d object. loc Locations, needed INLA mesh provided matrix standard SPDE approach, matrix returned inla.spde.make.. provided mesh provided. dim dimension. provided mesh provided. rspde_order order covariance-based rational SPDE approach. nu NULL, model assume nu estimated. nu fixed, provide value nu. index observation/prediction value, index loc. Default seq_len(nrow(.loc)). group observation/prediction value, index group model. repl observation/prediction value, replicate index. n.group size group model. n.repl total number replicates.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"\\(\\) matrix rSPDE models.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.A.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Observation/prediction matrices for rSPDE models. — rspde.make.A","text":"","code":"#devel version library(INLA)  set.seed(123) loc <- matrix(runif(100 * 2) * 100, 100, 2) mesh <- inla.mesh.2d( loc = loc, cutoff = 50, max.edge = c(50, 500) ) A <- rspde.make.A(mesh, loc = loc, rspde_order=3) #devel.tag"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":null,"dir":"Reference","previous_headings":"","what":"rSPDE model index vector generation — rspde.make.index","title":"rSPDE model index vector generation — rspde.make.index","text":"Generates list named index vectors rSPDE model.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rSPDE model index vector generation — rspde.make.index","text":"","code":"rspde.make.index(   name,   n.spde = NULL,   n.group = 1,   n.repl = 1,   mesh = NULL,   rspde_order = 2,   nu = NULL,   dim = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rSPDE model index vector generation — rspde.make.index","text":"name character string base name effect. n.spde number basis functions mesh model. n.group size group model. n.repl total number replicates. mesh inla.mesh inla.mesh.1d object. rspde_order order rational approximation nu NULL, model assume nu estimated. nu fixed, provide value nu. dim dimension domain. provided  mesh provided.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"rSPDE model index vector generation — rspde.make.index","text":"list named index vectors. name Indices vector latent variables name.group 'group' indices name.repl Indices replicates","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.make.index.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"rSPDE model index vector generation — rspde.make.index","text":"","code":"#devel version library(INLA) set.seed(123)  m = 100 loc_2d_mesh = matrix(runif(m*2),m,2) mesh_2d = inla.mesh.2d(loc=loc_2d_mesh,                        cutoff=0.05,                        max.edge=c(0.1,0.5) ) sigma <- 0.01 range <- 0.2 nu <- 0.8 kappa <- sqrt(8*nu)/range op <- matern.operators(mesh=mesh_2d,nu=nu,                        kappa=kappa,sigma=sigma,m=2) u <- simulate(op) A <- inla.spde.make.A(mesh=mesh_2d,                       loc=loc_2d_mesh) sigma.e <- 0.1 y = A %*% u + rnorm(m) * sigma.e Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d) st.dat=inla.stack(data=list(y=as.vector(y)),                   A=Abar,                   effects=mesh.index) rspde_model <- rspde.matern(mesh = mesh_2d,                             nu_upper_bound = 1) f = y ~ -1 + f(field, model=rspde_model) rspde_fit = rspde.inla(f,       data=inla.stack.data(st.dat),       family=\"gaussian\",       control.predictor=         list(A=inla.stack.A(st.dat))) result <- rspde.result(rspde_fit, \"field\", rspde_model) plot(result)    #devel.tag"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":null,"dir":"Reference","previous_headings":"","what":"Matern rSPDE model object for INLA — rspde.matern","title":"Matern rSPDE model object for INLA — rspde.matern","text":"Creates INLA object stationary Matern model general  smoothness parameter.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matern rSPDE model object for INLA — rspde.matern","text":"","code":"rspde.matern(   mesh,   nu_upper_bound = 4,   rspde_order = 2,   nu = NULL,   sharp = TRUE,   debug = FALSE,   optimize = TRUE,   prior.kappa = NULL,   prior.nu = NULL,   prior.tau = NULL,   start.lkappa = NULL,   start.nu = NULL,   start.ltau = NULL,   prior.nu.dist = c(\"beta\", \"lognormal\"),   nu.prec.inc = 1,   type.rational.approx = c(\"chebfun\", \"brasil\", \"chebfunLB\") )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matern rSPDE model object for INLA — rspde.matern","text":"mesh mesh build model. inla.mesh inla.mesh.1d object. nu_upper_bound Upper bound smoothness parameter. rspde_order order covariance-based rational SPDE approach. nu nu set parameter, nu kept fixed estimated. nu NULL, estimated. sharp sparsity graph correct sparsity (costs perform sparsity analysis) upper bound sparsity? TRUE, graph correct sparsity. debug INLA debug argument. optimize model optimized? case sparsities matrices analyzed. prior.kappa list containing elements meanlog sdlog, , mean standard deviation log scale. prior.nu list containing elements mean prec beta distribution, loglocation logscale truncated lognormal distribution. loglocation stands location parameter truncated lognormal distribution log scale. prec stands precision beta distribution. logscale stands scale truncated lognormal distribution log scale. Check details . prior.tau list containing elements meanlog sdlog, , mean standard deviation log scale. start.lkappa Starting value log kappa. start.nu Starting value nu. start.ltau Starting value log tau. prior.nu.dist distribution smoothness parameter. current options \"beta\" \"lognormal\". default \"beta\". nu.prec.inc Amount increase precision beta prior distribution. Check details . type.rational.approx type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matern rSPDE model object for INLA — rspde.matern","text":"INLA model.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matern rSPDE model object for INLA — rspde.matern","text":"function constructs stationary Matern rSPDE model used INLA interface. parameters range parameter \\(\\kappa\\), smoothness parameter \\(\\nu\\) variance rescaling parameter \\(\\tau\\). model, upper bound smoothness parameter \\(\\nu\\) given. given nu_upper_bound argument. important notice larger value nu_upper_bound higher computational cost fit model. , generally best initially fit model small value nu_upper_bound increase really needed (instance, estimated smoothness parameter close nu_upper_bound). following parameterization used: $$\\log(\\tau) = \\theta_1,$$ $$\\log(\\kappa) = \\theta_2$$ \\(\\theta_3\\) can beta prior truncated lognormal prior distribution. case, prior distribution support interval \\((0,\\nu_{UB})\\), \\(\\nu_{UB}\\) nu_upper_bound. , following parameterization considered: $$\\log\\Big(\\frac{\\nu}{\\nu_{UB}-\\nu}\\Big) = \\theta_3.$$ default, optimized version model considered. optimized version generally much faster larger datasets, however takes time build model sparsity graph analyzed.  However, small datasets, possible time taken analyze sparsity plus fitting model larger time taken fit unoptimized model. , small dataset might convenient set optimize=FALSE. way use optimized version reduce cost sparsity analysis set sharp FALSE. However, increase  cost fitting model. Therefore, one usually benefit setting sharp argument FALSE fitting model large datasets. Finally, considering beta prior, beta distribution parameterized terms mean, say \\(\\mu\\) precision parameter \\(\\phi\\), variance beta distribution given \\(\\mu(\\nu_{UB}-\\mu)/(1+\\phi)\\).  mean beta prior determined prior.nu$mean, whereas precision parameter determined prior.nu$prec. prior.nu$prec NULL (default case), precision parameter taken  $$\\phi = \\max\\Big\\{\\frac{\\nu_{UB}}{\\mu}, \\frac{\\nu_{UB}}{\\nu_{UB}-\\mu}\\Big\\} + \\textrm{nu.prec.inc},$$ \\(\\mu\\) prior mean smoothness parameter. choice precision parameter ensure prior beta density boundary values equal zero (boundary values defined either continuity limits). Hence, higher value nu.prec.inc informative prior .","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matern rSPDE model object for INLA — rspde.matern","text":"","code":"#devel version library(INLA)  #Organizing the data data(PRprec) data(PRborder)  Y <- rowMeans(PRprec[, 3 + 1:31]) ind <- !is.na(Y) Y <- Y[ind] coords <- as.matrix(PRprec[ind, 1:2]) alt <- PRprec$Altitude[ind]  seaDist <- apply(spDists(coords, PRborder[1034:1078, ], longlat = TRUE),  1, min)  #Creating INLA mesh prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(80, 80)) prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.6, 1.2), cutoff = 0.3)  #Building the A matrix Abar <- rspde.make.A(mesh = prmesh, loc = coords)  #Building the index mesh.index <- rspde.make.index(name = \"field\", mesh = prmesh)  #Creating the model rspde_model <- rspde.matern(mesh = prmesh)  #INLA stack stk.dat <- inla.stack(data = list(y = Y), A = list(Abar, 1), tag = \"est\",    effects = list(c(mesh.index,                     list(Intercept = 1)),                     list(long = inla.group(coords[, 1]),                     lat = inla.group(coords[,2]),                    seaDist = inla.group(seaDist))))  #INLA formula f.s <- y ~ -1 + Intercept +  f(seaDist, model = \"rw1\") +  f(field, model = rspde_model)    #Fitting the model rspde_fit <- rspde.inla(f.s, family = \"Gamma\", data = inla.stack.data(stk.dat),  control.inla=list(int.strategy='eb'), control.predictor = list(A = inla.stack.A(stk.dat)))  #The result summary(rspde_fit) #>  #> Call: #>    c(\"inla.core(formula = formula, family = family, contrasts = contrasts,  #>    \", \" data = data, quantiles = quantiles, E = E, offset = offset, \", \"  #>    scale = scale, weights = weights, Ntrials = Ntrials, strata = strata,  #>    \", \" lp.scale = lp.scale, link.covariates = link.covariates, verbose =  #>    verbose, \", \" lincomb = lincomb, selection = selection, control.compute  #>    = control.compute, \", \" control.predictor = control.predictor,  #>    control.family = control.family, \", \" control.inla = control.inla,  #>    control.fixed = control.fixed, \", \" control.mode = control.mode,  #>    control.expert = control.expert, \", \" control.hazard = control.hazard,  #>    control.lincomb = control.lincomb, \", \" control.update =  #>    control.update, control.lp.scale = control.lp.scale, \", \"  #>    control.pardiso = control.pardiso, only.hyperparam = only.hyperparam,  #>    \", \" inla.call = inla.call, inla.arg = inla.arg, num.threads =  #>    num.threads, \", \" blas.num.threads = blas.num.threads, keep = keep,  #>    working.directory = working.directory, \", \" silent = silent, inla.mode  #>    = inla.mode, safe = FALSE, debug = debug, \", \" .parent.frame =  #>    .parent.frame)\")  #> Time used: #>     Pre = 3.28, Running = 13.8, Post = 0.0523, Total = 17.2  #> Fixed effects: #>           mean    sd 0.025quant 0.5quant 0.975quant mode   kld #> Intercept 0.65 0.016      0.619     0.65       0.68   NA 0.008 #>  #> Random effects: #>   Name\t  Model #>     seaDist RW1 model #>    field RGeneric2 #>  #> Model hyperparameters: #>                                                   mean       sd 0.025quant #> Precision parameter for the Gamma observations   13.85    0.920     12.121 #> Precision for seaDist                          7710.45 6156.363   2056.109 #> Theta1 for field                                 -1.38    0.458     -2.312 #> Theta2 for field                                  1.40    0.263      0.877 #> Theta3 for field                                 -1.07    0.316     -1.674 #>                                                0.5quant 0.975quant    mode #> Precision parameter for the Gamma observations    13.82     15.744   13.76 #> Precision for seaDist                           5957.79  24215.833 3891.59 #> Theta1 for field                                  -1.37     -0.499   -1.33 #> Theta2 for field                                   1.40      1.915    1.40 #> Theta3 for field                                  -1.07     -0.423   -1.10 #>  #> Marginal log-Likelihood:  -1254.76  #>  is computed  #> Posterior summaries for the linear predictor and the fitted values are computed #> (Posterior marginals needs also 'control.compute=list(return.marginals.predictor=TRUE)') #>  #devel.tag"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Precision matrix of the covariance-based rational approximation of \nstationary Gaussian Matern random fields — rspde.matern.precision","title":"Precision matrix of the covariance-based rational approximation of \nstationary Gaussian Matern random fields — rspde.matern.precision","text":"rspde.matern.precision used computing precision matrix covariance-based rational SPDE approximation stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^(\\nu-1)\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h)$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Precision matrix of the covariance-based rational approximation of \nstationary Gaussian Matern random fields — rspde.matern.precision","text":"","code":"rspde.matern.precision(   kappa,   nu,   tau = NULL,   sigma = NULL,   rspde_order,   dim,   fem_mesh_matrices,   only_fractional = FALSE,   return_block_list = FALSE,   type_rational_approx = \"chebfun\" )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Precision matrix of the covariance-based rational approximation of \nstationary Gaussian Matern random fields — rspde.matern.precision","text":"kappa Range parameter covariance function. nu Shape parameter covariance function. tau Scale parameter covariance function. sigma provided, tau provided. sigma Standard deviation covariance function. tau provided, sigma provided. rspde_order order rational approximation dim dimension domain fem_mesh_matrices list containing FEM-related matrices. list contain elements c0, g1, g2, g3, etc. only_fractional Logical. fractional-order part precision matrix returned? return_block_list Logical. type = \"covariance\", block parts precision matrix returned separately list? type_rational_approx type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Precision matrix of the covariance-based rational approximation of \nstationary Gaussian Matern random fields — rspde.matern.precision","text":"precision matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Precision matrix of the covariance-based rational approximation of \nstationary Gaussian Matern random fields — rspde.matern.precision","text":"","code":"set.seed(123) nobs = 101 x <- seq(from = 0, to = 1, length.out = nobs) fem <- rSPDE.fem1d(x) kappa <- 40 sigma <- 1 d <- 1 nu = 2.6 tau = sqrt(gamma(nu) / (kappa^(2*nu) * (4*pi)^(d /2) * gamma(nu + d/2))) op_cov <- matern.operators(C=fem$C, G=fem$G,nu = nu,kappa = kappa, sigma = sigma,                                   d=1,m = 2,compute_higher_order = TRUE) v <- t(rSPDE.A1d(x,0.5)) c.true <- matern.covariance(abs(x - 0.5), kappa, nu, sigma) Q <- rspde.matern.precision(kappa=kappa,nu=nu,tau=tau,rspde_order=2,d=1, fem_mesh_matrices = op_cov$fem_mesh_matrices) A <- Diagonal(nobs) Abar <- cbind(A,A,A) w <- rbind(v,v,v) c.approx_cov <- (Abar)%*%solve(Q,w)  #plot the result and compare with the true Matern covariance plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma), type = \"l\", ylab = \"C(h)\",      xlab=\"h\", main = \"Matern covariance and rational approximations\") lines(x, c.approx_cov, col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":null,"dir":"Reference","previous_headings":"","what":"Precision matrix of stationary Gaussian Matern random fields with integer\ncovariance exponent — rspde.matern.precision.integer","title":"Precision matrix of stationary Gaussian Matern random fields with integer\ncovariance exponent — rspde.matern.precision.integer","text":"rspde.matern.precision.integer.opt used computing precision matrix stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^(\\nu-1)\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h)$$, \\(\\alpha = \\nu + d/2\\) natural number.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Precision matrix of stationary Gaussian Matern random fields with integer\ncovariance exponent — rspde.matern.precision.integer","text":"","code":"rspde.matern.precision.integer(   kappa,   nu,   tau = NULL,   sigma = NULL,   dim,   fem_mesh_matrices )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Precision matrix of stationary Gaussian Matern random fields with integer\ncovariance exponent — rspde.matern.precision.integer","text":"kappa Range parameter covariance function. nu Shape parameter covariance function. tau Scale parameter covariance function. sigma Standard deviation covariance function. tau provided, sigma provided. dim dimension domain fem_mesh_matrices list containing FEM-related matrices. list contain elements c0, g1, g2, g3, etc.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Precision matrix of stationary Gaussian Matern random fields with integer\ncovariance exponent — rspde.matern.precision.integer","text":"precision matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Precision matrix of stationary Gaussian Matern random fields with integer\ncovariance exponent — rspde.matern.precision.integer","text":"","code":"set.seed(123) nobs = 101 x <- seq(from = 0, to = 1, length.out = nobs) fem <- rSPDE.fem1d(x) kappa <- 40 sigma <- 1 d <- 1 nu = 0.5 tau = sqrt(gamma(nu) / (kappa^(2*nu) * (4*pi)^(d /2) * gamma(nu + d/2))) op_cov <- matern.operators(C=fem$C, G=fem$G,nu = nu,kappa = kappa,sigma = sigma,                                   d=1,m = 2) v <- t(rSPDE.A1d(x,0.5)) c.true <- matern.covariance(abs(x - 0.5), kappa, nu, sigma) Q <- rspde.matern.precision.integer(kappa=kappa,nu=nu,tau=tau,d=1, fem_mesh_matrices = op_cov$fem_mesh_matrices) A <- Diagonal(nobs) c.approx_cov <- A%*%solve(Q,v)  #plot the result and compare with the true Matern covariance plot(x, matern.covariance(abs(x - 0.5), kappa, nu, sigma), type = \"l\", ylab = \"C(h)\",      xlab=\"h\", main = \"Matern covariance and rational approximations\") lines(x, c.approx_cov, col = 2)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.opt.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimized precision matrix of stationary Gaussian Matern random fields with integer\ncovariance exponent — rspde.matern.precision.integer.opt","title":"Optimized precision matrix of stationary Gaussian Matern random fields with integer\ncovariance exponent — rspde.matern.precision.integer.opt","text":"rspde.matern.precision.integer.opt used computing optimized version precision matrix stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h),$$ \\(\\alpha = \\nu + d/2\\) natural number.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.opt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimized precision matrix of stationary Gaussian Matern random fields with integer\ncovariance exponent — rspde.matern.precision.integer.opt","text":"","code":"rspde.matern.precision.integer.opt(   kappa,   nu,   tau,   d,   fem_matrices,   graph = NULL )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.opt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimized precision matrix of stationary Gaussian Matern random fields with integer\ncovariance exponent — rspde.matern.precision.integer.opt","text":"kappa Range parameter covariance function. nu Shape parameter covariance function. tau Scale parameter covariance function. d dimension domain fem_matrices list containing FEM-related matrices. list contain elements C, G, G_2, G_3, etc. graph sparsity graph matrices. NULL, vector elements returned, non-NULL, sparse matrix returned.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.integer.opt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimized precision matrix of stationary Gaussian Matern random fields with integer\ncovariance exponent — rspde.matern.precision.integer.opt","text":"precision matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.opt.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimized precision matrix of the covariance-based rational approximation — rspde.matern.precision.opt","title":"Optimized precision matrix of the covariance-based rational approximation — rspde.matern.precision.opt","text":"rspde.matern.precision used computing optimized version precision matrix covariance-based rational SPDE approximation stationary Gaussian random fields \\(R^d\\) Matern covariance function $$C(h) = \\frac{\\sigma^2}{2^{\\nu-1}\\Gamma(\\nu)}(\\kappa h)^\\nu K_\\nu(\\kappa h).$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.opt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimized precision matrix of the covariance-based rational approximation — rspde.matern.precision.opt","text":"","code":"rspde.matern.precision.opt(   kappa,   nu,   tau,   rspde_order,   dim,   fem_matrices,   graph = NULL,   sharp,   type_rational_approx )"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.opt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimized precision matrix of the covariance-based rational approximation — rspde.matern.precision.opt","text":"kappa Range parameter covariance function. nu Shape parameter covariance function. tau Scale parameter covariance function. rspde_order order rational approximation dim dimension domain fem_matrices list containing FEM-related matrices. list contain elements C, G, G_2, G_3, etc. graph sparsity graph matrices. NULL, vector elements returned, non-NULL, sparse matrix returned. sharp sparsity graph correct sparsity (costs perform sparsity analysis) upper bound sparsity? type_rational_approx type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\".","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.matern.precision.opt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimized precision matrix of the covariance-based rational approximation — rspde.matern.precision.opt","text":"precision matrix","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a lattice projection to/from an inla.mesh for rSPDE objects — rspde.mesh.project","title":"Calculate a lattice projection to/from an inla.mesh for rSPDE objects — rspde.mesh.project","text":"Calculate lattice projection /inla.mesh rSPDE objects","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a lattice projection to/from an inla.mesh for rSPDE objects — rspde.mesh.project","text":"","code":"rspde.mesh.project(...)  rspde.mesh.projector(   mesh,   nu = NULL,   rspde_order = 2,   loc = NULL,   lattice = NULL,   xlim = NULL,   ylim = NULL,   dims = c(100, 100),   projection = NULL,   ... )  # S3 method for inla.mesh rspde.mesh.project(   mesh,   loc = NULL,   field = NULL,   rspde_order = 2,   nu = NULL,   ... )  # S3 method for rspde.mesh.projector rspde.mesh.project(projector, field, ...)  # S3 method for inla.mesh.1d rspde.mesh.project(mesh, loc, field = NULL, rspde_order = 2, nu = NULL, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a lattice projection to/from an inla.mesh for rSPDE objects — rspde.mesh.project","text":"... Additional parameters. mesh inla.mesh inla.mesh.1d object. nu smoothness parameter. NULL, assumed nu estimated. rspde_order order rational approximation. loc Projection locations. Can matrix SpatialPoints SpatialPointsDataFrame object. lattice inla.mesh.lattice object. xlim X-axis limits lattice. R2 meshes, defaults covering domain. ylim Y-axis limits lattice. R2 meshes, defaults covering domain. dims Lattice dimensions. projection One c(\"default\", \"longlat\", \"longsinlat\", \"mollweide\"). field Basis function weights, one per mesh basis function, describing function evaluated projection locations. projector rspde.mesh.projector object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a lattice projection to/from an inla.mesh for rSPDE objects — rspde.mesh.project","text":"list projection information rspde.mesh.project. rspde.mesh.projector(mesh, ...),  rspde.mesh.projector object. rspde.mesh.project(projector, field, ...), field projected mesh onto locations  given projector object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.mesh.project.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate a lattice projection to/from an inla.mesh for rSPDE objects — rspde.mesh.project","text":"function built upon inla.mesh.project inla.mesh.projector functions INLA.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.precision.html","id":null,"dir":"Reference","previous_headings":"","what":"Precision matrices for inla.rspde objects — rspde.precision","title":"Precision matrices for inla.rspde objects — rspde.precision","text":"Precision matrices rSPDE models Calculates precision matrix  given parameter values based inla.rspde model object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.precision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Precision matrices for inla.rspde objects — rspde.precision","text":"","code":"rspde.precision(rspde, theta, optimized = FALSE)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.precision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Precision matrices for inla.rspde objects — rspde.precision","text":"rspde inla.rspde object. theta parameter vector. See details rspde.matern see parameterizations. optimized Logical indicating elements (x slot) precision matrix returned.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.precision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Precision matrices for inla.rspde objects — rspde.precision","text":"sparse precision matrix.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.precision.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Precision matrices for inla.rspde objects — rspde.precision","text":"","code":"#devel version library(INLA)  set.seed(1) n <- 10  coords <- cbind(long=sample(1:n), lat=sample(1:n))  mesh <- inla.mesh.2d(coords, max.edge = c(20, 40)) rspde_model_int <- rspde.matern(mesh = mesh, nu = 1)  prec_int <- rspde.precision(rspde_model_int, theta=log(c(1,3)))  rspde_model <- rspde.matern(mesh) prec <- rspde.precision(rspde_model, theta=log(c(1,3,1.2))) #devel.tag"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":null,"dir":"Reference","previous_headings":"","what":"rSPDE result extraction from INLA estimation results — rspde.result","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"Extract field parameter values distributions rspde effect inla result object.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"","code":"rspde.result(inla, name, rspde, compute.summary = TRUE)"},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"inla inla object obtained call inla(). name character string name rSPDE effect inla formula. rspde inla.rspde object used effect inla formula. compute.summary summary computed?","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"Returns list containing: marginals.kappa Marginal densities kappa marginals.log.kappa Marginal densities log(kappa) marginals.log.tau Marginal densities log(tau) marginals.tau Marginal densities tau marginals.values Marginal densities field values summary.log.kappa Summary statistics log(kappa) summary.log.tau Summary statistics log(tau) summary.values Summary statistics field values nu estimated, list also contain marginals.nu Marginal densities nu nu estimated beta prior used, list also contain marginals.logit.nu Marginal densities logit(nu) summary.logit.nu Marginal densities logit(nu) nu estimated truncated lognormal prior used, list also contain marginals.log.nu Marginal densities log(nu) summary.log.nu Marginal densities log(nu) compute.summary TRUE, list also contain summary.kappa Summary statistics kappa summary.tau Summary statistics tau nu estimated compute.summary TRUE, list also contain summary.nu Summary statistics nu","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/rspde.result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"rSPDE result extraction from INLA estimation results — rspde.result","text":"","code":"#devel version library(INLA) set.seed(123)  m = 100 loc_2d_mesh = matrix(runif(m*2),m,2) mesh_2d = inla.mesh.2d(loc=loc_2d_mesh,                        cutoff=0.05,                        max.edge=c(0.1,0.5) ) sigma <- 0.01 range <- 0.2 nu <- 0.8 kappa <- sqrt(8*nu)/range op <- matern.operators(mesh=mesh_2d,nu=nu,                        kappa=kappa,sigma=sigma,m=2) u <- simulate(op) A <- inla.spde.make.A(mesh=mesh_2d,                       loc=loc_2d_mesh) sigma.e <- 0.1 y = A %*% u + rnorm(m) * sigma.e Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d) st.dat=inla.stack(data=list(y=as.vector(y)),                   A=Abar,                   effects=mesh.index) rspde_model <- rspde.matern(mesh = mesh_2d,                             nu_upper_bound = 1) f = y ~ -1 + f(field, model=rspde_model) rspde_fit = rspde.inla(f,       data=inla.stack.data(st.dat),       family=\"gaussian\",       control.predictor=         list(A=inla.stack.A(st.dat))) result <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result) #>           mean         sd 0.025quant 0.5quant 0.975quant     mode #> tau   0.402805 0.00691672   0.390656 0.402283   0.417625 0.400772 #> kappa 4.190970 0.09618510   3.991980 4.195780   4.367960 4.210670 #> nu    0.751538 0.00402127   0.744326 0.751241   0.760048 0.750458 plot(result)    #devel.tag"},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation of a fractional SPDE using the covariance-based rational SPDE approximation — simulate.CBrSPDEobj","title":"Simulation of a fractional SPDE using the covariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"function samples Gaussian random field based using covariance-based rational SPDE approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation of a fractional SPDE using the covariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"","code":"# S3 method for CBrSPDEobj simulate(   object,   nsim = 1,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_m = NULL,   pivot = TRUE,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation of a fractional SPDE using the covariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"object covariance-based rational SPDE approximation,  computed using matern.operators nsim number simulations. user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_m non-null, update order rational approximation, needs positive integer. pivot pivoting used Cholesky decompositions? Default TRUE ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation of a fractional SPDE using the covariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"matrix n samples columns.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation of a fractional SPDE using the covariance-based rational SPDE approximation — simulate.CBrSPDEobj","text":"","code":"#Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8  #create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  #compute rational approximation of covariance function at 0.5 tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2*nu) * (4*pi)^(1/2) * gamma(nu+1/2))) op_cov <- matern.operators(C=fem$C, G=fem$G,nu=nu, kappa=kappa,sigma=sigma,d=1,m=2)  #Sample the model and plot the result Y <- simulate(op_cov) plot(x, Y, type = \"l\", ylab = \"u(x)\", xlab = \"x\")"},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate","text":"function samples Gaussian random field based pre-computed rational SPDE approximation.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate","text":"","code":"simulate(object, nsim, ...)  # S3 method for rSPDEobj simulate(object, nsim = 1, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate","text":"object rational SPDE approximation, computed using fractional.operators, matern.operators, spde.matern.operators. nsim number simulations. ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate","text":"matrix n samples columns.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/simulate.rSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulation of a fractional SPDE using a rational SPDE approximation — simulate","text":"","code":"#Sample a Gaussian Matern process on R using a rational approximation kappa <- 10 sigma <- 1 nu <- 0.8  #create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  #compute rational approximation op <- matern.operators(kappa = kappa, sigma = sigma,                        nu = nu, G=fem$G, C=fem$C, d = 1)  #Sample the model and plot the result Y <- simulate(op) plot(x, Y, type = \"l\", ylab = \"u(x)\", xlab = \"x\")"},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":null,"dir":"Reference","previous_headings":"","what":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model using a rational SPDE approximation — spde.matern.loglike","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model using a rational SPDE approximation — spde.matern.loglike","text":"function evaluates log-likelihood function observations Gaussian process defined solution SPDE $$(\\kappa(s) - \\Delta)^\\beta (\\tau(s)u(s)) = W.$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model using a rational SPDE approximation — spde.matern.loglike","text":"","code":"spde.matern.loglike(kappa, tau, nu, sigma.e, Y, G, C, A, d = 2, m = 1)"},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model using a rational SPDE approximation — spde.matern.loglike","text":"kappa Vector , possibly spatially varying, range parameter evaluated locations mesh used finite element discretization SPDE. tau Vector , possibly spatially varying, precision parameter evaluated locations mesh used finite element discretization SPDE. nu Shape parameter covariance function, related \\(\\beta\\) equation \\(\\beta = (\\nu + d/2)/2\\). sigma.e standard deviation measurement noise. Y observations, either vector matrix columns correspond independent replicates observations. G stiffness matrix finite element discretization domain. C mass matrix finite element discretization domain. matrix linking measurement locations basis FEM approximation latent model. d dimension domain. default value 2. m order rational approximation, needs positive integer. default value 1.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model using a rational SPDE approximation — spde.matern.loglike","text":"log-likelihood value.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model using a rational SPDE approximation — spde.matern.loglike","text":"observations assumed generated \\(Y_i = u(s_i) + \\epsilon_i\\), \\(\\epsilon_i\\) iid mean-zero Gaussian variables. latent model approximated using rational approximation fractional SPDE model.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.loglike.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parameter-based log-likelihood for a latent Gaussian Matern SPDE model using a rational SPDE approximation — spde.matern.loglike","text":"","code":"#this example illustrates how the function can be used for maximum likelihood estimation set.seed(123) #Sample a Gaussian Matern process on R using a rational approximation sigma.e = 0.1 n.rep = 10 n.obs = 100 n.x = 51  #create mass and stiffness matrices for a FEM discretization x = seq(from = 0, to = 1, length.out = n.x) fem <- rSPDE.fem1d(x)  tau = rep(0.5,n.x) nu = 0.8 kappa = rep(1,n.x)  #compute rational approximation op <- spde.matern.operators(kappa = kappa, tau = tau, nu = nu,                             G = fem$G, C = fem$C, d = 1)  #Sample the model u <- simulate(op, n.rep)  #Create some data obs.loc <- runif(n = n.obs, min = 0, max = 1) A <- rSPDE.A1d(x, obs.loc) noise <- rnorm(n.obs*n.rep) dim(noise) <- c(n.obs, n.rep) Y = as.matrix(A%*%u + sigma.e*noise)  #define negative likelihood function for optimization using matern.loglike mlik <- function(theta, Y, G, C, A){ return(-spde.matern.loglike(rep(exp(theta[1]),n.x), rep(exp(theta[2]),n.x),                             exp(theta[3]), exp(theta[4]),                             Y = Y, G = G, C = C, A = A, d = 1)) }  #' #The parameters can now be estimated by minimizing mlik with optim # \\donttest{ #Choose some reasonable starting values depending on the size of the domain theta0 = log(c(sqrt(8), 1/sqrt(var(c(Y))), 0.9, 0.01))  #run estimation and display the results theta <- optim(theta0, mlik, Y = Y, G = fem$G, C = fem$C, A = A)  print(data.frame(kappa = c(kappa[1],exp(theta$par[1])), tau = c(tau[1],exp(theta$par[2])),                  nu = c(nu,exp(theta$par[3])), sigma.e = c(sigma.e,exp(theta$par[4])),                  row.names = c(\"Truth\",\"Estimates\"))) #>              kappa       tau        nu   sigma.e #> Truth     1.000000 0.5000000 0.8000000 0.1000000 #> Estimates 1.254077 0.5437648 0.7929743 0.0987481 # }"},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":null,"dir":"Reference","previous_headings":"","what":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"spde.matern.operators used computing rational SPDE approximation Gaussian random fields \\(R^d\\) defined solution SPDE $$(\\kappa(s) - \\Delta)^\\beta (\\tau(s)u(s)) = W.$$","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"","code":"spde.matern.operators(kappa, tau, nu, G, C, d, m = 1)"},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"kappa Vector , possibly spatially varying, range parameter evaluated locations mesh used finite element discretization SPDE. tau Vector , possibly spatially varying, precision parameter evaluated locations mesh used finite element discretization SPDE. nu Shape parameter covariance function, related \\(\\beta\\) equation \\(\\beta = (\\nu + d/2)/2\\). G stiffness matrix finite element discretization domain interest. C mass matrix finite element discretization domain interest. d dimension domain. m order rational approximation, needs positive integer. default value 1.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"spde.matern.operators returns object class \"rSPDEobj. object contains quantities listed output fractional.operators well smoothness parameter \\(\\nu\\).","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"approximation based rational approximation fractional operator \\((\\kappa(s)^2 -\\Delta)^\\beta\\), \\(\\beta = (\\nu + d/2)/2\\). results approximate model form $$P_l u(s) = P_r W,$$ \\(P_j = p_j(L)\\) non-fractional operators defined terms polynomials \\(p_j\\) \\(j=l,r\\). order \\(p_r\\) given m order \\(p_l\\) \\(m + m_\\beta\\) \\(m_\\beta\\) integer part \\(\\beta\\) \\(\\beta>1\\) \\(m_\\beta = 1\\) otherwise. discrete approximation can written \\(u = P_r x\\) \\(x \\sim N(0,Q^{-1})\\) \\(Q = P_l^T C^{-1} P_l\\). Note matrices \\(P_r\\) \\(Q\\) may ill-conditioned \\(m>1\\). case, metehods operator.operations used operations involving matrices, since methods numerically stable.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/spde.matern.operators.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rational approximations of non-stationary Gaussian SPDE Matern random fields — spde.matern.operators","text":"","code":"#Sample non-stationary Matern field on R tau <- 1 nu <- 0.8  #create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)   #define a non-stationary range parameter  kappa <- seq(from = 2, to = 20, length.out = length(x))  #compute rational approximation op <- spde.matern.operators(kappa = kappa, tau = tau, nu = nu,                             G = fem$G, C = fem$C, d = 1)  #sample the field u <- simulate(op)  #plot the sample plot(x, u, type = \"l\", ylab = \"u(s)\", xlab = \"s\")"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise CBrSPDE objects — summary.CBrSPDEobj","title":"Summarise CBrSPDE objects — summary.CBrSPDEobj","text":"Summary method class \"CBrSPDEobj\"","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise CBrSPDE objects — summary.CBrSPDEobj","text":"","code":"# S3 method for CBrSPDEobj summary(object, ...)  # S3 method for summary.CBrSPDEobj print(x, ...)  # S3 method for CBrSPDEobj print(x, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise CBrSPDE objects — summary.CBrSPDEobj","text":"object object class \"CBrSPDEobj\", usually, result call matern.operators. ... arguments passed methods. x object class \"summary.CBrSPDEobj\", usually, result call summary.CBrSPDEobj.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise CBrSPDE objects — summary.CBrSPDEobj","text":"","code":"#Compute the covariance-based rational approximation of a  #Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  #create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  #compute rational approximation of covariance function at 0.5 tau <- sqrt(gamma(nu) / (sigma^2 * kappa^(2*nu) * (4*pi)^(1/2) * gamma(nu+1/2))) op_cov <- matern.operators(C=fem$C, G=fem$G,nu=nu, kappa=kappa,sigma=sigma,d=1,m=2)  op_cov #> Type of approximation:  Covariance-Based Matern SPDE approximation  #> Type of rational approximation:  chebfun  #> Parameters of covariance function: kappa =  10 , sigma =  1 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise rSPDE objects — summary.rSPDEobj","title":"Summarise rSPDE objects — summary.rSPDEobj","text":"Summary method class \"rSPDEobj\"","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise rSPDE objects — summary.rSPDEobj","text":"","code":"# S3 method for rSPDEobj summary(object, ...)  # S3 method for summary.rSPDEobj print(x, ...)  # S3 method for rSPDEobj print(x, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise rSPDE objects — summary.rSPDEobj","text":"object object class \"rSPDEobj\", usually, result call fractional.operators, matern.operators, spde.matern.operators. ... arguments passed methods. x object class \"summary.rSPDEobj\", usually, result call summary.rSPDEobj.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde.result.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary for posteriors of field parameters for an inla.rspde model from a rspde.result object — summary.rspde.result","title":"Summary for posteriors of field parameters for an inla.rspde model from a rspde.result object — summary.rspde.result","text":"Summary posteriors rSPDE field parameters original scales.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde.result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary for posteriors of field parameters for an inla.rspde model from a rspde.result object — summary.rspde.result","text":"","code":"# S3 method for rspde.result summary(object, digits = 6, ...)"},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde.result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary for posteriors of field parameters for an inla.rspde model from a rspde.result object — summary.rspde.result","text":"object rspde.result object. digits integer, used number formatting signif() ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde.result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary for posteriors of field parameters for an inla.rspde model from a rspde.result object — summary.rspde.result","text":"Returns data.frame containing summary.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/summary.rspde.result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary for posteriors of field parameters for an inla.rspde model from a rspde.result object — summary.rspde.result","text":"","code":"#devel version library(INLA) set.seed(123)  m = 100 loc_2d_mesh = matrix(runif(m*2),m,2) mesh_2d = inla.mesh.2d(loc=loc_2d_mesh,                        cutoff=0.05,                        max.edge=c(0.1,0.5) ) sigma <- 0.01 range <- 0.2 nu <- 0.8 kappa <- sqrt(8*nu)/range op <- matern.operators(mesh=mesh_2d,nu=nu,                        kappa=kappa,sigma=sigma,m=2) u <- simulate(op) A <- inla.spde.make.A(mesh=mesh_2d,                       loc=loc_2d_mesh) sigma.e <- 0.1 y = A %*% u + rnorm(m) * sigma.e Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh) mesh.index <- rspde.make.index(name = \"field\", mesh = mesh_2d) st.dat=inla.stack(data=list(y=as.vector(y)),                   A=Abar,                   effects=mesh.index) rspde_model <- rspde.matern(mesh = mesh_2d,                             nu_upper_bound = 1) f = y ~ -1 + f(field, model=rspde_model) rspde_fit = rspde.inla(f,       data=inla.stack.data(st.dat),       family=\"gaussian\",       control.predictor=         list(A=inla.stack.A(st.dat))) result <- rspde.result(rspde_fit, \"field\", rspde_model) summary(result) #>           mean         sd 0.025quant 0.5quant 0.975quant     mode #> tau   0.706561 0.01145950   0.683236 0.706914   0.728146 0.708018 #> kappa 5.050490 0.11285400   4.873430 5.034820   5.306870 4.981990 #> nu    0.751873 0.00442189   0.741786 0.752507   0.758722 0.754685 #devel.tag"},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"Function change parameters CBrSPDEobj object","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"","code":"# S3 method for CBrSPDEobj update(   object,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_m = NULL,   compute_higher_order = object$higher_order,   type_rational_approximation = object$type_rational_approximation,   return_block_list = object$return_block_list,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"object covariance-based rational SPDE approximation,  computed using matern.operators user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_m non-null, update order rational approximation, needs positive integer. compute_higher_order Logical. higher order finite element matrices computed? type_rational_approximation type rational approximation used? current types \"chebfun\", \"brasil\" \"chebfunLB\". return_block_list Logical. type = \"covariance\", block parts precision matrix returned separately list? ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"returns object class \"CBrSPDEobj. object contains quantities listed output matern.operators.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/update.CBrSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update parameters of CBrSPDEobj objects — update.CBrSPDEobj","text":"","code":"#Compute the covariance-based rational approximation of a  #Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  #create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  #compute rational approximation of covariance function at 0.5 op_cov <- matern.operators(C=fem$C, G=fem$G,nu=nu, kappa=kappa,sigma=sigma,d=1,m=2) op_cov #> Type of approximation:  Covariance-Based Matern SPDE approximation  #> Type of rational approximation:  chebfun  #> Parameters of covariance function: kappa =  10 , sigma =  1 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101   #Update the range parameter of the model: op_cov <- update(op_cov, user_kappa=20) op_cov #> Type of approximation:  Covariance-Based Matern SPDE approximation  #> Type of rational approximation:  chebfun  #> Parameters of covariance function: kappa =  20 , sigma =  1 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101"},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":null,"dir":"Reference","previous_headings":"","what":"Update parameters of rSPDEobj objects — update.rSPDEobj","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"Function change parameters rSPDEobj object","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"","code":"# S3 method for rSPDEobj update(   object,   user_nu = NULL,   user_kappa = NULL,   user_sigma = NULL,   user_m = NULL,   ... )"},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"object operator-based rational SPDE approximation,  computed using matern.operators type=\"operator\" user_nu non-null, update shape parameter covariance function. user_kappa non-null, update range parameter covariance function. user_sigma non-null, update standard deviation covariance function. user_m non-null, update order rational approximation, needs positive integer. ... Currently used.","code":""},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"returns object class \"rSPDEobj. object contains quantities listed output matern.operators.","code":""},{"path":[]},{"path":"https://davidbolin.github.io/rSPDE/reference/update.rSPDEobj.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Update parameters of rSPDEobj objects — update.rSPDEobj","text":"","code":"#Compute the operator-based rational approximation of a  #Gaussian process with a Matern covariance function on R kappa <- 10 sigma <- 1 nu <- 0.8  #create mass and stiffness matrices for a FEM discretization x <- seq(from = 0, to = 1, length.out = 101) fem <- rSPDE.fem1d(x)  #compute rational approximation of covariance function at 0.5 op <- matern.operators(C=fem$C, G=fem$G,nu=nu, kappa=kappa,sigma=sigma,d=1,m=2, type=\"operator\") op #> Type of approximation:  Matern approximation  #> Parametres of covariance function: kappa =  10 , sigma =  1 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101   #Update the range parameter of the model: op <- update(op, user_kappa=20) op #> Type of approximation:  Matern approximation  #> Parametres of covariance function: kappa =  20 , sigma =  1 , nu =  0.8  #> Order or rational approximation:  2  #> Size of discrete operators:  101  x  101"},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-development-version","dir":"Changelog","previous_headings":"","what":"rSPDE (development version)","title":"rSPDE (development version)","text":"Added “rational.order” “rational.type” functions Added BRASIL rational approximation Improved covariance-based operator objects Improved log-likelihood computation Created 2d folded Matern different boundary conditions. Implemented different boundary conditions 1d folded Matern.","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-111","dir":"Changelog","previous_headings":"","what":"rSPDE 1.1.1","title":"rSPDE 1.1.1","text":"CRAN release: 2022-01-14 Adjusts donttest examples CRAN.","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-110","dir":"Changelog","previous_headings":"","what":"rSPDE 1.1.0","title":"rSPDE 1.1.0","text":"Minor typos vignettes man pages corrected. examples changed improve numerical stability.","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-100","dir":"Changelog","previous_headings":"","what":"rSPDE 1.0.0","title":"rSPDE 1.0.0","text":"CRAN release: 2021-12-13 Implementation covariance-based rational approximation stationary Matérn models. R-INLA implementation rational SPDE approach Added introduction rSPDE vignette previous vignette updated became operator-based rational approximation vignette. Added vignette R-INLA implementation SPDE approach Added vignette present rational approximation using rSPDE package Backward compatibility maintained.","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-063","dir":"Changelog","previous_headings":"","what":"rSPDE 0.6.3","title":"rSPDE 0.6.3","text":"CRAN release: 2021-10-14 Change inline citations Vignette avoid problems CRAN","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-062","dir":"Changelog","previous_headings":"","what":"rSPDE 0.6.2","title":"rSPDE 0.6.2","text":"CRAN release: 2021-02-23","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-061","dir":"Changelog","previous_headings":"","what":"rSPDE 0.6.1","title":"rSPDE 0.6.1","text":"Add rgdal suggested package","code":""},{"path":"https://davidbolin.github.io/rSPDE/news/index.html","id":"rspde-050","dir":"Changelog","previous_headings":"","what":"rSPDE 0.5.0","title":"rSPDE 0.5.0","text":"Remove dependency INLA Vignette CRAN Update citation","code":""}]
