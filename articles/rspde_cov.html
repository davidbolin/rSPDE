<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Rational approximation with the rSPDE package • rSPDE</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Roboto_Slab-0.4.9/font.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Rational approximation with the rSPDE package">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">rSPDE</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.3.3.9000</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/rSPDE.html">Get started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Functions</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-vignettes" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Vignettes</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-vignettes">
<li><a class="dropdown-item" href="../articles/rspde_inla.html">R-INLA implementation of the rational SPDE approach</a></li>
    <li><a class="dropdown-item" href="../articles/rspde_inlabru.html">inlabru implementation of the rational SPDE approach</a></li>
    <li><a class="dropdown-item" href="../articles/rspde_cov.html">Rational approximation with the rSPDE package</a></li>
    <li><a class="dropdown-item" href="../articles/rspde_base.html">Operator-based rational approximation</a></li>
    <li><a class="dropdown-item" href="../articles/intrinsic.html">Intrinsic models</a></li>
    <li><a class="dropdown-item" href="../articles/build_source.html">Building the rSPDE package from source on Mac and Linux</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/davidbolin/rSPDE/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
<li class="nav-item"><a class="external-link nav-link" href="https://twitter.com/jdavidbolin" aria-label="Twitter"><span class="fa fa-twitter"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Rational approximation with the rSPDE package</h1>
                        <h4 data-toc-skip class="author">David Bolin,
Alexandre B. Simas, Zhen Xiong</h4>
            
            <h4 data-toc-skip class="date">Created: 2021-12-04. Last
modified: 2024-10-06.</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/davidbolin/rSPDE/blob/devel-src/vignettes/rspde_cov.Rmd" class="external-link"><code>vignettes/rspde_cov.Rmd</code></a></small>
      <div class="d-none name"><code>rspde_cov.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>In this vignette we will introduce the covariance-based rational SPDE
approach and illustrate how to perform statistical inference with
it.</p>
<p>The covariance-based approach is an efficient alternative to the
operator-based rational SPDE approach by <a href="https://www.tandfonline.com/doi/full/10.1080/10618600.2019.1665537" class="external-link"><span class="citation">Bolin and Kirchner (2020)</span></a> which works when
one has SPDE driven by Gaussian white noise. We refer the reader to <a href="https://doi.org/10.1080/10618600.2023.2231051" class="external-link"><span class="citation">Bolin, Simas, and Xiong (2023)</span></a> for the
theoretical details of the approach.</p>
<p>Details about the operator-based rational SPDE approach are given in
the <a href="rspde_base.html">Operator-based rational approximation</a>
vignette. For the <a href="https://www.r-inla.org" class="external-link"><code>R-INLA</code></a> and
<code>inlabru</code> implementations of the covariance-based rational
SPDE approach we refer the reader to the vignettes <a href="rspde_inla.html">R-INLA implementation of the rational SPDE
approach</a> and <a href="rspde_inlabru.html">inlabru implementation of
the rational SPDE approach</a> respectively.</p>
</div>
<div class="section level2">
<h2 id="covariance-based-rational-spde-approach">Covariance-based rational SPDE approach<a class="anchor" aria-label="anchor" href="#covariance-based-rational-spde-approach"></a>
</h2>
<p>Let us first present the idea behind the approach. In the SPDE
approach, introduced in <a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/j.1467-9868.2011.00777.x" class="external-link"><span class="citation">Lindgren, Rue, and Lindström (2011)</span></a> we model
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math>
as the solution of the following SPDE:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mrow><mi>α</mi><mi>/</mi><mn>2</mn></mrow></msup><mrow><mo stretchy="true" form="prefix">(</mo><mi>τ</mi><mi>u</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mi>W</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">
L^{\alpha/2}(\tau u) = W,
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo>−</mo><mi>Δ</mi><mo>+</mo><msup><mi>κ</mi><mn>2</mn></msup><mi>I</mi></mrow><annotation encoding="application/x-tex">L  = -\Delta +\kappa^2 I</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>W</mi><annotation encoding="application/x-tex">W</annotation></semantics></math>
is the standard Gaussian white noise. Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>
are the parameters of the model. In the standard SPDE approach,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>ν</mi><mo>+</mo><mi>d</mi><mi>/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">\alpha = \nu + d/2</annotation></semantics></math>
needs to be fixed to an integer value, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">\alpha = 2</annotation></semantics></math>
is the usual default value. In the rational SPDE approach we can use any
value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\nu&gt;0</annotation></semantics></math>
and also estimate it from data.</p>
<p>The main idea of the covariance-based rational SPDE approach is to
perform the rational approximation of the covariance operator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>L</mi><mrow><mo>−</mo><mi>α</mi></mrow></msup><annotation encoding="application/x-tex">L^{-\alpha}</annotation></semantics></math>.
To this end, we begin by obtaining an approximation of the random field
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math>,
which is the solution of the SPDE above, by using the finite element
method (FEM):
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>h</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐬</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>h</mi></msub></munderover><msub><mover><mi>u</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><msub><mi>φ</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐬</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">
u_h(\mathbf{s}_i)=\sum_{j=1}^{n_h} \hat{u}_j \varphi_j(\mathbf{s}_i),
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mover><mi>u</mi><mo accent="true">̂</mo></mover><mi>j</mi></msub><msubsup><mo stretchy="false" form="postfix">}</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>h</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">\{\hat{u}_j\}_{j = 1}^{n_h}</annotation></semantics></math>
are stochastic weights and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>φ</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐬</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><msubsup><mo stretchy="false" form="postfix">}</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>h</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">\{\varphi_j(\mathbf{s}_i)\}_{j = 1}^{n_h}</annotation></semantics></math>
are fixed piecewise linear and continuous basis functions obtained from
a triangulation of the spatial domain. We then obtain a FEM
approximation of the operator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>L</mi><annotation encoding="application/x-tex">L</annotation></semantics></math>,
which is given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>h</mi></msub><annotation encoding="application/x-tex">L_h</annotation></semantics></math>,
and the covariance operator of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>u</mi><mi>h</mi></msub><annotation encoding="application/x-tex">u_h</annotation></semantics></math>
is given by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>L</mi><mi>h</mi><mrow><mo>−</mo><mi>α</mi></mrow></msubsup><annotation encoding="application/x-tex">L_h^{-\alpha}</annotation></semantics></math>.</p>
<p>Now, by using the rational approximation on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>L</mi><mi>h</mi></msub><annotation encoding="application/x-tex">L_h</annotation></semantics></math>,
we can approximate covariance operator
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msubsup><mi>L</mi><mi>h</mi><mrow><mo>−</mo><mi>α</mi></mrow></msubsup><annotation encoding="application/x-tex">L_h^{-\alpha}</annotation></semantics></math>
as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>L</mi><mrow><mi>h</mi><mo>,</mo><mi>m</mi></mrow><mrow><mo>−</mo><mi>α</mi></mrow></msubsup><mo>=</mo><msubsup><mi>L</mi><mi>h</mi><mrow><mo>−</mo><mo stretchy="false" form="prefix">⌊</mo><mi>α</mi><mo stretchy="false" form="postfix">⌋</mo></mrow></msubsup><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>L</mi><mi>h</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>q</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>L</mi><mi>h</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>,</mo></mrow><annotation encoding="application/x-tex">L_{h,m}^{-\alpha} = L_h^{-\lfloor\alpha\rfloor} p(L_h^{-1})q(L_h^{-1})^{-1},</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">⌊</mo><mi>α</mi><mo stretchy="false" form="postfix">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor\alpha\rfloor</annotation></semantics></math>
denotes the integer part of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>α</mi><annotation encoding="application/x-tex">\alpha</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
is the order of rational approximation,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>L</mi><mi>h</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></msubsup><msub><mi>a</mi><mi>i</mi></msub><msubsup><mi>L</mi><mi>h</mi><mrow><mi>m</mi><mo>−</mo><mi>i</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">p(L_h^{-1}) = \sum_{i=0}^m a_i L_h^{m-i}</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>L</mi><mi>h</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></msubsup><msub><mi>b</mi><mi>j</mi></msub><msubsup><mi>L</mi><mi>h</mi><mrow><mi>m</mi><mo>−</mo><mi>i</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">q(L_h^{-1}) = \sum_{j=0}^m b_j L_h^{m-i}</annotation></semantics></math>,
with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>a</mi><mi>i</mi></msub><msubsup><mo stretchy="false" form="postfix">}</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">\{a_i\}_{i = 0}^m</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>b</mi><mi>j</mi></msub><msubsup><mo stretchy="false" form="postfix">}</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>m</mi></msubsup></mrow><annotation encoding="application/x-tex">\{b_j\}_{j = 0}^m</annotation></semantics></math>
being known coefficients obtained from a rational approximation of the
function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>x</mi><mrow><mi>α</mi><mo>−</mo><mo stretchy="false" form="prefix">⌊</mo><mi>α</mi><mo stretchy="false" form="postfix">⌋</mo></mrow></msup><annotation encoding="application/x-tex">x^{\alpha - \lfloor\alpha\rfloor}</annotation></semantics></math>.</p>
<p>The next step is to perform a partial fraction decomposition of the
rational function
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>L</mi><mi>h</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mi>q</mi><msup><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mi>L</mi><mi>h</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">p(L_h^{-1})q(L_h^{-1})^{-1}</annotation></semantics></math>,
which yields the representation
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mi>L</mi><mrow><mi>h</mi><mo>,</mo><mi>m</mi></mrow><mrow><mo>−</mo><mi>α</mi></mrow></msubsup><mo>=</mo><msubsup><mi>L</mi><mi>h</mi><mrow><mo>−</mo><mo stretchy="false" form="prefix">⌊</mo><mi>α</mi><mo stretchy="false" form="postfix">⌋</mo></mrow></msubsup><mrow><mo stretchy="true" form="prefix">(</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>r</mi><mi>i</mi></msub><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>L</mi><mi>h</mi></msub><mo>−</mo><msub><mi>p</mi><mi>i</mi></msub><mi>I</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">L_{h,m}^{-\alpha} =L_h^{-\lfloor\alpha\rfloor} \left(\sum_{i=1}^{m}  r_i  (L_h-p_i I)^{-1} +k\right).</annotation></semantics></math>
Based on the above operator equation, we can write the covariance matrix
of the stochastic weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mtext mathvariant="bold">𝐮</mtext><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\textbf{u}}</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mtext mathvariant="bold">𝐮</mtext><mo accent="true">̂</mo></mover><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">[</mo><msub><mover><mi>u</mi><mo accent="true">̂</mo></mover><mn>1</mn></msub><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><msub><mover><mi>u</mi><mo accent="true">̂</mo></mover><msub><mi>n</mi><mi>h</mi></msub></msub><mo stretchy="true" form="postfix">]</mo></mrow><mi>⊤</mi></msup></mrow><annotation encoding="application/x-tex">\hat{\textbf{u}}=[\hat{u}_1,...,\hat{u}_{n_h}]^\top</annotation></semantics></math>,
as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>𝚺</mi><mover><mtext mathvariant="bold">𝐮</mtext><mo accent="true">̂</mo></mover></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mtext mathvariant="bold">𝐋</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext mathvariant="bold">𝐂</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="false" form="prefix">⌊</mo><mi>α</mi><mo stretchy="false" form="postfix">⌋</mo></mrow></msup><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>m</mi></munderover><msub><mi>r</mi><mi>i</mi></msub><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="bold">𝐋</mtext><mo>−</mo><msub><mi>p</mi><mi>i</mi></msub><mtext mathvariant="bold">𝐂</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mtext mathvariant="bold">𝐊</mtext><mo>,</mo></mrow><annotation encoding="application/x-tex">\mathbf{\Sigma}_{\hat{\textbf{u}}} = (\textbf{L}^{-1}\textbf{C})^{\lfloor\alpha\rfloor} \sum_{i=1}^{m}r_i(\textbf{L}-p_i\textbf{C})^{-1}+\textbf{K}, </annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">𝐂</mtext><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>C</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msubsup><mo stretchy="false" form="postfix">}</mo><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>h</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">\textbf{C} = \{C_{ij}\}_{i,j=1}^{n_h}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>φ</mi><mi>i</mi></msub><mo>,</mo><msub><mi>φ</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><msub><mi>L</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msub></mrow><annotation encoding="application/x-tex">C_{ij} = (\varphi_i,\varphi_j)_{L_2(\mathcal{D})}</annotation></semantics></math>,
is the mass matrix,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">𝐋</mtext><mo>=</mo><msup><mi>κ</mi><mn>2</mn></msup><mtext mathvariant="bold">𝐂</mtext><mo>+</mo><mtext mathvariant="bold">𝐆</mtext></mrow><annotation encoding="application/x-tex">\textbf{L} = \kappa^2\textbf{C}+\textbf{G}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">𝐆</mtext><mo>=</mo><mo stretchy="false" form="prefix">{</mo><msub><mi>G</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><msubsup><mo stretchy="false" form="postfix">}</mo><mrow><mi>i</mi><mo>,</mo><mi>j</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>h</mi></msub></msubsup></mrow><annotation encoding="application/x-tex">\textbf{G} = \{G_{ij}\}_{i,j=1}^{n_h}</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>∇</mi><msub><mi>φ</mi><mi>i</mi></msub><mo>,</mo><mi>∇</mi><msub><mi>φ</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mrow><msub><mi>L</mi><mn>2</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝒟</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msub></mrow><annotation encoding="application/x-tex">G_{ij}=(\nabla\varphi_i,\nabla\varphi_j)_{L_2(\mathcal{D})}</annotation></semantics></math>,
is the stiffness matrix, and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">𝐊</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mi>k</mi><mtext mathvariant="bold">𝐂</mtext></mtd><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="left" style="text-align: left"><mo stretchy="false" form="prefix">⌊</mo><mi>α</mi><mo stretchy="false" form="postfix">⌋</mo><mo>=</mo><mn>0</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><mi>k</mi><msup><mtext mathvariant="bold">𝐋</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="bold">𝐂</mtext><msup><mtext mathvariant="bold">𝐋</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="false" form="prefix">⌊</mo><mi>α</mi><mo stretchy="false" form="postfix">⌋</mo><mo>−</mo><mn>1</mn></mrow></msup></mtd><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="left" style="text-align: left"><mo stretchy="false" form="prefix">⌊</mo><mi>α</mi><mo stretchy="false" form="postfix">⌋</mo><mo>≥</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"></mtd></mtr></mtable></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">
\textbf{K}=\left\{
    \begin{array}{lcl}
        k\textbf{C}      &amp;      &amp; {\lfloor\alpha\rfloor=0}\\
        k\textbf{L}^{-1}(\textbf{C}\textbf{L}^{-1})^{\lfloor\alpha\rfloor-1}    &amp;      &amp; {\lfloor\alpha\rfloor\geq 1}\\
    \end{array} \right. .
    </annotation></semantics></math></p>
<p>The above representation shows that we can express
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mtext mathvariant="bold">𝐮</mtext><mo accent="true">̂</mo></mover><annotation encoding="application/x-tex">\hat{\textbf{u}}</annotation></semantics></math>
as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mtext mathvariant="bold">𝐮</mtext><mo accent="true">̂</mo></mover><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></munderover><msub><mtext mathvariant="bold">𝐱</mtext><mi>i</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">
\hat{\textbf{u}}=\sum_{i=1}^{m+1}\textbf{x}_i,
</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">𝐱</mtext><mi>i</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>,</mo><mn>1</mn></mrow></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>x</mi><mrow><mi>i</mi><mo>,</mo><msub><mi>n</mi><mi>h</mi></msub></mrow></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\textbf{x}_i = (x_{i,1}, \ldots, x_{i,n_h})</annotation></semantics></math>,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">𝐱</mtext><mi>i</mi></msub><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="bold">𝟎</mtext><mo>,</mo><msubsup><mtext mathvariant="bold">𝐐</mtext><mi>i</mi><mrow><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mrow><annotation encoding="application/x-tex">\textbf{x}_i \sim N(\textbf{0},\textbf{Q}_i^{-1}),</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="bold">𝐐</mtext><mi>i</mi></msub><annotation encoding="application/x-tex">\textbf{Q}_i</annotation></semantics></math>
is the precision matrix of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mtext mathvariant="bold">𝐱</mtext><mi>i</mi></msub><annotation encoding="application/x-tex">\textbf{x}_i</annotation></semantics></math>,
which is given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mtext mathvariant="bold">𝐐</mtext><mi>i</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">{</mo><mtable><mtr><mtd columnalign="left" style="text-align: left"><mrow><mo stretchy="true" form="prefix">(</mo><mtext mathvariant="bold">𝐋</mtext><mo>−</mo><msub><mi>p</mi><mi>i</mi></msub><mtext mathvariant="bold">𝐂</mtext><mo stretchy="true" form="postfix">)</mo></mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><msup><mtext mathvariant="bold">𝐂</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup><mtext mathvariant="bold">𝐋</mtext><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mo stretchy="false" form="prefix">⌊</mo><mi>α</mi><mo stretchy="false" form="postfix">⌋</mo></mrow></msup><mi>/</mi><msub><mi>r</mi><mi>i</mi></msub><mo>,</mo></mtd><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="left" style="text-align: left"><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>.</mi><mi>.</mi><mi>.</mi><mo>,</mo><mi>m</mi></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"><msup><mtext mathvariant="bold">𝐊</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>,</mo></mtd><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="left" style="text-align: left"><mi>i</mi><mo>=</mo><mi>m</mi><mo>+</mo><mn>1</mn></mtd></mtr><mtr><mtd columnalign="left" style="text-align: left"></mtd></mtr></mtable><mi>.</mi></mrow></mrow><annotation encoding="application/x-tex">
\textbf{Q}_i=\left \{
    \begin{array}{lcl}
        (\textbf{L}-p_i\textbf{C})(\textbf{C}^{-1}\textbf{L})^{\lfloor\alpha\rfloor}/r_i,      &amp;      &amp; {i = 1,...,m}\\
         \textbf{K}^{-1},   &amp;      &amp; {i = m+1}\\
    \end{array}. \right.
    </annotation></semantics></math></p>
<p>We, then, replace the Matérn latent field by the latent vector given
above, which has precision matrix given by
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">𝐐</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mtext mathvariant="bold">𝐐</mtext><mn>1</mn></msub></mtd><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"><mo>⋱</mo></mtd><mtd columnalign="center" style="text-align: center"></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"></mtd><mtd columnalign="center" style="text-align: center"><msub><mtext mathvariant="bold">𝐐</mtext><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></msub></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\textbf{Q}=\begin{bmatrix}\textbf{Q}_1&amp; &amp;\\&amp;\ddots&amp;\\&amp; &amp;\textbf{Q}_{m+1}\end{bmatrix}.</annotation></semantics></math>
We thus have a Markov approximation which can be used for
computationally efficient inference. For example, assume that we observe
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub><mo>=</mo><msub><mi>u</mi><mi>h</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐬</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ε</mi><mi>j</mi></msub><mo>,</mo><mspace width="1.0em"></mspace><mi>j</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>N</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">y_j = u_h(\mathbf{s}_j) + \varepsilon_j,\quad j=1,\ldots, N,</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mi>j</mi></msub><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mi>ε</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varepsilon_j\sim N(0,\sigma_\varepsilon^2)</annotation></semantics></math>
are iid measurement noise. Then, we have that
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>j</mi></msub><mo>=</mo><msub><mi>u</mi><mi>h</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐬</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ε</mi><mi>j</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>h</mi></msub></munderover><msub><mover><mi>u</mi><mo accent="true">̂</mo></mover><mi>l</mi></msub><msub><mi>φ</mi><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐬</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ε</mi><mi>j</mi></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow></munderover><munderover><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><msub><mi>n</mi><mi>h</mi></msub></munderover><msub><mi>x</mi><mrow><mi>i</mi><mo>,</mo><mi>l</mi></mrow></msub><msub><mi>φ</mi><mi>l</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐬</mi><mi>j</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ε</mi><mi>j</mi></msub><mi>.</mi></mrow><annotation encoding="application/x-tex">
y_j = u_h(\mathbf{s}_j) + \varepsilon_j = \sum_{l=1}^{n_h} \hat{u}_l \varphi_l(\mathbf{s}_j) + \varepsilon_j = \sum_{i=1}^{m+1} \sum_{l=1}^{n_h} x_{i,l} \varphi_l(\mathbf{s}_j) + \varepsilon_j.
</annotation></semantics></math> This can be written in a matrix form as
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">𝐲</mtext><mo>=</mo><mover><mtext mathvariant="bold">𝐀</mtext><mo accent="true">¯</mo></mover><mtext mathvariant="bold">𝐗</mtext><mo>+</mo><mi>𝛆</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">\textbf{y} = \overline{\textbf{A}} \textbf{X} + \boldsymbol{\varepsilon},</annotation></semantics></math>
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">𝐲</mtext><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>y</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>y</mi><mi>N</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mi>⊤</mi></msup><mo>,</mo><mtext mathvariant="bold">𝐗</mtext><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">[</mo><msubsup><mtext mathvariant="bold">𝐱</mtext><mn>1</mn><mi>⊤</mi></msubsup><mo>,</mo><mi>…</mi><mo>,</mo><msubsup><mtext mathvariant="bold">𝐱</mtext><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><mi>⊤</mi></msubsup><mo stretchy="true" form="postfix">]</mo></mrow><mi>⊤</mi></msup></mrow><annotation encoding="application/x-tex">\textbf{y} = [y_1,\ldots,y_N]^\top, \textbf{X} = [\textbf{x}_1^\top,\ldots,\textbf{x}_{m+1}^\top]^\top</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>𝛆</mi><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">[</mo><msub><mi>ε</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>ε</mi><mi>N</mi></msub><mo stretchy="true" form="postfix">]</mo></mrow><mi>⊤</mi></msup></mrow><annotation encoding="application/x-tex">\boldsymbol{\varepsilon} = [\varepsilon_1,\ldots,\varepsilon_N]^\top</annotation></semantics></math>,
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mtext mathvariant="bold">𝐀</mtext><mo accent="true">¯</mo></mover><mo>=</mo><msub><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mtext mathvariant="bold">𝐀</mtext></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><mtext mathvariant="bold">𝐀</mtext></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mrow><mi>n</mi><mo>×</mo><msub><mi>n</mi><mi>h</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>m</mi><mo>+</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">\overline{\textbf{A}}=\begin{bmatrix}\textbf{A}&amp;\cdots&amp;\textbf{A}\end{bmatrix}_{n\times n_h(m+1)},</annotation></semantics></math>
and
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="bold">𝐀</mtext><mo>=</mo><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>φ</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>φ</mi><msub><mi>n</mi><mi>h</mi></msub></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>φ</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>φ</mi><msub><mi>n</mi><mi>h</mi></msub></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>n</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><mi>.</mi></mrow><annotation encoding="application/x-tex">\textbf{A}=\begin{bmatrix}\varphi_1(s_1)&amp;\cdots&amp;\varphi_{n_h}(s_1)\\\vdots&amp;\vdots&amp;\vdots\\\varphi_1(s_n)&amp;\cdots&amp;\varphi_{n_h}(s_n)\end{bmatrix}.</annotation></semantics></math>
We then arrive at the following hierarchical model:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtable><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="bold">𝐲</mtext><mo>∣</mo><mtext mathvariant="bold">𝐗</mtext></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msub><mi>σ</mi><mi>ε</mi></msub><mtext mathvariant="bold">𝐈</mtext><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mtext mathvariant="bold">𝐗</mtext></mtd><mtd columnalign="left" style="text-align: left"><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msup><mtext mathvariant="bold">𝐐</mtext><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo stretchy="true" form="postfix">)</mo></mrow></mtd></mtr></mtable><mi>.</mi></mrow><annotation encoding="application/x-tex">\begin{align} \textbf{y}\mid \textbf{X} &amp;\sim N(0,\sigma_\varepsilon\textbf{I})\\ \textbf{X}&amp;\sim N(0,\textbf{Q}^{-1}) \end{align}.</annotation></semantics></math></p>
<p>With these elements, we can, for example, use <a href="https://www.r-inla.org" class="external-link"><code>R-INLA</code></a> to compute the
posterior distribution of the three parameters we want to estimate.</p>
</div>
<div class="section level2">
<h2 id="constructing-the-approximation">Constructing the approximation<a class="anchor" aria-label="anchor" href="#constructing-the-approximation"></a>
</h2>
<p>In this section, we explain how to to use the function
<code><a href="../reference/matern.operators.html">matern.operators()</a></code> with the default argument
<code>type</code>, that is, <code>type="covariance"</code>, which is
constructs the covariance-based rational approximation. We will also
illustrate the usage of several methods and functions related to the
covariance-based rational approximation. We will use functions to sample
from Gaussian fields with stationary Matérn covariance function, compute
the log-likelihood function, and do spatial prediction.</p>
<p>The first step for performing the covariance-based rational SPDE
approximation is to define the FEM mesh. We will also illustrate how
spatial models can be constructed if the FEM implementation of the
<code>fmesher</code> package is used. When using the <a href="https://www.r-inla.org" class="external-link"><code>R-INLA</code></a> package, we also
recommend the usage of our <a href="https://www.r-inla.org" class="external-link"><code>R-INLA</code></a> implementation of
the rational SPDE approach. For more details, see the <a href="rspde_inla.html">R-INLA implementation of the rational SPDE
approach</a> vignette.</p>
<p>We begin by loading the <code>rSPDE</code> package:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://davidbolin.github.io/rSPDE/">rSPDE</a></span><span class="op">)</span></span></code></pre></div>
<p>Assume that we want to define a model on the interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">[0,1]</annotation></semantics></math>.
We then start by defining a vector with mesh nodes
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>s</mi><mi>i</mi></msub><annotation encoding="application/x-tex">s_i</annotation></semantics></math>
where the basis functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>φ</mi><mi>i</mi></msub><annotation encoding="application/x-tex">\varphi_i</annotation></semantics></math>
are centered.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">s</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">0</span>, to <span class="op">=</span> <span class="fl">1</span>, length.out <span class="op">=</span> <span class="fl">101</span><span class="op">)</span></span></code></pre></div>
<p>We can now use <code><a href="../reference/matern.operators.html">matern.operators()</a></code> to construct a
rational SPDE approximation of order
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">m=2</annotation></semantics></math>
for a Gaussian random field with a Matérn covariance function on the
interval. We also refer the reader to the <a href="rspde_base.html">Operator-based rational approximation</a> for a
similar comparison made for the operator-based rational
approximation.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">kappa</span> <span class="op">&lt;-</span> <span class="fl">20</span></span>
<span><span class="va">sigma</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">nu</span> <span class="op">&lt;-</span> <span class="fl">0.8</span></span>
<span><span class="va">r</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="fl">8</span><span class="op">*</span><span class="va">nu</span><span class="op">)</span><span class="op">/</span><span class="va">kappa</span> <span class="co">#range parameter</span></span>
<span><span class="va">op_cov</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span>loc_mesh <span class="op">=</span> <span class="va">s</span>, nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>  range <span class="op">=</span> <span class="va">r</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="fl">2</span>, parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The object <code>op_cov</code> contains the matrices needed for
evaluating the distribution of the stochastic weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">u</mi><annotation encoding="application/x-tex">\boldsymbol{\mathrm{u}}</annotation></semantics></math>.
If we want to evaluate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>u</mi><mi>h</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">u_h(s)</annotation></semantics></math>
at some locations
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>s</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">s_1,\ldots, s_n</annotation></semantics></math>,
we need to multiply the weights with the basis functions
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>φ</mi><mi>i</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><mi>s</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varphi_i(s)</annotation></semantics></math>
evaluated at the locations. For this, we can construct the observation
matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">A</mi><annotation encoding="application/x-tex">\boldsymbol{\mathrm{A}}</annotation></semantics></math>,
with elements
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>A</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>φ</mi><mi>j</mi></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">A_{ij} = \varphi_j(s_i)</annotation></semantics></math>,
which links the FEM basis functions to the locations. This matrix can be
constructed using the function <code><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis()</a></code> from the
<code>fmesher</code> package. However, as observed in the introduction
of this vignette, we have decomposed the stochastic weights
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">u</mi><annotation encoding="application/x-tex">\boldsymbol{\mathrm{u}}</annotation></semantics></math>
into a vector of latent variables. Thus, the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
matrix for the covariance-based rational approximation, which we will
denote by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mover><mi>A</mi><mo accent="true">¯</mo></mover><annotation encoding="application/x-tex">\overline{A}</annotation></semantics></math>,
is actually given by the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">m+1</annotation></semantics></math>-fold
horizontal concatenation of these
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
matrices, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
is the order of the rational approximation. <!-- 
To compute the precision matrix from the covariance-based rational approximation one
can use the `precision()` method on the `CBrSPDEobj` object (the object returned by
the `matern.operators()` function with the default type, which is
`type="covariance"`):

# ```{r}
# Q <- precision(op_cov)
# ``` 

--></p>
<p>To evaluate the accuracy of the approximation, let us compute the
covariance function between the process at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mo>=</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">s=0.5</annotation></semantics></math>
and all other locations in <code>s</code> and compare with the true
Matérn covariance function. The covariances can be calculated by using
the <code>cov_function_mesh()</code> method. <!-- as 
$$
\overline{\boldsymbol{\mathrm{A}}} \boldsymbol{\mathrm{Q}}^{-1}\overline{\boldsymbol{\mathrm{v}}}.
$$
Here, $\boldsymbol{\mathrm{Q}}$ is the precision matrix obtained from the covariance-based rational approximation, $\boldsymbol{\mathrm{A}}$ is an identity matrix since we are evaluating the approximation in the nodes of the FEM mesh, $\overline{\boldsymbol{\mathrm{v}}}$ is the $(m+1)$-fold vertical concatenation of the vector $\boldsymbol{\mathrm{v}}$, where $\boldsymbol{\mathrm{v}}$ is a vector with all basis functions evaluated in $s=0.5$.
--></p>
<!-- 
# ```{r}
#library(fmesher)
#mesh_1d <- fm_mesh_1d(s)
#v <- t(fm_basis(x = mesh_1d, loc = 0.5))
#v_bar <- kronecker(matrix(1, nrow = 3), v)
#A <- Diagonal(101)
#A_bar <- kronecker(matrix(1, ncol = 3), A)
#c_cov.approx <- (A_bar) %*% solve(Q, v_bar)
# ``` 
-->
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">c_cov.approx</span> <span class="op">&lt;-</span> <span class="va">op_cov</span><span class="op">$</span><span class="fu">cov_function_mesh</span><span class="op">(</span><span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p>Let us now compute the true Matérn covariance function on the
interval
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0,1)</annotation></semantics></math>,
which is the folded Matérn, see Theorem 1 in <a href="https://www.jstor.org/stable/41262260" class="external-link">An explicit link between
Gaussian fields and Gaussian Markov random fields: the stochastic
partial differential equation approach</a> for further details.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">c.true</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/folded.matern.covariance.1d.html">folded.matern.covariance.1d</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">s</span><span class="op">)</span><span class="op">)</span>, </span>
<span>                                      <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="va">s</span><span class="op">)</span>, <span class="va">kappa</span>, <span class="va">nu</span>, <span class="va">sigma</span><span class="op">)</span></span></code></pre></div>
<p>The covariance function and the error compared with the Matérn
covariance are shown in the following figure.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">opar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span></span>
<span>  mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, mgp <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1.3</span>, <span class="fl">0.5</span>, <span class="fl">0</span><span class="op">)</span>,</span>
<span>  mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">)</span> <span class="op">+</span> <span class="fl">0.1</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c.true</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"l"</span>, ylab <span class="op">=</span> <span class="st">"C(|s-0.5|)"</span>, xlab <span class="op">=</span> <span class="st">"s"</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">5</span><span class="op">)</span>,</span>
<span>  cex.main <span class="op">=</span> <span class="fl">0.8</span>, cex.axis <span class="op">=</span> <span class="fl">0.8</span>, cex.lab <span class="op">=</span> <span class="fl">0.8</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c_cov.approx</span>, col <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">"topright"</span>,</span>
<span>  bty <span class="op">=</span> <span class="st">"n"</span>,</span>
<span>  legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Matérn"</span>, <span class="st">"Rational"</span><span class="op">)</span>,</span>
<span>  col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"black"</span>, <span class="st">"red"</span><span class="op">)</span>,</span>
<span>  lty <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  cex <span class="op">=</span> <span class="fl">0.8</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c.true</span> <span class="op">-</span> <span class="va">c_cov.approx</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"l"</span>, ylab <span class="op">=</span> <span class="st">"Error"</span>, xlab <span class="op">=</span> <span class="st">"s"</span>,</span>
<span>  cex.main <span class="op">=</span> <span class="fl">0.8</span>, cex.axis <span class="op">=</span> <span class="fl">0.8</span>, cex.lab <span class="op">=</span> <span class="fl">0.8</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span><span class="va">opar</span><span class="op">)</span></span></code></pre></div>
<p><img src="rspde_cov_files/figure-html/unnamed-chunk-6-1.png" width="700" style="display: block; margin: auto;"></p>
<p>To improve the approximation we can increase the degree of the
polynomials, by increasing
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>,
and/or increase the number of basis functions used for the FEM
approximation. Let us, for example, compute the approximation with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">m=4</annotation></semantics></math>
using the same mesh, as well as the approximation when we increase the
number of basis functions and use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">m=2</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">m=4</annotation></semantics></math>.
We will also load the <code>fmesher</code> package to use the
<code><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis()</a></code> and <code><a href="https://inlabru-org.github.io/fmesher/reference/fm_mesh_1d.html" class="external-link">fm_mesh_1d()</a></code> functions to map
between the meshes.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://inlabru-org.github.io/fmesher/" class="external-link">fmesher</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">op_cov2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>  range <span class="op">=</span> <span class="va">r</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>  loc_mesh <span class="op">=</span> <span class="va">s</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">c_cov.approx2</span> <span class="op">&lt;-</span> <span class="va">op_cov2</span><span class="op">$</span><span class="fu">cov_function_mesh</span><span class="op">(</span><span class="fl">0.5</span><span class="op">)</span></span>
<span></span>
<span><span class="va">s2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">0</span>, to <span class="op">=</span> <span class="fl">1</span>, length.out <span class="op">=</span> <span class="fl">501</span><span class="op">)</span></span>
<span></span>
<span><span class="va">op_cov</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>  range <span class="op">=</span> <span class="va">r</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>  loc_mesh <span class="op">=</span> <span class="va">s2</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">mesh_s2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_mesh_1d.html" class="external-link">fm_mesh_1d</a></span><span class="op">(</span><span class="va">s2</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Map the mesh s2 to s</span></span>
<span><span class="va">A2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis</a></span><span class="op">(</span><span class="va">mesh_s2</span>, <span class="va">s</span><span class="op">)</span></span>
<span></span>
<span><span class="va">c_cov.approx3</span> <span class="op">&lt;-</span> <span class="va">A2</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">op_cov</span><span class="op">$</span><span class="fu">cov_function_mesh</span><span class="op">(</span><span class="fl">0.5</span><span class="op">)</span></span>
<span></span>
<span><span class="va">op_cov</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>  range <span class="op">=</span> <span class="va">r</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>  loc_mesh <span class="op">=</span> <span class="va">s2</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="fl">4</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">c_cov.approx4</span> <span class="op">&lt;-</span> <span class="va">A2</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">op_cov</span><span class="op">$</span><span class="fu">cov_function_mesh</span><span class="op">(</span><span class="fl">0.5</span><span class="op">)</span></span></code></pre></div>
<p>The resulting errors are shown in the following figure.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">opar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mgp <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1.3</span>, <span class="fl">0.5</span>, <span class="fl">0</span><span class="op">)</span>, mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">)</span> <span class="op">+</span> <span class="fl">0.1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c.true</span> <span class="op">-</span> <span class="va">c_cov.approx</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"l"</span>, ylab <span class="op">=</span> <span class="st">"Error"</span>, xlab <span class="op">=</span> <span class="st">"s"</span>, col <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  cex.main <span class="op">=</span> <span class="fl">0.8</span>, cex.axis <span class="op">=</span> <span class="fl">0.8</span>, cex.lab <span class="op">=</span> <span class="fl">0.8</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c.true</span> <span class="op">-</span> <span class="va">c_cov.approx2</span>, col <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c.true</span> <span class="op">-</span> <span class="va">c_cov.approx3</span>, col <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c.true</span> <span class="op">-</span> <span class="va">c_cov.approx4</span>, col <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">"bottomright"</span>,</span>
<span>  bty <span class="op">=</span> <span class="st">"n"</span>,</span>
<span>  legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"m=2 coarse mesh"</span>, <span class="st">"m=4 coarse mesh"</span>, </span>
<span>             <span class="st">"m=2 fine mesh"</span>, <span class="st">"m=4 fine mesh"</span><span class="op">)</span>,</span>
<span>  col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">4</span><span class="op">)</span>,</span>
<span>  lty <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  cex <span class="op">=</span> <span class="fl">0.8</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span><span class="va">opar</span><span class="op">)</span></span></code></pre></div>
<p><img src="rspde_cov_files/figure-html/unnamed-chunk-8-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Since the error induced by the rational approximation decreases
exponentially in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>,
there is in general rarely a need for an approximation with a large
value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>.
This is good because the size of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi mathvariant="normal">Q</mi><annotation encoding="application/x-tex">\boldsymbol{\mathrm{Q}}</annotation></semantics></math>
increases with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>,
which makes the approximation more computationally costly to use. To
illustrate this, let us compute the norm of the approximation error for
different
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Mapping s2 to s</span></span>
<span><span class="va">A2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis</a></span><span class="op">(</span><span class="va">mesh_s2</span>, <span class="va">s</span><span class="op">)</span></span>
<span></span>
<span><span class="va">errors</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">4</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">op_cov</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>    range <span class="op">=</span> <span class="va">r</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>    loc_mesh <span class="op">=</span> <span class="va">s2</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="va">i</span>,</span>
<span>    parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">c_cov.approx</span> <span class="op">&lt;-</span> <span class="va">A2</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">op_cov</span><span class="op">$</span><span class="fu">cov_function_mesh</span><span class="op">(</span><span class="fl">0.5</span><span class="op">)</span></span>
<span>  <span class="va">errors</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/norm-methods.html" class="external-link">norm</a></span><span class="op">(</span><span class="va">c.true</span> <span class="op">-</span> <span class="va">c_cov.approx</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.977500618 0.086659189 0.017335545 0.008432137</span></span></code></pre>
<p>We see that the error decreases very fast when we increase
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math>,
without any numerical instability. This is an advantage of the
covariance-based rational approximation when compared to the
operator-based rational approximation. See <a href="rspde_base.html">Operator-based rational approximation</a> for
details on the numerical instability of the operator-based rational
approximation.</p>
</div>
<div class="section level2">
<h2 id="using-the-approximation">Using the approximation<a class="anchor" aria-label="anchor" href="#using-the-approximation"></a>
</h2>
<p>When we use the function <code><a href="../reference/matern.operators.html">matern.operators()</a></code>, we can
simulate from the model using the <code><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate()</a></code> method. To
such an end we simply apply the <code><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate()</a></code> method to the
object returned by the <code><a href="../reference/matern.operators.html">matern.operators()</a></code> function:</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate</a></span><span class="op">(</span><span class="va">op_cov</span><span class="op">)</span></span></code></pre></div>
<p>If we want replicates, we simply set the argument <code>nsim</code>
to the desired number of replicates. For instance, to generate two
replicates of the model, we simply do:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">u.rep</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate</a></span><span class="op">(</span><span class="va">op_cov</span>, nsim <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="fitting-a-model">Fitting a model<a class="anchor" aria-label="anchor" href="#fitting-a-model"></a>
</h3>
<p>There is built-in support for computing log-likelihood functions and
performing kriging prediction in the <code>rSPDE</code> package. To
illustrate this, we use the simulation to create some noisy observations
of the process. For this, we first construct the observation matrix
linking the FEM basis functions to the locations where we want to
simulate. We first randomly generate some observation locations and then
construct the matrix.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">s</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">0</span>, to <span class="op">=</span> <span class="fl">1</span>, length.out <span class="op">=</span> <span class="fl">501</span><span class="op">)</span></span>
<span><span class="va">n.obs</span> <span class="op">&lt;-</span> <span class="fl">200</span></span>
<span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span></span>
<span><span class="va">mesh_s</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_mesh_1d.html" class="external-link">fm_mesh_1d</a></span><span class="op">(</span><span class="va">s</span><span class="op">)</span></span>
<span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">mesh_s</span>, loc <span class="op">=</span> <span class="va">obs.loc</span><span class="op">)</span></span></code></pre></div>
<p>We now generate the observations as
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Y</mi><mi>i</mi></msub><mo>=</mo><mn>2</mn><mo>−</mo><mi>x</mi><mn>1</mn><mo>+</mo><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ε</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">Y_i = 2 - x1 + u(s_i) + \varepsilon_i</annotation></semantics></math>,
where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mi>i</mi></msub><mo>∼</mo><mi>N</mi><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><msubsup><mi>σ</mi><mi>e</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\varepsilon_i \sim N(0,\sigma_e^2)</annotation></semantics></math>
is Gaussian measurement noise,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">x1</annotation></semantics></math>
is a covariate giving the observation location. We will assume that the
latent process has a Matérn covariance with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>κ</mi><mo>=</mo><mn>20</mn><mo>,</mo><mi>σ</mi><mo>=</mo><mn>1.3</mn></mrow><annotation encoding="application/x-tex">\kappa=20, \sigma=1.3</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi><mo>=</mo><mn>0.8</mn></mrow><annotation encoding="application/x-tex">\nu=0.8</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">kappa</span> <span class="op">&lt;-</span> <span class="fl">20</span></span>
<span><span class="va">sigma</span> <span class="op">&lt;-</span> <span class="fl">1.3</span></span>
<span><span class="va">nu</span> <span class="op">&lt;-</span> <span class="fl">0.8</span></span>
<span><span class="va">r</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="fl">8</span><span class="op">*</span><span class="va">nu</span><span class="op">)</span><span class="op">/</span><span class="va">kappa</span></span>
<span><span class="va">op_cov</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>  loc_mesh <span class="op">=</span> <span class="va">s</span>, nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>  range <span class="op">=</span> <span class="va">r</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate</a></span><span class="op">(</span><span class="va">op_cov</span><span class="op">)</span></span>
<span></span>
<span><span class="va">sigma.e</span> <span class="op">&lt;-</span> <span class="fl">0.3</span></span>
<span></span>
<span><span class="va">x1</span> <span class="op">&lt;-</span> <span class="va">obs.loc</span></span>
<span></span>
<span><span class="va">Y</span> <span class="op">&lt;-</span> <span class="fl">2</span> <span class="op">-</span> <span class="va">x1</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">A</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">u</span> <span class="op">+</span> <span class="va">sigma.e</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">df_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">Y</span>, loc <span class="op">=</span> <span class="va">obs.loc</span>, x1 <span class="op">=</span> <span class="va">x1</span><span class="op">)</span></span></code></pre></div>
<p>Let us create a new object to fit the model:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">op_cov_est</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>  loc_mesh <span class="op">=</span> <span class="va">s</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="fl">2</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Let us now fit the model. To this end we will use the
<code><a href="../reference/rspde_lme.html">rspde_lme()</a></code> function:</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rspde_lme.html">rspde_lme</a></span><span class="op">(</span><span class="va">y</span><span class="op">~</span><span class="va">x1</span>, model <span class="op">=</span> <span class="va">op_cov_est</span>,</span>
<span>                    data <span class="op">=</span> <span class="va">df_data</span>, loc <span class="op">=</span> <span class="st">"loc"</span><span class="op">)</span></span></code></pre></div>
<p>We can get a summary of the fit with the <code><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary()</a></code>
method:</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fit</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Whittle-Matern</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rspde_lme(formula = y ~ x1, loc = "loc", data = df_data, model = op_cov_est)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)</span></span>
<span><span class="co">## (Intercept)   1.2977    1.1935   1.087    0.277</span></span>
<span><span class="co">## x1           -0.5586    2.0517  -0.272    0.785</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##        Estimate Std.error z-value</span></span>
<span><span class="co">## alpha  1.342557  0.053412  25.136</span></span>
<span><span class="co">## tau    0.038168  0.009482   4.025</span></span>
<span><span class="co">## kappa 16.477711  5.252625   3.137</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects (Matern parameterization):</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## nu     0.84256   0.05341  15.775</span></span>
<span><span class="co">## sigma  1.47083   0.31851   4.618</span></span>
<span><span class="co">## range  0.15756   0.04912   3.208</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev  0.33075   0.02231   14.83</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -145.9036 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 111</span></span>
<span><span class="co">## Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  22.83868 secs</span></span></code></pre>
<p>Let us compare the parameters of the latent model:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  sigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="va">fit</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>, </span>
<span>  range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">r</span>, <span class="va">fit</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  nu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">nu</span>, <span class="va">fit</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  row.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Truth"</span>, <span class="st">"Estimates"</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##              sigma     range        nu</span></span>
<span><span class="co">## Truth     1.300000 0.1264911 0.8000000</span></span>
<span><span class="co">## Estimates 1.470833 0.1575606 0.8425568</span></span></code></pre>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Total time</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">fit</span><span class="op">$</span><span class="va">fitting_time</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Time difference of 22.83868 secs</span></span></code></pre>
<p>Let us take a glance at the fit:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/glance.rspde_lme.html">glance</a></span><span class="op">(</span><span class="va">fit</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## <span style="color: #949494;"># A tibble: 1 × 9</span></span></span>
<span><span class="co">##    nobs sigma logLik   AIC   BIC deviance df.residual model                alpha</span></span>
<span><span class="co">##   <span style="color: #949494; font-style: italic;">&lt;int&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>       <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>                <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">## <span style="color: #BCBCBC;">1</span>   200 0.331  -<span style="color: #BB0000;">146.</span>  304.  324.     292.         194 Covariance-Based Ma…  1.34</span></span></code></pre>
<p>We can also speed up the optimization by setting
<code>parallel=TRUE</code> (which uses implicitly the
<code>optimParallel</code> function):</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit_par</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rspde_lme.html">rspde_lme</a></span><span class="op">(</span><span class="va">y</span><span class="op">~</span><span class="va">x1</span>, model <span class="op">=</span> <span class="va">op_cov_est</span>,</span>
<span>                    data <span class="op">=</span> <span class="va">df_data</span>, loc <span class="op">=</span> <span class="st">"loc"</span>, parallel <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Here is the summary:</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fit_par</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Whittle-Matern</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rspde_lme(formula = y ~ x1, loc = "loc", data = df_data, model = op_cov_est, </span></span>
<span><span class="co">##     parallel = TRUE)</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Fixed effects:</span></span>
<span><span class="co">##             Estimate Std.error z-value Pr(&gt;|z|)</span></span>
<span><span class="co">## (Intercept)   1.2977    1.1935   1.087    0.277</span></span>
<span><span class="co">## x1           -0.5586    2.0517  -0.272    0.785</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##        Estimate Std.error z-value</span></span>
<span><span class="co">## alpha  1.342557  0.053412  25.136</span></span>
<span><span class="co">## tau    0.038168  0.009482   4.025</span></span>
<span><span class="co">## kappa 16.477711  5.252625   3.137</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects (Matern parameterization):</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## nu     0.84256   0.05341  15.775</span></span>
<span><span class="co">## sigma  1.47083   0.31851   4.618</span></span>
<span><span class="co">## range  0.15756   0.04912   3.208</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev  0.33075   0.02231   14.83</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -145.9036 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 111</span></span>
<span><span class="co">## Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  15.28355 secs </span></span>
<span><span class="co">##   set up the parallelization = 2.45385 secs</span></span></code></pre>
<p>Let us compare with the true values and compare the time:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  sigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="va">fit_par</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>, </span>
<span>  range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">r</span>, <span class="va">fit_par</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  nu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">nu</span>, <span class="va">fit_par</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  row.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Truth"</span>, <span class="st">"Estimates"</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##              sigma     range        nu</span></span>
<span><span class="co">## Truth     1.300000 0.1264911 0.8000000</span></span>
<span><span class="co">## Estimates 1.470833 0.1575606 0.8425568</span></span></code></pre>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Total time (time to fit plus time to set up the parallelization)</span></span>
<span><span class="va">total_time</span> <span class="op">&lt;-</span> <span class="va">fit_par</span><span class="op">$</span><span class="va">fitting_time</span> <span class="op">+</span> <span class="va">fit_par</span><span class="op">$</span><span class="va">time_par</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">total_time</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Time difference of 17.73741 secs</span></span></code></pre>
</div>
<div class="section level3">
<h3 id="kriging">Kriging<a class="anchor" aria-label="anchor" href="#kriging"></a>
</h3>
<p>Finally, we compute the kriging prediction of the process
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>u</mi><annotation encoding="application/x-tex">u</annotation></semantics></math>
at the locations in <code>s</code> based on these observations.</p>
<p>Let us create the <code>data.frame</code> with locations in which we
want to obtain the predictions. Observe that we also must provide the
values of the covariates.</p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>loc <span class="op">=</span> <span class="va">s</span>, x1 <span class="op">=</span> <span class="va">s</span><span class="op">)</span></span></code></pre></div>
<p>We can now perform kriging with the <code><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict()</a></code>
method:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">u.krig</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">fit</span>, newdata <span class="op">=</span> <span class="va">df_pred</span>, loc <span class="op">=</span> <span class="st">"loc"</span><span class="op">)</span></span></code></pre></div>
<p>The simulated process, the observed data, and the kriging prediction
are shown in the following figure.</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">opar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mgp <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1.3</span>, <span class="fl">0.5</span>, <span class="fl">0</span><span class="op">)</span>, mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">)</span> <span class="op">+</span> <span class="fl">0.1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">obs.loc</span>, <span class="va">Y</span>,</span>
<span>  ylab <span class="op">=</span> <span class="st">"u(s)"</span>, xlab <span class="op">=</span> <span class="st">"s"</span>,</span>
<span>  ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">u</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">Y</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">u</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">Y</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  cex.main <span class="op">=</span> <span class="fl">0.8</span>, cex.axis <span class="op">=</span> <span class="fl">0.8</span>, cex.lab <span class="op">=</span> <span class="fl">0.8</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">u.krig</span><span class="op">$</span><span class="va">mean</span>, col <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span><span class="va">opar</span><span class="op">)</span></span></code></pre></div>
<p><img src="rspde_cov_files/figure-html/unnamed-chunk-24-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We can also use the <code><a href="../reference/augment.rspde_lme.html">augment()</a></code> function and pipe the
results into a plot:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://ggplot2.tidyverse.org" class="external-link">ggplot2</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://dplyr.tidyverse.org" class="external-link">dplyr</a></span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="../reference/augment.rspde_lme.html">augment</a></span><span class="op">(</span><span class="va">fit</span>, newdata <span class="op">=</span> <span class="va">df_pred</span>, loc <span class="op">=</span> <span class="st">"loc"</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html" class="external-link">%&gt;%</a></span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> </span>
<span>                <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">loc</span>, y <span class="op">=</span> <span class="va">.fitted</span><span class="op">)</span> <span class="op">+</span></span>
<span>                <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_path.html" class="external-link">geom_line</a></span><span class="op">(</span>col<span class="op">=</span><span class="st">"red"</span><span class="op">)</span> <span class="op">+</span> </span>
<span>                <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html" class="external-link">geom_point</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">df_data</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">loc</span>, y<span class="op">=</span><span class="va">Y</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p><img src="rspde_cov_files/figure-html/unnamed-chunk-25-1.png" width="700"></p>
</div>
</div>
<div class="section level2">
<h2 id="fitting-a-model-with-replicates">Fitting a model with replicates<a class="anchor" aria-label="anchor" href="#fitting-a-model-with-replicates"></a>
</h2>
<p>Let us illustrate how to simulate a dataset with replicates and then
fit a model to such data. Recall that to simulate a latent model with
replicates, all we do is set the <code>nsim</code> argument to the
number of replicates.</p>
<p>We will use the <code>CBrSPDEobj</code> object (returned from the
<code><a href="../reference/matern.operators.html">matern.operators()</a></code> function) from the previous example,
namely <code>op_cov</code>.</p>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/Random.html" class="external-link">set.seed</a></span><span class="op">(</span><span class="fl">123</span><span class="op">)</span></span>
<span><span class="va">n.rep</span> <span class="op">&lt;-</span> <span class="fl">20</span></span>
<span><span class="va">u.rep</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate</a></span><span class="op">(</span><span class="va">op_cov</span>, nsim <span class="op">=</span> <span class="va">n.rep</span><span class="op">)</span></span></code></pre></div>
<p>Now, let us generate the observed values
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>:</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sigma.e</span> <span class="op">&lt;-</span> <span class="fl">0.3</span></span>
<span><span class="va">Y.rep</span> <span class="op">&lt;-</span> <span class="va">A</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">u.rep</span> <span class="op">+</span> <span class="va">sigma.e</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span> <span class="op">*</span> <span class="va">n.rep</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">n.rep</span><span class="op">)</span></span></code></pre></div>
<p>Note that
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>Y</mi><annotation encoding="application/x-tex">Y</annotation></semantics></math>
is a matrix with 20 columns, each column containing one replicate. We
need to turn <code>y</code> into a vector and create an auxiliary vector
<code>repl</code> indexing the replicates of <code>y</code>:</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y_vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">Y.rep</span><span class="op">)</span></span>
<span><span class="va">repl</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">n.rep</span>, each <span class="op">=</span> <span class="va">n.obs</span><span class="op">)</span></span>
<span></span>
<span><span class="va">df_data_repl</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">y_vec</span>, loc <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="va">obs.loc</span>, <span class="va">n.rep</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>We can now fit the model in the same way as before by using the
<code><a href="../reference/rspde_lme.html">rspde_lme()</a></code> function:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit_repl</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rspde_lme.html">rspde_lme</a></span><span class="op">(</span><span class="va">y_vec</span> <span class="op">~</span> <span class="op">-</span><span class="fl">1</span>, model <span class="op">=</span> <span class="va">op_cov_est</span>, repl <span class="op">=</span> <span class="va">repl</span>, </span>
<span>      data <span class="op">=</span> <span class="va">df_data_repl</span>, loc <span class="op">=</span> <span class="st">"loc"</span>, parallel <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in rspde_lme(y_vec ~ -1, model = op_cov_est, repl = repl, data =</span></span>
<span><span class="co">## df_data_repl, : The optimization failed to provide a numerically</span></span>
<span><span class="co">## positive-definite Hessian. You can try to obtain a positive-definite Hessian by</span></span>
<span><span class="co">## setting 'improve_hessian' to TRUE or by setting 'parallel' to FALSE, which</span></span>
<span><span class="co">## allows other optimization methods to be used.</span></span></code></pre>
<pre><code><span><span class="co">## Warning in sqrt(diag(inv_fisher)): NaNs produced</span></span></code></pre>
<p>Let us see a summary of the fit:</p>
<div class="sourceCode" id="cb42"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fit_repl</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Whittle-Matern</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rspde_lme(formula = y_vec ~ -1, loc = "loc", data = df_data_repl, </span></span>
<span><span class="co">##     model = op_cov_est, repl = repl, parallel = TRUE)</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## No fixed effects.</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## alpha  1.28321       NaN     NaN</span></span>
<span><span class="co">## tau    0.04583       NaN     NaN</span></span>
<span><span class="co">## kappa 20.01370       NaN     NaN</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects (Matern parameterization):</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## nu    0.783209       NaN     NaN</span></span>
<span><span class="co">## sigma 1.271305  0.052037   24.43</span></span>
<span><span class="co">## range 0.125071  0.007832   15.97</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev 0.302680  0.004417   68.52</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -2758.186 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 34</span></span>
<span><span class="co">## Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  14.41901 secs </span></span>
<span><span class="co">##   set up the parallelization = 2.5052 secs</span></span></code></pre>
<p>and glance:</p>
<div class="sourceCode" id="cb46"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/glance.rspde_lme.html">glance</a></span><span class="op">(</span><span class="va">fit_repl</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## <span style="color: #949494;"># A tibble: 1 × 9</span></span></span>
<span><span class="co">##    nobs sigma logLik   AIC   BIC deviance df.residual model                alpha</span></span>
<span><span class="co">##   <span style="color: #949494; font-style: italic;">&lt;int&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>       <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>                <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">## <span style="color: #BCBCBC;">1</span>  <span style="text-decoration: underline;">4</span>000 0.303 -<span style="color: #BB0000; text-decoration: underline;">2</span><span style="color: #BB0000;">758.</span> <span style="text-decoration: underline;">5</span>524. <span style="text-decoration: underline;">5</span>550.    <span style="text-decoration: underline;">5</span>516.        <span style="text-decoration: underline;">3</span>996 Covariance-Based Ma…  1.28</span></span></code></pre>
<p>Let us compare with the true values:</p>
<div class="sourceCode" id="cb48"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  sigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="va">fit_repl</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>, </span>
<span>  range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">r</span>, <span class="va">fit_repl</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  nu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">nu</span>, <span class="va">fit_repl</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  row.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Truth"</span>, <span class="st">"Estimates"</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##              sigma     range        nu</span></span>
<span><span class="co">## Truth     1.300000 0.1264911 0.8000000</span></span>
<span><span class="co">## Estimates 1.271305 0.1250709 0.7832089</span></span></code></pre>
<div class="sourceCode" id="cb50"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Total time</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">fit_repl</span><span class="op">$</span><span class="va">fitting_time</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Time difference of 14.41901 secs</span></span></code></pre>
<p>We can obtain better estimates of the Hessian by setting
<code>improve_hessian</code> to <code>TRUE</code>, however this might
make the process take longer:</p>
<div class="sourceCode" id="cb52"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit_repl2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rspde_lme.html">rspde_lme</a></span><span class="op">(</span><span class="va">y_vec</span> <span class="op">~</span> <span class="op">-</span><span class="fl">1</span>, model <span class="op">=</span> <span class="va">op_cov_est</span>, repl <span class="op">=</span> <span class="va">repl</span>, </span>
<span>      data <span class="op">=</span> <span class="va">df_data_repl</span>, loc <span class="op">=</span> <span class="st">"loc"</span>, parallel <span class="op">=</span> <span class="cn">TRUE</span>, </span>
<span>      improve_hessian <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Let us get a summary:</p>
<div class="sourceCode" id="cb53"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fit_repl2</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Whittle-Matern</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rspde_lme(formula = y_vec ~ -1, loc = "loc", data = df_data_repl, </span></span>
<span><span class="co">##     model = op_cov_est, repl = repl, parallel = TRUE, improve_hessian = TRUE)</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## No fixed effects.</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##        Estimate Std.error z-value</span></span>
<span><span class="co">## alpha  1.283209  0.013648   94.02</span></span>
<span><span class="co">## tau    0.045834  0.003324   13.79</span></span>
<span><span class="co">## kappa 20.013699  1.369621   14.61</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects (Matern parameterization):</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## nu    0.783209  0.013648   57.39</span></span>
<span><span class="co">## sigma 1.271305  0.052038   24.43</span></span>
<span><span class="co">## range 0.125071  0.007832   15.97</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev 0.302680  0.004949   61.16</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -2758.186 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 34</span></span>
<span><span class="co">## Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  11.78098 secs </span></span>
<span><span class="co">##   compute the Hessian = 6.47201 secs </span></span>
<span><span class="co">##   set up the parallelization = 2.54947 secs</span></span></code></pre>
</div>
<div class="section level2">
<h2 id="spatial-data-and-parameter-estimation">Spatial data and parameter estimation<a class="anchor" aria-label="anchor" href="#spatial-data-and-parameter-estimation"></a>
</h2>
<p>The functions used in the previous examples also work for spatial
models. We then need to construct a mesh over the domain of interest and
then compute the matrices needed to define the operator. These tasks can
be performed, for example, using the <code>fmesher</code> package. Let
us start by defining a mesh over
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo>,</mo><mn>1</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">[0,1]\times [0, 1]</annotation></semantics></math>
and compute the mass and stiffness matrices for that mesh.</p>
<p>We consider a simple Gaussian linear model with 30 independent
replicates of a latent spatial field
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐬</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">u(\mathbf{s})</annotation></semantics></math>,
observed at the same
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
locations,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>𝐬</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>𝐬</mi><mi>m</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\mathbf{s}_1 , \ldots , \mathbf{s}_m \}</annotation></semantics></math>,
for each replicate. For each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>m</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">i = 1,\ldots,m,</annotation></semantics></math>
we have</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>y</mi><mi>i</mi></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>u</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐬</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ε</mi><mi>i</mi></msub><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mi>⋮</mi></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><msub><mi>y</mi><mrow><mi>i</mi><mo>+</mo><mn>29</mn><mi>m</mi></mrow></msub></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>u</mi><mn>30</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐬</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ε</mi><mrow><mi>i</mi><mo>+</mo><mn>29</mn><mi>m</mi></mrow></msub><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align} 
y_i &amp;= u_1(\mathbf{s}_i)+\varepsilon_i,\\
\vdots &amp;= \vdots\\

y_{i+29m} &amp;= u_{30}(\mathbf{s}_i) + \varepsilon_{i+29m},
\end{align}</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>ε</mi><mrow><mn>30</mn><mi>m</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\varepsilon_1,\ldots,\varepsilon_{30m}</annotation></semantics></math>
are iid normally distributed with mean 0 and standard deviation 0.1.</p>
<p>Let us create the FEM mesh:</p>
<div class="sourceCode" id="cb57"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n_loc</span> <span class="op">&lt;-</span> <span class="fl">500</span></span>
<span><span class="va">loc_2d_mesh</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">n_loc</span> <span class="op">*</span> <span class="fl">2</span><span class="op">)</span>, <span class="va">n_loc</span>, <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">mesh_2d</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_mesh_2d.html" class="external-link">fm_mesh_2d</a></span><span class="op">(</span></span>
<span>  loc <span class="op">=</span> <span class="va">loc_2d_mesh</span>,</span>
<span>  cutoff <span class="op">=</span> <span class="fl">0.05</span>,</span>
<span>  offset <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.4</span><span class="op">)</span>,</span>
<span>  max.edge <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.05</span>, <span class="fl">0.5</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">mesh_2d</span>, main <span class="op">=</span> <span class="st">""</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="va">loc_2d_mesh</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>, <span class="va">loc_2d_mesh</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p><img src="rspde_cov_files/figure-html/unnamed-chunk-35-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We can now use this mesh to define a rational SPDE approximation of
order
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">m=2</annotation></semantics></math>
for a Matérn model in the same fashion as we did above in the
one-dimensional case. We now simulate a latent process with standard
deviation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sigma=1</annotation></semantics></math>
and range
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0.1</mn><annotation encoding="application/x-tex">0.1</annotation></semantics></math>.
We will use
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi><mo>=</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">\nu=0.5</annotation></semantics></math>
so that the model has an exponential covariance function. To this end we
create a model object with the <code><a href="../reference/matern.operators.html">matern.operators()</a></code>
function:</p>
<div class="sourceCode" id="cb58"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nu</span> <span class="op">&lt;-</span> <span class="fl">0.7</span></span>
<span><span class="va">sigma</span> <span class="op">&lt;-</span> <span class="fl">1.3</span></span>
<span><span class="va">range</span> <span class="op">&lt;-</span> <span class="fl">0.15</span></span>
<span><span class="va">d</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">op_cov_2d</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>  mesh <span class="op">=</span> <span class="va">mesh_2d</span>,</span>
<span>  nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>  range <span class="op">=</span> <span class="va">range</span>,</span>
<span>  sigma <span class="op">=</span> <span class="va">sigma</span>,</span>
<span>  m <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span><span class="op">)</span></span>
<span><span class="va">tau</span> <span class="op">&lt;-</span> <span class="va">op_cov_2d</span><span class="op">$</span><span class="va">tau</span></span></code></pre></div>
<p>Now let us simulate some noisy data that we will use to estimate the
parameters of the model. To construct the observation matrix, we use the
function <code><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis()</a></code> from the <code>fmesher</code> package.
Recall that we will simulate the data with 30 replicates.</p>
<div class="sourceCode" id="cb59"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n.rep</span> <span class="op">&lt;-</span> <span class="fl">30</span></span>
<span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate</a></span><span class="op">(</span><span class="va">op_cov_2d</span>, nsim <span class="op">=</span> <span class="va">n.rep</span><span class="op">)</span></span>
<span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="va">mesh_2d</span>,</span>
<span>  loc <span class="op">=</span> <span class="va">loc_2d_mesh</span></span>
<span><span class="op">)</span></span>
<span><span class="va">sigma.e</span> <span class="op">&lt;-</span> <span class="fl">0.1</span></span>
<span><span class="va">Y</span> <span class="op">&lt;-</span> <span class="va">A</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">u</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n_loc</span> <span class="op">*</span> <span class="va">n.rep</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">n.rep</span><span class="op">)</span> <span class="op">*</span> <span class="va">sigma.e</span></span></code></pre></div>
<p>The first replicate of the simulated random field as well as the
observation locations are shown in the following figure.</p>
<div class="sourceCode" id="cb60"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://sjmgarnier.github.io/viridis/" class="external-link">viridis</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://ggplot2.tidyverse.org" class="external-link">ggplot2</a></span><span class="op">)</span></span>
<span><span class="va">proj</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_evaluate.html" class="external-link">fm_evaluator</a></span><span class="op">(</span><span class="va">mesh_2d</span>, dims <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">70</span>, <span class="fl">70</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">df_field</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">proj</span><span class="op">$</span><span class="va">lattice</span><span class="op">$</span><span class="va">loc</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>,</span>
<span>                        y <span class="op">=</span> <span class="va">proj</span><span class="op">$</span><span class="va">lattice</span><span class="op">$</span><span class="va">loc</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span>,</span>
<span>                        field <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_evaluate.html" class="external-link">fm_evaluate</a></span><span class="op">(</span><span class="va">proj</span>, </span>
<span>                        field <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">u</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                        type <span class="op">=</span> <span class="st">"field"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">df_loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">loc_2d_mesh</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>,</span>
<span>                      y <span class="op">=</span> <span class="va">loc_2d_mesh</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>,</span>
<span>                      field <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">Y</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>                      type <span class="op">=</span> <span class="st">"locations"</span><span class="op">)</span></span>
<span><span class="va">df_plot</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">df_field</span>, <span class="va">df_loc</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span><span class="va">df_plot</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span>, fill <span class="op">=</span> <span class="va">field</span><span class="op">)</span> <span class="op">+</span></span>
<span>        <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/facet_wrap.html" class="external-link">facet_wrap</a></span><span class="op">(</span><span class="op">~</span><span class="va">type</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/lims.html" class="external-link">xlim</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/lims.html" class="external-link">ylim</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span> <span class="op">+</span> </span>
<span>        <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_tile.html" class="external-link">geom_raster</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">df_field</span><span class="op">)</span> <span class="op">+</span></span>
<span>        <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html" class="external-link">geom_point</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">df_loc</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>colour <span class="op">=</span> <span class="va">field</span><span class="op">)</span>,</span>
<span>        show.legend <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> <span class="op">+</span> </span>
<span>        <span class="fu"><a href="https://sjmgarnier.github.io/viridis/reference/scale_viridis.html" class="external-link">scale_fill_viridis</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://sjmgarnier.github.io/viridis/reference/scale_viridis.html" class="external-link">scale_colour_viridis</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p><img src="rspde_cov_files/figure-html/unnamed-chunk-38-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Let us now create a new object to fit the model:</p>
<div class="sourceCode" id="cb61"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">op_cov_2d_est</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>  mesh <span class="op">=</span> <span class="va">mesh_2d</span>,</span>
<span>  m <span class="op">=</span> <span class="fl">2</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>We can now proceed as in the previous cases. We set up a vector with
the response variables and create an auxiliary replicates vector,
<code>repl</code>, that contains the indexes of the replicates of each
observation, and then we fit the model:</p>
<div class="sourceCode" id="cb62"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y_vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">Y</span><span class="op">)</span></span>
<span><span class="va">repl</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">n.rep</span>, each <span class="op">=</span> <span class="va">n_loc</span><span class="op">)</span></span>
<span><span class="va">df_data_2d</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">y_vec</span>, x_coord <span class="op">=</span> <span class="va">loc_2d_mesh</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>,</span>
<span>                      y_coord <span class="op">=</span> <span class="va">loc_2d_mesh</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span><span class="op">)</span></span>
<span></span>
<span><span class="va">fit_2d</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rspde_lme.html">rspde_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="op">-</span><span class="fl">1</span>, model <span class="op">=</span> <span class="va">op_cov_2d_est</span>, </span>
<span>          data <span class="op">=</span> <span class="va">df_data_2d</span>, repl <span class="op">=</span> <span class="va">repl</span>,</span>
<span>          loc <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"x_coord"</span>, <span class="st">"y_coord"</span><span class="op">)</span>, parallel <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Let us get a summary:</p>
<div class="sourceCode" id="cb63"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fit_2d</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Whittle-Matern</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rspde_lme(formula = y ~ -1, loc = c("x_coord", "y_coord"), data = df_data_2d, </span></span>
<span><span class="co">##     model = op_cov_2d_est, repl = repl, parallel = TRUE)</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## No fixed effects.</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## alpha  1.52782   0.04909  31.123</span></span>
<span><span class="co">## tau    0.07302   0.01346   5.423</span></span>
<span><span class="co">## kappa 13.13775   0.80390  16.342</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects (Matern parameterization):</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## nu    0.527816  0.049090   10.75</span></span>
<span><span class="co">## sigma 1.365723  0.014512   94.11</span></span>
<span><span class="co">## range 0.156410  0.005158   30.32</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##           Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev 0.1003218 0.0008777   114.3</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -5659.535 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 40</span></span>
<span><span class="co">## Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  1.71085 mins </span></span>
<span><span class="co">##   set up the parallelization = 4.85739 secs</span></span></code></pre>
<p>and glance:</p>
<div class="sourceCode" id="cb67"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/glance.rspde_lme.html">glance</a></span><span class="op">(</span><span class="va">fit_2d</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## <span style="color: #949494;"># A tibble: 1 × 9</span></span></span>
<span><span class="co">##    nobs sigma logLik    AIC    BIC deviance df.residual model              alpha</span></span>
<span><span class="co">##   <span style="color: #949494; font-style: italic;">&lt;int&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>       <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>              <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">## <span style="color: #BCBCBC;">1</span> <span style="text-decoration: underline;">15</span>000 0.100 -<span style="color: #BB0000; text-decoration: underline;">5</span><span style="color: #BB0000;">660.</span> <span style="text-decoration: underline;">11</span>327. <span style="text-decoration: underline;">11</span>358.   <span style="text-decoration: underline;">11</span>319.       <span style="text-decoration: underline;">14</span>996 Covariance-Based …  1.53</span></span></code></pre>
<p>Let us compare the estimated results with the true values:</p>
<div class="sourceCode" id="cb69"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  sigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="va">fit_2d</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>, </span>
<span>  range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">range</span>, <span class="va">fit_2d</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  nu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">nu</span>, <span class="va">fit_2d</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  row.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Truth"</span>, <span class="st">"Estimates"</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##              sigma     range        nu</span></span>
<span><span class="co">## Truth     1.300000 0.1500000 0.7000000</span></span>
<span><span class="co">## Estimates 1.365723 0.1564103 0.5278161</span></span></code></pre>
<div class="sourceCode" id="cb71"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Total time</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">fit_2d</span><span class="op">$</span><span class="va">fitting_time</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Time difference of 1.710854 mins</span></span></code></pre>
<p>Let us now plot the prediction for replicate 3 by using the
<code>augment</code> function. We begin by creating the
<code>data.frame</code> we want to do prediction:</p>
<div class="sourceCode" id="cb73"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df_pred</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">proj</span><span class="op">$</span><span class="va">lattice</span><span class="op">$</span><span class="va">loc</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>,</span>
<span>                        y <span class="op">=</span> <span class="va">proj</span><span class="op">$</span><span class="va">lattice</span><span class="op">$</span><span class="va">loc</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb74"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/augment.rspde_lme.html">augment</a></span><span class="op">(</span><span class="va">fit_2d</span>, newdata <span class="op">=</span> <span class="va">df_pred</span>, loc <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"x"</span>,<span class="st">"y"</span><span class="op">)</span>, which_repl <span class="op">=</span> <span class="fl">3</span><span class="op">)</span> <span class="op"><a href="https://magrittr.tidyverse.org/reference/pipe.html" class="external-link">%&gt;%</a></span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span></span>
<span>              <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_tile.html" class="external-link">geom_raster</a></span><span class="op">(</span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x<span class="op">=</span><span class="va">x</span>, y<span class="op">=</span><span class="va">y</span>, fill <span class="op">=</span> <span class="va">.fitted</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/lims.html" class="external-link">xlim</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/lims.html" class="external-link">ylim</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span> <span class="op">+</span> </span>
<span>              <span class="fu"><a href="https://sjmgarnier.github.io/viridis/reference/scale_viridis.html" class="external-link">scale_fill_viridis</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning: Removed 3744 rows containing missing values or values outside the scale range</span></span>
<span><span class="co">## (`geom_raster()`).</span></span></code></pre>
<p><img src="rspde_cov_files/figure-html/unnamed-chunk-45-1.png" width="700"></p>
</div>
<div class="section level2">
<h2 id="an-example-with-a-non-stationary-model">An example with a non-stationary model<a class="anchor" aria-label="anchor" href="#an-example-with-a-non-stationary-model"></a>
</h2>
<p>Our goal now is to show how one can fit model with non-stationary
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>σ</mi><annotation encoding="application/x-tex">\sigma</annotation></semantics></math>
(std. deviation) and non-stationary
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>ρ</mi><annotation encoding="application/x-tex">\rho</annotation></semantics></math>
(a range parameter). One can also use the parameterization in terms of
non-stationary SPDE parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>κ</mi><annotation encoding="application/x-tex">\kappa</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>τ</mi><annotation encoding="application/x-tex">\tau</annotation></semantics></math>.</p>
<p>For this example we will consider simulated data.</p>
<div class="section level3">
<h3 id="simulating-the-data">Simulating the data<a class="anchor" aria-label="anchor" href="#simulating-the-data"></a>
</h3>
<p>Let us consider a simple Gaussian linear model with a latent spatial
field
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐬</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">x(\mathbf{s})</annotation></semantics></math>,
defined on the rectangle
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>10</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>×</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>5</mn><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">(0,10) \times (0,5)</annotation></semantics></math>,
where the std. deviation and range parameter satisfy the following
log-linear regressions:
<math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable><mtr><mtd columnalign="right" style="text-align: right"><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>σ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐬</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>θ</mi><mn>1</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>3</mn></msub><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐬</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr><mtr><mtd columnalign="right" style="text-align: right"><mo>log</mo><mrow><mo stretchy="true" form="prefix">(</mo><mi>ρ</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐬</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mtd><mtd columnalign="left" style="text-align: left"><mo>=</mo><msub><mi>θ</mi><mn>2</mn></msub><mo>+</mo><msub><mi>θ</mi><mn>3</mn></msub><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐬</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>,</mo></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{align}
\log(\sigma(\mathbf{s})) &amp;= \theta_1 + \theta_3 b(\mathbf{s}),\\
\log(\rho(\mathbf{s})) &amp;= \theta_2 + \theta_3 b(\mathbf{s}),
\end{align}</annotation></semantics></math> where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>𝐬</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>s</mi><mn>1</mn></msub><mo>−</mo><mn>5</mn><mo stretchy="true" form="postfix">)</mo></mrow><mi>/</mi><mn>10</mn></mrow><annotation encoding="application/x-tex">b(\mathbf{s}) = (s_1-5)/10</annotation></semantics></math>.
We assume the data is observed at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>m</mi><annotation encoding="application/x-tex">m</annotation></semantics></math>
locations,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">{</mo><msub><mi>𝐬</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>𝐬</mi><mi>m</mi></msub><mo stretchy="false" form="postfix">}</mo></mrow><annotation encoding="application/x-tex">\{\mathbf{s}_1 , \ldots , \mathbf{s}_m \}</annotation></semantics></math>.
For each
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>,</mo><mi>…</mi><mo>,</mo><mi>m</mi><mo>,</mo></mrow><annotation encoding="application/x-tex">i = 1,\ldots,m,</annotation></semantics></math>
we have</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>y</mi><mi>i</mi></msub><mo>=</mo><msub><mi>x</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>𝐬</mi><mi>i</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>ε</mi><mi>i</mi></msub><mo>,</mo></mrow><annotation encoding="application/x-tex">y_i = x_1(\mathbf{s}_i)+\varepsilon_i,</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>ε</mi><mn>1</mn></msub><mo>,</mo><mi>…</mi><mo>,</mo><msub><mi>ε</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">\varepsilon_1,\ldots,\varepsilon_{m}</annotation></semantics></math>
are iid normally distributed with mean 0 and standard deviation 0.1.</p>
<p>We begin by defining the domain and creating the mesh:</p>
<div class="sourceCode" id="cb76"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">rec_domain</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">0</span>, <span class="fl">0</span><span class="op">)</span> <span class="op">*</span> <span class="fl">10</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">1</span>, <span class="fl">0</span><span class="op">)</span> <span class="op">*</span> <span class="fl">5</span><span class="op">)</span></span>
<span></span>
<span><span class="va">mesh</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_mesh_2d.html" class="external-link">fm_mesh_2d</a></span><span class="op">(</span>loc.domain <span class="op">=</span> <span class="va">rec_domain</span>, cutoff <span class="op">=</span> <span class="fl">0.1</span>, </span>
<span>  max.edge <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fl">1.5</span><span class="op">)</span>, offset <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fl">1.5</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>We follow the same structure as <code>INLA</code>. However,
<code>INLA</code> only allows one to specify <code>B.tau</code> and
<code>B.kappa</code> matrices, and, in <code>INLA</code>, if one wants
to parameterize in terms of range and standard deviation one needs to do
it manually. Here we provide the option to directly provide the matrices
<code>B.sigma</code> and <code>B.range</code>.</p>
<p>The usage of the matrices <code>B.tau</code> and <code>B.kappa</code>
are identical to the corresponding ones in
<code><a href="https://rdrr.io/pkg/INLA/man/inla.spde2.matern.html" class="external-link">inla.spde2.matern()</a></code> function. The matrices
<code>B.sigma</code> and <code>B.range</code> work in the same way, but
they parameterize the stardard deviation and range, respectively.</p>
<p>The columns of the <code>B</code> matrices correspond to the same
parameter. The first column does not have any parameter to be estimated,
it is a constant column.</p>
<p>So, for instance, if one wants to share a parameter with both
<code>sigma</code> and <code>range</code> (or with both <code>tau</code>
and <code>kappa</code>), one simply let the corresponding column to be
nonzero on both <code>B.sigma</code> and <code>B.range</code> (or on
<code>B.tau</code> and <code>B.kappa</code>).</p>
<p>We will assume
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ν</mi><mo>=</mo><mn>0.8</mn></mrow><annotation encoding="application/x-tex">\nu = 0.8</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>1</mn></msub><mo>=</mo><mn>0</mn><mo>,</mo><msub><mi>θ</mi><mn>2</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\theta_1 = 0, \theta_2 = 1</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>θ</mi><mn>3</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\theta_3=1</annotation></semantics></math>.
Let us now build the model with the <code><a href="../reference/spde.matern.operators.html">spde.matern.operators()</a></code>
function:</p>
<div class="sourceCode" id="cb77"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nu</span> <span class="op">&lt;-</span> <span class="fl">0.8</span></span>
<span><span class="va">true_theta</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">B.sigma</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span>, <span class="fl">0</span>, <span class="op">(</span><span class="va">mesh</span><span class="op">$</span><span class="va">loc</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">-</span> <span class="fl">5</span><span class="op">)</span> <span class="op">/</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">B.range</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">0</span>, <span class="fl">1</span>, <span class="op">(</span><span class="va">mesh</span><span class="op">$</span><span class="va">loc</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">-</span> <span class="fl">5</span><span class="op">)</span> <span class="op">/</span> <span class="fl">10</span><span class="op">)</span></span>
<span><span class="va">alpha</span> <span class="op">&lt;-</span> <span class="va">nu</span> <span class="op">+</span> <span class="fl">1</span> <span class="co"># nu + d/2 ; d = 2</span></span>
<span></span>
<span><span class="co"># SPDE model</span></span>
<span><span class="va">op_cov_ns</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/spde.matern.operators.html">spde.matern.operators</a></span><span class="op">(</span>mesh <span class="op">=</span> <span class="va">mesh</span>, </span>
<span>  theta <span class="op">=</span> <span class="va">true_theta</span>,</span>
<span>  nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>  B.sigma <span class="op">=</span> <span class="va">B.sigma</span>, </span>
<span>  B.range <span class="op">=</span> <span class="va">B.range</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span><span class="op">)</span></span></code></pre></div>
<p>Let us now sample the data with the <code><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate()</a></code>
method:</p>
<div class="sourceCode" id="cb78"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate</a></span><span class="op">(</span><span class="va">op_cov_ns</span>, seed <span class="op">=</span> <span class="fl">123</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Let us now obtain 600 random locations on the rectangle and compute
the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
matrix:</p>
<div class="sourceCode" id="cb79"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">m</span> <span class="op">&lt;-</span><span class="fl">600</span></span>
<span><span class="va">loc_mesh</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">m</span><span class="op">)</span> <span class="op">*</span> <span class="fl">10</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">m</span><span class="op">)</span> <span class="op">*</span> <span class="fl">5</span><span class="op">)</span></span>
<span></span>
<span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="va">mesh</span>,</span>
<span>  loc <span class="op">=</span> <span class="va">loc_mesh</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>We can now generate the response vector <code>y</code>:</p>
<div class="sourceCode" id="cb80"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">A</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">u</span><span class="op">)</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">m</span><span class="op">)</span> <span class="op">*</span> <span class="fl">0.1</span></span></code></pre></div>
<p>Let us now create the object to fit the data:</p>
<div class="sourceCode" id="cb81"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">op_cov_ns_est</span> <span class="op">&lt;-</span> <span class="va">op_cov_ns</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/spde.matern.operators.html">spde.matern.operators</a></span><span class="op">(</span>mesh <span class="op">=</span> <span class="va">mesh</span>, </span>
<span>  B.sigma <span class="op">=</span> <span class="va">B.sigma</span>, </span>
<span>  B.range <span class="op">=</span> <span class="va">B.range</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span><span class="op">)</span></span></code></pre></div>
<p>Let us also create the <code><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame()</a></code> that contains the
data and the locations:</p>
<div class="sourceCode" id="cb82"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">df_data_ns</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>y<span class="op">=</span> <span class="va">y</span>, x_coord <span class="op">=</span> <span class="va">loc_mesh</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>, y_coord <span class="op">=</span> <span class="va">loc_mesh</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="fitting-the-non-stationary-rspde-model">Fitting the non-stationary rSPDE model<a class="anchor" aria-label="anchor" href="#fitting-the-non-stationary-rspde-model"></a>
</h3>
<div class="sourceCode" id="cb83"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit_ns</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rspde_lme.html">rspde_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="op">-</span><span class="fl">1</span>, model <span class="op">=</span> <span class="va">op_cov_ns_est</span>, </span>
<span>          data <span class="op">=</span> <span class="va">df_data_ns</span>, loc <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"x_coord"</span>, <span class="st">"y_coord"</span><span class="op">)</span>, </span>
<span>          parallel <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Let us get the summary:</p>
<div class="sourceCode" id="cb84"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fit_ns</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Generalized Whittle-Matern</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rspde_lme(formula = y ~ -1, loc = c("x_coord", "y_coord"), data = df_data_ns, </span></span>
<span><span class="co">##     model = op_cov_ns_est, parallel = TRUE)</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## No fixed effects.</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##         Estimate Std.error z-value</span></span>
<span><span class="co">## alpha    1.89706   0.06386  29.705</span></span>
<span><span class="co">## Theta 1 -0.29625   0.15621  -1.897</span></span>
<span><span class="co">## Theta 2  0.90944   0.23431   3.881</span></span>
<span><span class="co">## Theta 3  1.90932   0.40437   4.722</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev  0.10194   0.05288   1.928</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -89.47917 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 93</span></span>
<span><span class="co">## Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  11.11663 secs </span></span>
<span><span class="co">##   set up the parallelization = 2.59349 secs</span></span></code></pre>
<p>Let us now compare with the true values:</p>
<div class="sourceCode" id="cb88"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  theta1 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">true_theta</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>, <span class="va">fit_ns</span><span class="op">$</span><span class="va">coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>, </span>
<span>  theta2 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">true_theta</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>, <span class="va">fit_ns</span><span class="op">$</span><span class="va">coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  theta3 <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">true_theta</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span>, <span class="va">fit_ns</span><span class="op">$</span><span class="va">coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span>, </span>
<span>  alpha <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">alpha</span>, <span class="va">fit_ns</span><span class="op">$</span><span class="va">coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  row.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Truth"</span>, <span class="st">"Estimates"</span><span class="op">)</span></span>
<span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##               theta1    theta2   theta3    alpha</span></span>
<span><span class="co">## Truth      0.0000000 1.0000000 1.000000 1.800000</span></span>
<span><span class="co">## Estimates -0.2962479 0.9094445 1.909317 1.897063</span></span></code></pre>
</div>
</div>
<div class="section level2">
<h2 id="changing-the-type-and-the-order-of-the-rational-approximation">Changing the type and the order of the rational approximation<a class="anchor" aria-label="anchor" href="#changing-the-type-and-the-order-of-the-rational-approximation"></a>
</h2>
<p>We have three rational approximations available. The BRASIL algorithm
<a href="https://doi.org/10.1007/s11075-020-01042-0" class="external-link"><span class="citation">Hofreither (2021)</span></a>, and two “versions” of the
Clenshaw-Lord Chebyshev-Pade algorithm, one with lower bound zero and
another with the lower bound given in <a href="https://doi.org/10.1080/10618600.2023.2231051" class="external-link"><span class="citation">Bolin, Simas, and Xiong (2023)</span></a>.</p>
<p>The type of rational approximation can be chosen by setting the
<code>type_rational_approximation</code> argument in the
<code>matern.operators</code> function. The BRASIL algorithm corresponds
to the choice <code>brasil</code>, the Clenshaw-Lord Chebyshev pade with
zero lower bound and non-zero lower bounds are given, respectively, by
the choices <code>chebfun</code> and <code>chebfunLB</code>.</p>
<p>For instance, we can create an <code>rSPDE</code> object with a
<code>chebfunLB</code> rational approximation by</p>
<div class="sourceCode" id="cb90"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">op_cov_2d_type</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>  mesh <span class="op">=</span> <span class="va">mesh_2d</span>,</span>
<span>  m <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  type_rational_approximation <span class="op">=</span> <span class="st">"chebfunLB"</span></span>
<span><span class="op">)</span></span>
<span><span class="va">tau</span> <span class="op">&lt;-</span> <span class="va">op_cov_2d_type</span><span class="op">$</span><span class="va">tau</span></span></code></pre></div>
<p>We can check the order of the rational approximation with the
<code><a href="../reference/rational.order.html">rational.order()</a></code> function and assign a new order with the
<code>rational.order&lt;-()</code> function:</p>
<div class="sourceCode" id="cb91"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rational.order.html">rational.order</a></span><span class="op">(</span><span class="va">op_cov_2d_type</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 2</span></span></code></pre>
<div class="sourceCode" id="cb93"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rational.order.html">rational.order</a></span><span class="op">(</span><span class="va">op_cov_2d_type</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fl">1</span></span></code></pre></div>
<p>Let us fit a model using the data from the previous example:</p>
<div class="sourceCode" id="cb94"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit_order1</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rspde_lme.html">rspde_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="op">-</span><span class="fl">1</span>, model <span class="op">=</span> <span class="va">op_cov_2d_type</span>, </span>
<span>          data <span class="op">=</span> <span class="va">df_data_2d</span>,repl <span class="op">=</span> <span class="va">repl</span>,</span>
<span>          loc <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"x_coord"</span>, <span class="st">"y_coord"</span><span class="op">)</span>, parallel <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb95"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fit_order1</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Whittle-Matern</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rspde_lme(formula = y ~ -1, loc = c("x_coord", "y_coord"), data = df_data_2d, </span></span>
<span><span class="co">##     model = op_cov_2d_type, repl = repl, parallel = TRUE)</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## No fixed effects.</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## alpha  1.51696   0.04769  31.807</span></span>
<span><span class="co">## tau    0.07206   0.01281   5.626</span></span>
<span><span class="co">## kappa 13.98082   0.75501  18.517</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects (Matern parameterization):</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## nu    0.516958  0.047693   10.84</span></span>
<span><span class="co">## sigma 1.392506  0.014772   94.27</span></span>
<span><span class="co">## range 0.145459  0.004507   32.27</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##           Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev 0.1003733 0.0008786   114.2</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -5658.37 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 30</span></span>
<span><span class="co">## Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  33.40777 secs </span></span>
<span><span class="co">##   set up the parallelization = 4.91648 secs</span></span></code></pre>
<p>Let us compare with the true values:</p>
<div class="sourceCode" id="cb99"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  sigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="va">fit_order1</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>, </span>
<span>  range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">range</span>, <span class="va">fit_order1</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  nu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">nu</span>, <span class="va">fit_order1</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  row.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Truth"</span>, <span class="st">"Estimates"</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##              sigma     range        nu</span></span>
<span><span class="co">## Truth     1.300000 0.1500000 0.8000000</span></span>
<span><span class="co">## Estimates 1.392506 0.1454587 0.5169575</span></span></code></pre>
<p>Finally, we can check the type of rational approximation with the
<code><a href="../reference/rational.type.html">rational.type()</a></code> function and assign a new type by using the
<code>rational.type&lt;-()</code> function:</p>
<div class="sourceCode" id="cb101"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rational.type.html">rational.type</a></span><span class="op">(</span><span class="va">op_cov_2d_type</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] "chebfunLB"</span></span></code></pre>
<div class="sourceCode" id="cb103"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rational.type.html">rational.type</a></span><span class="op">(</span><span class="va">op_cov_2d_type</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="st">"brasil"</span></span></code></pre></div>
<p>Let us now fit this model, with the data from the previous example,
with <code>brasil</code> rational approximation:</p>
<div class="sourceCode" id="cb104"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit_brasil</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rspde_lme.html">rspde_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="op">-</span><span class="fl">1</span>, model <span class="op">=</span> <span class="va">op_cov_2d_type</span>, </span>
<span>          data <span class="op">=</span> <span class="va">df_data_2d</span>,repl <span class="op">=</span> <span class="va">repl</span>,</span>
<span>          loc <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"x_coord"</span>, <span class="st">"y_coord"</span><span class="op">)</span>, parallel <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## Warning in rspde_lme(y ~ -1, model = op_cov_2d_type, data = df_data_2d, : The</span></span>
<span><span class="co">## optimization failed to provide a numerically positive-definite Hessian. You can</span></span>
<span><span class="co">## try to obtain a positive-definite Hessian by setting 'improve_hessian' to TRUE</span></span>
<span><span class="co">## or by setting 'parallel' to FALSE, which allows other optimization methods to</span></span>
<span><span class="co">## be used.</span></span></code></pre>
<pre><code><span><span class="co">## Warning in sqrt(diag(inv_fisher)): NaNs produced</span></span></code></pre>
<div class="sourceCode" id="cb107"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fit_brasil</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Latent model - Whittle-Matern</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Call:</span></span>
<span><span class="co">## rspde_lme(formula = y ~ -1, loc = c("x_coord", "y_coord"), data = df_data_2d, </span></span>
<span><span class="co">##     model = op_cov_2d_type, repl = repl, parallel = TRUE)</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## No fixed effects.</span></span></code></pre>
<pre><code><span><span class="co">## </span></span>
<span><span class="co">## Random effects:</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## alpha  1.49502       NaN     NaN</span></span>
<span><span class="co">## tau    0.08003       NaN     NaN</span></span>
<span><span class="co">## kappa 13.61506       NaN     NaN</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Random effects (Matern parameterization):</span></span>
<span><span class="co">##       Estimate Std.error z-value</span></span>
<span><span class="co">## nu    0.495016       NaN     NaN</span></span>
<span><span class="co">## sigma 1.375559  0.014745   93.29</span></span>
<span><span class="co">## range 0.146162  0.004105   35.61</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Measurement error:</span></span>
<span><span class="co">##          Estimate Std.error z-value</span></span>
<span><span class="co">## std. dev 0.100338  0.000878   114.3</span></span>
<span><span class="co">## ---</span></span>
<span><span class="co">## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Log-Likelihood:  -5658.827 </span></span>
<span><span class="co">## Number of function calls by 'optim' = 63</span></span>
<span><span class="co">## Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">## </span></span>
<span><span class="co">## Time used to:     fit the model =  1.0035 mins </span></span>
<span><span class="co">##   set up the parallelization = 5.02511 secs</span></span></code></pre>
<p>Let us compare with the true values:</p>
<div class="sourceCode" id="cb111"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  sigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="va">fit_brasil</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>, </span>
<span>  range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">range</span>, <span class="va">fit_brasil</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  nu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">nu</span>, <span class="va">fit_brasil</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  row.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Truth"</span>, <span class="st">"Estimates"</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##              sigma     range        nu</span></span>
<span><span class="co">## Truth     1.300000 0.1500000 0.8000000</span></span>
<span><span class="co">## Estimates 1.375559 0.1461621 0.4950159</span></span></code></pre>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-bolin19" class="csl-entry">
Bolin, David, and Kristin Kirchner. 2020. <span>“The Rational SPDE
Approach for Gaussian Random Fields with General Smoothness.”</span>
<em>Journal of Computational and Graphical Statistics</em> 29 (2):
274–85.
</div>
<div id="ref-xiong22" class="csl-entry">
Bolin, David, Alexandre B. Simas, and Zhen Xiong. 2023.
<span>“Covariance-Based Rational Approximations of Fractional SPDEs for
Computationally Efficient Bayesian Inference.”</span> <em>Journal of
Computational and Graphical Statistics</em>.
</div>
<div id="ref-Hofreither21" class="csl-entry">
Hofreither, Clemens. 2021. <span>“An Algorithm for Best Rational
Approximation Based on Barycentric Rational Interpolation.”</span>
<em>Numerical Algorithms</em> 88 (1): 365–88.
</div>
<div id="ref-lindgren11" class="csl-entry">
Lindgren, Finn, Håvard Rue, and Johan Lindström. 2011. <span>“An
Explicit Link Between Gaussian Fields and Gaussian Markov Random Fields:
The Stochastic Partial Differential Equation Approach.”</span>
<em>Journal of the Royal Statistical Society. Series B. Statistical
Methodology</em> 73 (4): 423–98.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by David Bolin, Alexandre Simas.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
