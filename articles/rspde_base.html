<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="rSPDE">
<title>Operator-based rational approximation • rSPDE</title>
<!-- favicons --><link rel="icon" type="image/png" sizes="16x16" href="../favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="../favicon-32x32.png">
<link rel="apple-touch-icon" type="image/png" sizes="180x180" href="../apple-touch-icon.png">
<link rel="apple-touch-icon" type="image/png" sizes="120x120" href="../apple-touch-icon-120x120.png">
<link rel="apple-touch-icon" type="image/png" sizes="76x76" href="../apple-touch-icon-76x76.png">
<link rel="apple-touch-icon" type="image/png" sizes="60x60" href="../apple-touch-icon-60x60.png">
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Roboto_Slab-0.4.9/font.css" rel="stylesheet">
<!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.11/clipboard.min.js" integrity="sha512-7O5pXpc0oCRrxk8RUfDYFgn0nO1t+jLuIOQdOMRp4APB7uZ4vSjspzp5y6YDtDs4VzUSTbWzBFZ/LKJhnyFOKw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Operator-based rational approximation">
<meta property="og:description" content="rSPDE">
<meta property="og:image" content="https://davidbolin.github.io/rSPDE/logo.png">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary" data-bs-theme="dark"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">rSPDE</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.3.3.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../articles/rSPDE.html">Get started</a>
</li>
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Functions</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-vignettes">Vignettes</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-vignettes">
    <a class="dropdown-item" href="../articles/rspde_inla.html">R-INLA implementation of the rational SPDE approach</a>
    <a class="dropdown-item" href="../articles/rspde_inlabru.html">inlabru implementation of the rational SPDE approach</a>
    <a class="dropdown-item" href="../articles/rspde_cov.html">Rational approximation with the rSPDE package</a>
    <a class="dropdown-item" href="../articles/rspde_base.html">Operator-based rational approximation</a>
    <a class="dropdown-item" href="../articles/intrinsic.html">Intrinsic models</a>
    <a class="dropdown-item" href="../articles/build_source.html">Building the rSPDE package from source on Mac and Linux</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/davidbolin/rSPDE/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
<li class="nav-item">
  <a class="external-link nav-link" href="https://twitter.com/jdavidbolin" aria-label="Twitter">
    <span class="fa fa-twitter"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="../logo.png" class="logo" alt=""><h1>Operator-based rational approximation</h1>
                        <h4 data-toc-skip class="author">David Bolin and
Alexandre B. Simas</h4>
            
            <h4 data-toc-skip class="date">Created: 2019-08-07. Last
modified: 2024-05-18.</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/davidbolin/rSPDE/blob/HEAD/vignettes/rspde_base.Rmd" class="external-link"><code>vignettes/rspde_base.Rmd</code></a></small>
      <div class="d-none name"><code>rspde_base.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>Several popular Gaussian random field models can be represented as
solutions to stochastic partial differential equations (SPDEs) of the
form <span class="math display">\[
L^{\beta} (\tau u) = \mathcal{W}.
\]</span></p>
<p>Here <span class="math inline">\(\mathcal{W}\)</span> is Gaussian
white noise, <span class="math inline">\(L\)</span> is a second-order
differential operator, the fractional power <span class="math inline">\(\beta&gt;0\)</span> determines the smoothness of
<span class="math inline">\(u\)</span>, and <span class="math inline">\(\tau&gt;0\)</span> scales the variance of <span class="math inline">\(u\)</span>.</p>
<p>If <span class="math inline">\(2\beta\)</span> is an integer and if
the domain <span class="math inline">\(\mathcal{D}\)</span> where the
model is defined is bounded, then <span class="math inline">\(u\)</span>
can be approximated by a Gaussian Markov random field (GMRF) <span class="math inline">\(\boldsymbol{\mathrm{u}}\)</span> via a finite
element method (FEM) for the SPDE. Specifically, the approximation can
be written as <span class="math display">\[
u_h(s) = \sum_{i=1}^n u_i \varphi_i(s).
\]</span> Here <span class="math inline">\(\{\varphi_i\}\)</span> are
piecewise linear basis functions defined by some triangulation of <span class="math inline">\(\mathcal{D}\)</span> and the vector of weights
<span class="math inline">\(\boldsymbol{\mathrm{u}} =
(u_1,\ldots,u_n)^T\)</span> is normally distributed, <span class="math inline">\(N(\boldsymbol{\mathrm{u}},\tilde{\boldsymbol{\mathrm{Q}}}^{-1})\)</span>,
where <span class="math inline">\(\tilde{\boldsymbol{\mathrm{Q}}}\)</span> is
sparse. See <a href="https://rss.onlinelibrary.wiley.com/doi/full/10.1111/j.1467-9868.2011.00777.x" class="external-link"><span class="citation">Lindgren, Rue, and Lindström (2011)</span></a> for
further details.</p>
<p>In this vignette we focus on the operator-based rational
approximation. This approach, introduced by <a href="https://www.tandfonline.com/doi/full/10.1080/10618600.2019.1665537" class="external-link"><span class="citation">Bolin and Kirchner (2020)</span></a>, results in an
approximation of the original SPDE which is of the form <span class="math inline">\(P_l x = P_r \mathcal{W}\)</span>, where <span class="math inline">\(P_l\)</span> and <span class="math inline">\(P_r\)</span> are non-fractional operators defined
in terms of polynomials <span class="math inline">\(p_l\)</span> and
<span class="math inline">\(p_r\)</span>. The order of <span class="math inline">\(p_r\)</span> is given by <span class="math inline">\(m\)</span> and the order of <span class="math inline">\(p_l\)</span> is <span class="math inline">\(m +
m_{\beta}\)</span> where <span class="math inline">\(m_{\beta}\)</span>
is the integer part of <span class="math inline">\(\beta\)</span> if
<span class="math inline">\(\beta&gt;1\)</span> and <span class="math inline">\(m_{\beta} = 1\)</span> otherwise.</p>
<p>The combination of the rational approximation of the operator with
the FEM discretization yields an approximation <span class="math inline">\(u_h\)</span> of <span class="math inline">\(u\)</span> on the basis expansion form above. The
difference to the non-fractional case is that the vector of stochastic
weights now is <span class="math inline">\(\boldsymbol{\mathrm{u}} \sim
N(\boldsymbol{\mathrm{0}},\boldsymbol{\mathrm{P}}_r\boldsymbol{\mathrm{Q}}^{-1}\boldsymbol{\mathrm{P}}_r^T)\)</span>
where <span class="math inline">\(\boldsymbol{\mathrm{Q}}\)</span> and
<span class="math inline">\(\boldsymbol{\mathrm{P}}_r\)</span> are
sparse matrices. Alternatively, <span class="math inline">\(\boldsymbol{\mathrm{u}}\)</span> can be
represented as <span class="math inline">\(\boldsymbol{\mathrm{u}} =
\boldsymbol{\mathrm{P}}_r \boldsymbol{\mathrm{x}}\)</span> where <span class="math inline">\(\boldsymbol{\mathrm{x}} \sim
N(\boldsymbol{\mathrm{0}},\boldsymbol{\mathrm{Q}}^{-1})\)</span>, which
means that the discrete approximation is a latent GMRF. This can be used
for computationally efficient inference and simulation. See <a href="https://www.tandfonline.com/doi/full/10.1080/10618600.2019.1665537" class="external-link">Bolin
and Kirchner (2020)</a> for further details.</p>
</div>
<div class="section level2">
<h2 id="using-the-package-to-perform-operator-based-rational-approximations">Using the package to perform operator-based rational
approximations<a class="anchor" aria-label="anchor" href="#using-the-package-to-perform-operator-based-rational-approximations"></a>
</h2>
<p>The main purpose of the <code>rSPDE</code> package is to provide
functions for creating the rational approximation. In this vignette we
focus on the operator-based rational approximation, which means
assembling the matrices <span class="math inline">\(\boldsymbol{\mathrm{Q}}\)</span> and <span class="math inline">\(\boldsymbol{\mathrm{P}}_r\)</span>. There are
three functions for computing the rational approximation. The most
general function is <code><a href="../reference/fractional.operators.html">fractional.operators()</a></code>, which works for
a wide class of models with a general differential operator <span class="math inline">\(L\)</span>. For the stationary Matérn case, where
<span class="math inline">\(L = \kappa^2 - \Delta\)</span>, the function
<code><a href="../reference/matern.operators.html">matern.operators()</a></code> provides a simplified model
specification. For the generalized non-stationary Matérn model, defined
through the SPDE <span class="math display">\[
(\kappa(s)^2 - \Delta)^\beta (\tau(s)u(s)) = \mathcal{W},
\]</span> the function <code><a href="../reference/spde.matern.operators.html">spde.matern.operators()</a></code> can be
used.</p>
<p>For the alternative covariance-based rational approximation, we refer
the reader to the <a href="rspde_cov.html">Rational approximation with
the rSPDE package</a> vignette. It is worth noting that the
covariance-based rational approximation only applies to fractional SPDE
models with Gaussian noise, whereas the operator-based rational
approximation can be used for more general models such as the models
driven by type-G Lévy noise considered in <a href="https://onlinelibrary.wiley.com/doi/full/10.1111/sjos.12141" class="external-link"><span class="citation">Wallin and Bolin (2015)</span></a>, <a href="https://onlinelibrary.wiley.com/doi/abs/10.1111/sjos.12046" class="external-link"><span class="citation">Bolin (2013)</span></a>, and <a href="https://rss.onlinelibrary.wiley.com/doi/pdf/10.1111/rssc.12405" class="external-link"><span class="citation">Asar et al. (2020)</span></a>.</p>
<p>Once the approximation has been constructed, it can be included
manually in statistical models just as for the non-fractional case. The
package has some built-in functions for basic use of the approximation,
such as <code><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate()</a></code> which can be applied for simulation of
the field. There are also functions for likelihood evaluation and
kriging prediction for geostatistical models with Gaussian measurement
noise. In the following sections, we illustrate the usage of these
functions.</p>
<div class="section level3">
<h3 id="constructing-the-approximation">Constructing the approximation<a class="anchor" aria-label="anchor" href="#constructing-the-approximation"></a>
</h3>
<p>In this section, we explain how the different main functions can be
used for constructing the rational approximation. The first step for
constructing the rational SPDE approximation is to define the FEM mesh.
In this section, we use the simple FEM implementation in the
<code>rSPDE</code> package for models defined on an interval.</p>
<p>Assume that we want to define a model on the interval <span class="math inline">\([0,1]\)</span>. We then start by defining a vector
with mesh nodes <span class="math inline">\(s_i\)</span> where the basis
functions <span class="math inline">\(\varphi_i\)</span> are
centered.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">s</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">0</span>, to <span class="op">=</span> <span class="fl">1</span>, length.out <span class="op">=</span> <span class="fl">101</span><span class="op">)</span></span></code></pre></div>
<p>Based on these nodes, we use (implicitly) the built-in function
<code><a href="../reference/rSPDE.fem1d.html">rSPDE.fem1d()</a></code> to assemble two matrices needed for creating
the approximation of a basic Matérn model. These matrices are the mass
matrix <span class="math inline">\(\boldsymbol{\mathrm{C}}\)</span>,
with elements <span class="math inline">\(C_{ij} = \int \varphi_j(s)
\varphi_i(s) ds\)</span>, and the stiffness matrix <span class="math inline">\(\boldsymbol{\mathrm{G}}\)</span>, with elements
<span class="math inline">\(G_{ij} = \int \nabla\varphi_j(s) \cdot
\nabla\varphi_i(s) ds\)</span>.</p>
<p>We can now use <code><a href="../reference/matern.operators.html">matern.operators()</a></code> to construct a
rational SPDE approximation of degree <span class="math inline">\(m=1\)</span> for a Gaussian random field with a
Matérn covariance function on the interval. Since we are using the
operator-based approximation, we must set <code>type</code> to
<code>"operator"</code>.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">kappa</span> <span class="op">&lt;-</span> <span class="fl">20</span></span>
<span><span class="va">sigma</span> <span class="op">&lt;-</span> <span class="fl">2</span></span>
<span><span class="va">nu</span> <span class="op">&lt;-</span> <span class="fl">0.8</span></span>
<span><span class="va">r</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">sqrt</a></span><span class="op">(</span><span class="fl">8</span><span class="op">*</span><span class="va">nu</span><span class="op">)</span><span class="op">/</span><span class="va">kappa</span></span>
<span><span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span> sigma <span class="op">=</span> <span class="va">sigma</span>, </span>
<span>  range <span class="op">=</span> <span class="va">r</span>,</span>
<span>  nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>  loc_mesh <span class="op">=</span> <span class="va">s</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"operator"</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>The object <code>op</code> contains the matrices needed for
evaluating the distribution of the stochastic weights <span class="math inline">\(\boldsymbol{\mathrm{u}}\)</span>. If we want to
evaluate <span class="math inline">\(u_h(s)\)</span> at some locations
<span class="math inline">\(s_1,\ldots, s_n\)</span>, we need to
multiply the weights with the basis functions <span class="math inline">\(\varphi_i(s)\)</span> evaluated at the locations.
For this, we can construct the observation matrix <span class="math inline">\(\boldsymbol{\mathrm{A}}\)</span> with elements
<span class="math inline">\(A_{ij} = \varphi_j(s_i)\)</span>, which
links the FEM basis functions to the locations. This matrix can be
constructed using the function <code><a href="../reference/rSPDE.A1d.html">rSPDE.A1d()</a></code>.</p>
<p>To evaluate the accuracy of the approximation, let us compute the
covariance function between the process at <span class="math inline">\(s=0.5\)</span> and all other locations in
<code>s</code> and compare with the true covariance function, which is
the folded Matérn covariance, see Theorem 1 in <a href="https://www.jstor.org/stable/41262260" class="external-link">An explicit link between
Gaussian fields and Gaussian Markov random fields: the stochastic
partial differential equation approach</a>. The covariances can be
calculated as <span class="math display">\[
\boldsymbol{\mathrm{A}} \boldsymbol{\mathrm{P}}_r
\boldsymbol{\mathrm{Q}}^{-1}\boldsymbol{\mathrm{P}}_r^T\boldsymbol{\mathrm{v}}.
\]</span> Here <span class="math inline">\(\boldsymbol{\mathrm{A}}\)</span> is an identity
matrix since we are evaluating the approximation in the nodes of the FEM
mesh and <span class="math inline">\(\boldsymbol{\mathrm{v}}\)</span> is
a vector with all basis functions evaluated in <span class="math inline">\(s=0.5\)</span>. This way of computing the
covariance is obtained by setting <code>direct = TRUE</code> in the
<code>cov_function_mesh()</code> function inside the <code>op</code>
object:</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">c.approx</span> <span class="op">&lt;-</span> <span class="va">op</span><span class="op">$</span><span class="fu">cov_function_mesh</span><span class="op">(</span><span class="fl">0.5</span>, direct <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">c.true</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/folded.matern.covariance.1d.html">folded.matern.covariance.1d</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0.5</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">s</span><span class="op">)</span><span class="op">)</span>,</span>
<span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html" class="external-link">abs</a></span><span class="op">(</span><span class="va">s</span><span class="op">)</span>, <span class="va">kappa</span>, <span class="va">nu</span>, <span class="va">sigma</span><span class="op">)</span></span></code></pre></div>
<p>The covariance function and the error compared with the Matérn
covariance are shown in the following figure.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">opar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span></span>
<span>  mfrow <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, mgp <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1.3</span>, <span class="fl">0.5</span>, <span class="fl">0</span><span class="op">)</span>,</span>
<span>  mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">)</span> <span class="op">+</span> <span class="fl">0.1</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c.true</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"l"</span>, ylab <span class="op">=</span> <span class="st">"C(|s-0.5|)"</span>, xlab <span class="op">=</span> <span class="st">"s"</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">5</span><span class="op">)</span>,</span>
<span>  cex.main <span class="op">=</span> <span class="fl">0.8</span>, cex.axis <span class="op">=</span> <span class="fl">0.8</span>, cex.lab <span class="op">=</span> <span class="fl">0.8</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c.approx</span>, col <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">"topright"</span>,</span>
<span>  bty <span class="op">=</span> <span class="st">"n"</span>,</span>
<span>  legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Matérn"</span>, <span class="st">"m=1 rSPDE"</span><span class="op">)</span>,</span>
<span>  col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"black"</span>, <span class="st">"red"</span><span class="op">)</span>,</span>
<span>  lty <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  cex <span class="op">=</span> <span class="fl">0.8</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c.true</span> <span class="op">-</span> <span class="va">c.approx</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"l"</span>, ylab <span class="op">=</span> <span class="st">"Error"</span>, xlab <span class="op">=</span> <span class="st">"s"</span>,</span>
<span>  cex.main <span class="op">=</span> <span class="fl">0.8</span>, cex.axis <span class="op">=</span> <span class="fl">0.8</span>, cex.lab <span class="op">=</span> <span class="fl">0.8</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span><span class="va">opar</span><span class="op">)</span></span></code></pre></div>
<p><img src="rspde_base_files/figure-html/unnamed-chunk-4-1.png" width="700" style="display: block; margin: auto;"></p>
<p>To improve the approximation we can increase the degree of the
polynomials, by increasing <span class="math inline">\(m\)</span>,
and/or increase the number of basis functions used for the FEM
approximation. Let us, as an example, compute the approximation with
<span class="math inline">\(m=2\)</span> using the same mesh, as well as
the approximation when we increase the number of basis functions and use
<span class="math inline">\(m=1\)</span> and <span class="math inline">\(m=2\)</span>. We will also load the
<code>fmesher</code> package to use the <code><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis()</a></code> and
<code><a href="https://inlabru-org.github.io/fmesher/reference/fm_mesh_1d.html" class="external-link">fm_mesh_1d()</a></code> functions to map between the meshes.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://inlabru-org.github.io/fmesher/" class="external-link">fmesher</a></span><span class="op">)</span></span>
<span></span>
<span><span class="va">op2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>  range <span class="op">=</span> <span class="va">r</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>  loc_mesh <span class="op">=</span> <span class="va">s</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"operator"</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span><span class="op">)</span></span>
<span><span class="va">c.approx2</span> <span class="op">&lt;-</span> <span class="va">op2</span><span class="op">$</span><span class="fu">cov_function_mesh</span><span class="op">(</span><span class="fl">0.5</span>, direct <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="va">s2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">0</span>, to <span class="op">=</span> <span class="fl">1</span>, length.out <span class="op">=</span> <span class="fl">501</span><span class="op">)</span></span>
<span><span class="va">fem2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rSPDE.fem1d.html">rSPDE.fem1d</a></span><span class="op">(</span><span class="va">s2</span><span class="op">)</span></span>
<span><span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>  range <span class="op">=</span> <span class="va">r</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>  loc_mesh <span class="op">=</span> <span class="va">s2</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"operator"</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="va">mesh_s2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_mesh_1d.html" class="external-link">fm_mesh_1d</a></span><span class="op">(</span><span class="va">s2</span><span class="op">)</span></span>
<span></span>
<span><span class="va">A</span>  <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis</a></span><span class="op">(</span><span class="va">mesh_s2</span>, <span class="va">s</span><span class="op">)</span></span>
<span><span class="va">c.approx3</span> <span class="op">&lt;-</span> <span class="va">A</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">op</span><span class="op">$</span><span class="fu">cov_function_mesh</span><span class="op">(</span><span class="fl">0.5</span>, direct <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>  range <span class="op">=</span> <span class="va">r</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>  loc_mesh <span class="op">=</span> <span class="va">s2</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="fl">2</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"operator"</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span><span class="op">)</span></span>
<span><span class="va">c.approx4</span> <span class="op">&lt;-</span> <span class="va">A</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">op</span><span class="op">$</span><span class="fu">cov_function_mesh</span><span class="op">(</span><span class="fl">0.5</span>, direct <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>The resulting errors are shown in the following figure.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">opar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mgp <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1.3</span>, <span class="fl">0.5</span>, <span class="fl">0</span><span class="op">)</span>, mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">)</span> <span class="op">+</span> <span class="fl">0.1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c.true</span> <span class="op">-</span> <span class="va">c.approx</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"l"</span>, ylab <span class="op">=</span> <span class="st">"Error"</span>, xlab <span class="op">=</span> <span class="st">"s"</span>, col <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  cex.main <span class="op">=</span> <span class="fl">0.8</span>, cex.axis <span class="op">=</span> <span class="fl">0.8</span>, cex.lab <span class="op">=</span> <span class="fl">0.8</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c.true</span> <span class="op">-</span> <span class="va">c.approx2</span>, col <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c.true</span> <span class="op">-</span> <span class="va">c.approx3</span>, col <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">c.true</span> <span class="op">-</span> <span class="va">c.approx4</span>, col <span class="op">=</span> <span class="fl">4</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/legend.html" class="external-link">legend</a></span><span class="op">(</span><span class="st">"bottomright"</span>,</span>
<span>  bty <span class="op">=</span> <span class="st">"n"</span>,</span>
<span>  legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"m=1 coarse mesh"</span>, <span class="st">"m=2 coarse mesh"</span>,</span>
<span>  <span class="st">"m=1 fine mesh"</span>, <span class="st">"m=2 fine mesh"</span><span class="op">)</span>,</span>
<span>  col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span>, <span class="fl">3</span>, <span class="fl">4</span><span class="op">)</span>,</span>
<span>  lty <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span>, <span class="fl">2</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="fl">1</span>,</span>
<span>  cex <span class="op">=</span> <span class="fl">0.8</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span><span class="va">opar</span><span class="op">)</span></span></code></pre></div>
<p><img src="rspde_base_files/figure-html/unnamed-chunk-6-1.png" width="700" style="display: block; margin: auto;"></p>
<p>Since the error induced by the rational approximation decreases
exponentially in <span class="math inline">\(m\)</span>, there is rarely
a need for an approximation with a large value of <span class="math inline">\(m\)</span>. This is good because the number of
non-zero elements in <span class="math inline">\(\boldsymbol{\mathrm{P}}_r\)</span> and <span class="math inline">\(\boldsymbol{\mathrm{Q}}\)</span> increases with
<span class="math inline">\(m\)</span>, which makes the approximation
more computationally costly to use. Further, the condition numbers of
<span class="math inline">\(\boldsymbol{\mathrm{P}}_r\)</span> and <span class="math inline">\(\boldsymbol{\mathrm{Q}}\)</span> increase with
<span class="math inline">\(m\)</span>, which can cause numerical
problems when working with these matrices. To illustrate this, let us
compute the norm of the approximation error for different <span class="math inline">\(m\)</span>.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Mapping s2 to s</span></span>
<span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis</a></span><span class="op">(</span><span class="va">mesh_s2</span>, <span class="va">s</span><span class="op">)</span></span>
<span></span>
<span><span class="va">errors</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">4</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>    range <span class="op">=</span> <span class="va">r</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>    loc_mesh <span class="op">=</span> <span class="va">s2</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="va">i</span>,</span>
<span>    type <span class="op">=</span> <span class="st">"operator"</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">c.app</span> <span class="op">&lt;-</span> <span class="va">A</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">op</span><span class="op">$</span><span class="fu">cov_function_mesh</span><span class="op">(</span><span class="fl">0.5</span>, direct <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span>  <span class="va">errors</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/norm.html" class="external-link">norm</a></span><span class="op">(</span><span class="va">c.true</span> <span class="op">-</span> <span class="va">c.app</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1]   1.0113068   0.1100836 576.3166935  54.6482253</span></span></code></pre></div>
<p>We see that, when we used the direct method to compute the covariance
function, as described above, the error decreases when increasing <span class="math inline">\(m\)</span> from <span class="math inline">\(1\)</span> to <span class="math inline">\(2\)</span>, but is very large for <span class="math inline">\(m=3\)</span> and <span class="math inline">\(m=4\)</span>. The reason for this is not that the
approximation is bad, but that the numerical accuracy of the product
<span class="math inline">\(\boldsymbol{\mathrm{P}}_r\boldsymbol{\mathrm{Q}}^{-1}\boldsymbol{\mathrm{P}}_rv\)</span>
is low due to the large condition numbers of the matrices.</p>
<p>It is important to note that the alternative covariance-based
rational approximation is more numerically stable. The main reason for
this is that it relies on a decomposition of the field <span class="math inline">\(u\)</span> into a sum of random fields, which
removes the need of computing higher order finite element matrices for
large values of <span class="math inline">\(m\)</span>. See the <a href="rspde_cov.html">Rational approximation with the rSPDE package</a>
vignette for further details.</p>
<p>To handle this issue for the operator-based rational approximation,
the package contains functions for performing operations such as <span class="math inline">\(\boldsymbol{\mathrm{P}}_rv\)</span> or <span class="math inline">\(\boldsymbol{\mathrm{P}}_r^{-1}v\)</span> that
takes advantage of the structure of <span class="math inline">\(\boldsymbol{\mathrm{P}}_r\)</span> to avoid
numerical instabilities. A complete list of these function can be seen
by typing <code><a href="../reference/operator.operations.html">?operator.operations</a></code>. One of these functions is
<code><a href="../reference/operator.operations.html">Sigma.mult()</a></code>, which performs the multiplication <span class="math inline">\(\boldsymbol{\mathrm{P}}_r\boldsymbol{\mathrm{Q}}^{-1}\boldsymbol{\mathrm{P}}_rv\)</span>
in a more numerically stable way. Let us use this function to compute
the errors of the approximations again to see that we indeed get better
approximations as <span class="math inline">\(m\)</span> increases. This
is obtained by setting the <code>direct</code> argument in
<code>cov_function_mesh()</code> to <code>FALSE</code>:</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">errors2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">4</span><span class="op">)</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span></span>
<span>    range <span class="op">=</span> <span class="va">r</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>    loc_mesh <span class="op">=</span> <span class="va">s2</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="va">i</span>,</span>
<span>    type <span class="op">=</span> <span class="st">"operator"</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span>  <span class="op">)</span></span>
<span>  <span class="va">c.app</span> <span class="op">&lt;-</span> <span class="va">A</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">op</span><span class="op">$</span><span class="fu">cov_function_mesh</span><span class="op">(</span><span class="fl">0.5</span>, direct <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span>  <span class="va">errors2</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/norm.html" class="external-link">norm</a></span><span class="op">(</span><span class="va">c.true</span> <span class="op">-</span> <span class="va">c.app</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">errors2</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 1.01130750 0.10425661 0.02356591 0.01717388</span></span></code></pre></div>
</div>
</div>
<div class="section level2">
<h2 id="a-non-stationary-model">A non-stationary model<a class="anchor" aria-label="anchor" href="#a-non-stationary-model"></a>
</h2>
<p>Let us now examine a non-stationary model <span class="math inline">\((\kappa(s)^2 - \Delta)^\beta (\tau(s)u(s)) =
\mathcal{W}\)</span> with <span class="math inline">\(\kappa(s) =
10(1+2s^2)\)</span> and <span class="math inline">\(\tau(s) = 0.1(1 -
0.7s^2)\)</span>. We can then use <code><a href="../reference/spde.matern.operators.html">spde.matern.operators()</a></code>
to create the rational approximation with <span class="math inline">\(m=1\)</span> as follows.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">s</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">0</span>, to <span class="op">=</span> <span class="fl">1</span>, length.out <span class="op">=</span> <span class="fl">501</span><span class="op">)</span></span>
<span><span class="va">s_mesh</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_mesh_1d.html" class="external-link">fm_mesh_1d</a></span><span class="op">(</span><span class="va">s</span><span class="op">)</span></span>
<span></span>
<span><span class="va">kappa</span> <span class="op">&lt;-</span> <span class="fl">10</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1</span> <span class="op">+</span> <span class="fl">2</span> <span class="op">*</span> <span class="va">s</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">tau</span> <span class="op">&lt;-</span> <span class="fl">0.1</span> <span class="op">*</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="fl">0.7</span> <span class="op">*</span> <span class="va">s</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/spde.matern.operators.html">spde.matern.operators</a></span><span class="op">(</span></span>
<span>  kappa <span class="op">=</span> <span class="va">kappa</span>, tau <span class="op">=</span> <span class="va">tau</span>, nu <span class="op">=</span> <span class="va">nu</span>,</span>
<span>  d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="fl">1</span>, mesh <span class="op">=</span> <span class="va">s_mesh</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"operator"</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Let us compute the covariance function <span class="math inline">\(C(s,s_i)\)</span> of the non-stationary model for
the locations <span class="math inline">\(s_1=0.1, s_2 = 0.5,\)</span>
and <span class="math inline">\(s_3 = 0.9\)</span>.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">v</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html" class="external-link">t</a></span><span class="op">(</span><span class="va">op</span><span class="op">$</span><span class="fu">make_A</span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.5</span>, <span class="fl">0.9</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">covs</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/operator.operations.html">Sigma.mult</a></span><span class="op">(</span><span class="va">op</span>, <span class="va">v</span><span class="op">)</span></span></code></pre></div>
<p>The three covariances are shown in the following figure.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">opar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mgp <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1.3</span>, <span class="fl">0.5</span>, <span class="fl">0</span><span class="op">)</span>, mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">)</span> <span class="op">+</span> <span class="fl">0.1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">covs</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>,</span>
<span>  type <span class="op">=</span> <span class="st">"l"</span>, ylab <span class="op">=</span> <span class="st">"C(s,s_i)"</span>, xlab <span class="op">=</span> <span class="st">"s"</span>,</span>
<span>  cex.main <span class="op">=</span> <span class="fl">0.8</span>, cex.axis <span class="op">=</span> <span class="fl">0.8</span>, cex.lab <span class="op">=</span> <span class="fl">0.8</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">covs</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>, col <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">covs</span><span class="op">[</span>, <span class="fl">3</span><span class="op">]</span>, col <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span><span class="va">opar</span><span class="op">)</span></span></code></pre></div>
<p><img src="rspde_base_files/figure-html/unnamed-chunk-11-1.png" width="700" style="display: block; margin: auto;"></p>
<p>We see that this choice of <span class="math inline">\(\kappa(s)\)</span> and <span class="math inline">\(\tau(s)\)</span> results in a model with longer
range for small values of <span class="math inline">\(s\)</span> and
smaller variance in the middle of the domain. We can also apply the
general function <code><a href="../reference/fractional.operators.html">fractional.operators()</a></code> to construct the
approximation. This function requires that the user supplies a
discretization of the non-fractional operator <span class="math inline">\(L\)</span>, as well as a scaling factor <span class="math inline">\(c&gt;0\)</span> which is a lower bound for the
smallest eigenvalue of <span class="math inline">\(L\)</span>. In our
case we have <span class="math inline">\(L = \kappa(s)^2 -
\Delta\)</span>, and the eigenvalues of this operator is bounded from
below by <span class="math inline">\(c = \min_s \kappa(s)^2\)</span>. We
compute this constant and the discrete operator.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fem</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_fem.html" class="external-link">fm_fem</a></span><span class="op">(</span><span class="va">s_mesh</span><span class="op">)</span></span>
<span><span class="va">C</span> <span class="op">&lt;-</span> <span class="va">fem</span><span class="op">$</span><span class="va">c0</span></span>
<span><span class="va">G</span> <span class="op">&lt;-</span> <span class="va">fem</span><span class="op">$</span><span class="va">g1</span> </span>
<span></span>
<span><span class="va">c</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">kappa</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span></span>
<span><span class="va">L</span> <span class="op">&lt;-</span> <span class="va">G</span> <span class="op">+</span> <span class="va">C</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/Diagonal.html" class="external-link">Diagonal</a></span><span class="op">(</span><span class="fl">501</span>, <span class="va">kappa</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p>Another difference between <code><a href="../reference/fractional.operators.html">fractional.operators()</a></code> and
the previous functions for constructing the approximation, is that it
requires specifying <span class="math inline">\(\beta\)</span> instead
of the smoothness parameter <span class="math inline">\(\nu\)</span> for
the Matérn covariance. These two parameters are related as <span class="math inline">\(2\beta = \nu + d/2\)</span>.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fractional.operators.html">fractional.operators</a></span><span class="op">(</span></span>
<span>  L <span class="op">=</span> <span class="va">L</span>, beta <span class="op">=</span> <span class="op">(</span><span class="va">nu</span> <span class="op">+</span> <span class="fl">1</span> <span class="op">/</span> <span class="fl">2</span><span class="op">)</span> <span class="op">/</span> <span class="fl">2</span>, C <span class="op">=</span> <span class="va">C</span>,</span>
<span>  scale.factor <span class="op">=</span> <span class="va">c</span>, tau <span class="op">=</span> <span class="va">tau</span>, m <span class="op">=</span> <span class="fl">1</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Let’s make sure that we have the same approximation by comparing the
previously computed covariances.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">covs2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/operator.operations.html">Sigma.mult</a></span><span class="op">(</span><span class="va">op</span>, <span class="va">v</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/norm.html" class="external-link">norm</a></span><span class="op">(</span><span class="va">covs</span> <span class="op">-</span> <span class="va">covs2</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 0</span></span></code></pre></div>
<p>Obviously, it is simpler to use <code><a href="../reference/spde.matern.operators.html">spde.matern.operators()</a></code>
in this case, but the advantage with <code><a href="../reference/fractional.operators.html">fractional.operators()</a></code>
is that it also can be used for other more general models such as one
with <span class="math inline">\(L = \kappa(s)^2 - \nabla \cdot
(\boldsymbol{\mathrm{H}}(s) \nabla)\)</span> for some matrix-valued
function <span class="math inline">\(\boldsymbol{\mathrm{H}}(s)\)</span>.</p>
<div class="section level3">
<h3 id="using-the-approximation">Using the approximation<a class="anchor" aria-label="anchor" href="#using-the-approximation"></a>
</h3>
<p>For any approximation, constructed using the functions
<code><a href="../reference/fractional.operators.html">fractional.operators()</a></code>, <code><a href="../reference/matern.operators.html">matern.operators()</a></code>, or
<code><a href="../reference/spde.matern.operators.html">spde.matern.operators()</a></code>, we can simulate from the model
using <code><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate()</a></code>.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate</a></span><span class="op">(</span><span class="va">op</span><span class="op">)</span></span></code></pre></div>
<p>There is also built-in support for kriging prediction. To illustrate
this, we use the simulation to create some noisy observations of the
process. For this, we first construct the observation matrix linking the
FEM basis functions to the locations where we want to simulate. We first
randomly generate some observation locations and then construct the
matrix.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n.obs</span> <span class="op">&lt;-</span> <span class="fl">20</span></span>
<span><span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span>n <span class="op">=</span> <span class="va">n.obs</span>, min <span class="op">=</span> <span class="fl">0</span>, max <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis</a></span><span class="op">(</span><span class="va">s_mesh</span>, <span class="va">obs.loc</span><span class="op">)</span></span></code></pre></div>
<p>We now generate the observations as <span class="math inline">\(Y_i =
u(s_i) + \varepsilon_i\)</span>, where <span class="math inline">\(\varepsilon_i \sim N(0,\sigma_e^2)\)</span> is
Gaussian measurement noise.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sigma.e</span> <span class="op">&lt;-</span> <span class="fl">0.3</span></span>
<span><span class="va">Y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">A</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">u</span> <span class="op">+</span> <span class="va">sigma.e</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<p>Finally, we compute the kriging prediction of the process <span class="math inline">\(u\)</span> at the locations in <code>s</code>
based on these observations. To specify which locations that should be
predicted, the argument <code>Aprd</code> is used. This argument should
be an observation matrix that links the mesh locations to the prediction
locations.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">A.krig</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis</a></span><span class="op">(</span><span class="va">s_mesh</span>, <span class="va">s</span><span class="op">)</span></span>
<span><span class="va">u.krig</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html" class="external-link">predict</a></span><span class="op">(</span><span class="va">op</span>, A <span class="op">=</span> <span class="va">A</span>, Aprd <span class="op">=</span> <span class="va">A.krig</span>, Y <span class="op">=</span> <span class="va">Y</span>, sigma.e <span class="op">=</span> <span class="va">sigma.e</span><span class="op">)</span></span></code></pre></div>
<p>The process simulation, the observed data, and the kriging prediction
are shown in the following figure.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">opar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>mgp <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1.3</span>, <span class="fl">0.5</span>, <span class="fl">0</span><span class="op">)</span>, mar <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">2</span>, <span class="fl">0.5</span>, <span class="fl">0.5</span><span class="op">)</span> <span class="op">+</span> <span class="fl">0.1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">obs.loc</span>, <span class="va">Y</span>,</span>
<span>  ylab <span class="op">=</span> <span class="st">"u(s)"</span>, xlab <span class="op">=</span> <span class="st">"s"</span>,</span>
<span>  ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">u</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">min</a></span><span class="op">(</span><span class="va">Y</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">u</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html" class="external-link">max</a></span><span class="op">(</span><span class="va">Y</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  cex.main <span class="op">=</span> <span class="fl">0.8</span>, cex.axis <span class="op">=</span> <span class="fl">0.8</span>, cex.lab <span class="op">=</span> <span class="fl">0.8</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">u</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">u.krig</span><span class="op">$</span><span class="va">mean</span>, col <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span><span class="va">opar</span><span class="op">)</span></span></code></pre></div>
<p><img src="rspde_base_files/figure-html/unnamed-chunk-19-1.png" width="700" style="display: block; margin: auto;"></p>
</div>
</div>
<div class="section level2">
<h2 id="spatial-data-and-parameter-estimation">Spatial data and parameter estimation<a class="anchor" aria-label="anchor" href="#spatial-data-and-parameter-estimation"></a>
</h2>
<p>The functions used in the previous examples also work for spatial
models. We then need to construct a mesh over the domain of interest and
then compute the matrices needed to define the operator. These tasks can
be performed, for example, using the <code>fmesher</code> package. Let
us start by defining a mesh over <span class="math inline">\([0,1]\times
[0, 1]\)</span> and compute the mass and stiffness matrices for that
mesh.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://inlabru-org.github.io/fmesher/" class="external-link">fmesher</a></span><span class="op">)</span></span>
<span><span class="va">m</span> <span class="op">&lt;-</span> <span class="fl">200</span></span>
<span><span class="va">loc_2d_mesh</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html" class="external-link">runif</a></span><span class="op">(</span><span class="va">m</span> <span class="op">*</span> <span class="fl">2</span><span class="op">)</span>, <span class="va">m</span>, <span class="fl">2</span><span class="op">)</span></span>
<span><span class="va">mesh_2d</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_mesh_2d.html" class="external-link">fm_mesh_2d</a></span><span class="op">(</span></span>
<span>  loc <span class="op">=</span> <span class="va">loc_2d_mesh</span>,</span>
<span>  cutoff <span class="op">=</span> <span class="fl">0.05</span>,</span>
<span>  offset <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.1</span>, <span class="fl">0.4</span><span class="op">)</span>,</span>
<span>  max.edge <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0.05</span>, <span class="fl">0.5</span><span class="op">)</span></span>
<span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">mesh_2d</span>, main <span class="op">=</span> <span class="st">""</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span><span class="va">loc_2d_mesh</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>, <span class="va">loc_2d_mesh</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p><img src="rspde_base_files/figure-html/unnamed-chunk-20-1.png" width="700" style="display: block; margin: auto;">
We can now use these matrices to define a rational SPDE approximation of
degree <span class="math inline">\(m=1\)</span> for a Matérn model in
the same was as before. To illustrate this, we simulate a latent process
with standard deviation <span class="math inline">\(\sigma=1\)</span>
and range <span class="math inline">\(0.1\)</span>. We choose <span class="math inline">\(\nu=0.5\)</span> so that the model corresponds to
a Gaussian process with an exponential covariance function.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">nu</span> <span class="op">&lt;-</span> <span class="fl">0.8</span></span>
<span><span class="va">sigma</span> <span class="op">&lt;-</span> <span class="fl">1.3</span></span>
<span><span class="va">range</span> <span class="op">&lt;-</span> <span class="fl">0.15</span></span>
<span><span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span>range <span class="op">=</span> <span class="va">range</span>, sigma <span class="op">=</span> <span class="va">sigma</span>,</span>
<span>nu <span class="op">=</span> <span class="va">nu</span>, m <span class="op">=</span> <span class="fl">2</span>, mesh <span class="op">=</span> <span class="va">mesh_2d</span>,</span>
<span>  parameterization <span class="op">=</span> <span class="st">"matern"</span><span class="op">)</span></span></code></pre></div>
<p>Now let us simulate some noisy data that we will use to estimate the
parameters of the model. To construct the observation matrix, we use the
<code>fmesher</code> function <code><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis()</a></code>. We sample 30
replicates of the latent field.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">n.rep</span> <span class="op">&lt;-</span> <span class="fl">30</span></span>
<span><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/simulate.html" class="external-link">simulate</a></span><span class="op">(</span><span class="va">op</span>, nsim <span class="op">=</span> <span class="va">n.rep</span><span class="op">)</span></span>
<span><span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_basis.html" class="external-link">fm_basis</a></span><span class="op">(</span></span>
<span>  x <span class="op">=</span> <span class="va">mesh_2d</span>,</span>
<span>  loc <span class="op">=</span> <span class="va">loc_2d_mesh</span></span>
<span><span class="op">)</span></span>
<span><span class="va">sigma.e</span> <span class="op">&lt;-</span> <span class="fl">0.1</span></span>
<span><span class="va">Y</span> <span class="op">&lt;-</span> <span class="va">A</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">u</span> <span class="op">+</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html" class="external-link">rnorm</a></span><span class="op">(</span><span class="va">m</span> <span class="op">*</span> <span class="va">n.rep</span><span class="op">)</span>, ncol <span class="op">=</span> <span class="va">n.rep</span><span class="op">)</span> <span class="op">*</span> <span class="va">sigma.e</span></span></code></pre></div>
<p>The first replicate of the simulated random field as well as the
observation locations are shown in the following figure.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://sjmgarnier.github.io/viridis/" class="external-link">viridis</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://ggplot2.tidyverse.org" class="external-link">ggplot2</a></span><span class="op">)</span></span>
<span><span class="va">proj</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_evaluate.html" class="external-link">fm_evaluator</a></span><span class="op">(</span><span class="va">mesh_2d</span>, dims <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">70</span>, <span class="fl">70</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">df_field</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">proj</span><span class="op">$</span><span class="va">lattice</span><span class="op">$</span><span class="va">loc</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>,</span>
<span>                        y <span class="op">=</span> <span class="va">proj</span><span class="op">$</span><span class="va">lattice</span><span class="op">$</span><span class="va">loc</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span>,</span>
<span>                        field <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="fu"><a href="https://inlabru-org.github.io/fmesher/reference/fm_evaluate.html" class="external-link">fm_evaluate</a></span><span class="op">(</span><span class="va">proj</span>, </span>
<span>                        field <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">u</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>,</span>
<span>                        type <span class="op">=</span> <span class="st">"field"</span><span class="op">)</span></span>
<span></span>
<span><span class="va">df_loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">loc_2d_mesh</span><span class="op">[</span>, <span class="fl">1</span><span class="op">]</span>,</span>
<span>                      y <span class="op">=</span> <span class="va">loc_2d_mesh</span><span class="op">[</span>, <span class="fl">2</span><span class="op">]</span>,</span>
<span>                      field <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">Y</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>                      type <span class="op">=</span> <span class="st">"locations"</span><span class="op">)</span></span>
<span><span class="va">df_plot</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html" class="external-link">rbind</a></span><span class="op">(</span><span class="va">df_field</span>, <span class="va">df_loc</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://ggplot2.tidyverse.org/reference/ggplot.html" class="external-link">ggplot</a></span><span class="op">(</span><span class="va">df_plot</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">y</span>, fill <span class="op">=</span> <span class="va">field</span><span class="op">)</span> <span class="op">+</span></span>
<span>        <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/facet_wrap.html" class="external-link">facet_wrap</a></span><span class="op">(</span><span class="op">~</span><span class="va">type</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/lims.html" class="external-link">xlim</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/lims.html" class="external-link">ylim</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1</span><span class="op">)</span> <span class="op">+</span> </span>
<span>        <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_tile.html" class="external-link">geom_raster</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">df_field</span><span class="op">)</span> <span class="op">+</span></span>
<span>        <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/geom_point.html" class="external-link">geom_point</a></span><span class="op">(</span>data <span class="op">=</span> <span class="va">df_loc</span>, <span class="fu"><a href="https://ggplot2.tidyverse.org/reference/aes.html" class="external-link">aes</a></span><span class="op">(</span>colour <span class="op">=</span> <span class="va">field</span><span class="op">)</span>,</span>
<span>        show.legend <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span> <span class="op">+</span> </span>
<span>        <span class="fu"><a href="https://sjmgarnier.github.io/viridis/reference/scale_viridis.html" class="external-link">scale_fill_viridis</a></span><span class="op">(</span><span class="op">)</span> <span class="op">+</span> <span class="fu"><a href="https://sjmgarnier.github.io/viridis/reference/scale_viridis.html" class="external-link">scale_colour_viridis</a></span><span class="op">(</span><span class="op">)</span></span></code></pre></div>
<p><img src="rspde_base_files/figure-html/unnamed-chunk-23-1.png" width="700" style="display: block; margin: auto;"></p>
<p>For each type of rational approximation of degree <span class="math inline">\(m\)</span>, there is a corresponding likelihood
function that can be used for likelihood-based parameter estimation.
Since we constructed the model with
<code><a href="../reference/spde.matern.operators.html">spde.matern.operators()</a></code>, we can use the function
<code><a href="../reference/spde.matern.loglike.html">spde.matern.loglike()</a></code> to define the likelihood. To simplify
parameter estimation, we create an object containing the
<code>rSPDE</code> model (we are assigning the meaningless value 1 for
the parameters because they will not be used):</p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">op_obj</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span> m <span class="op">=</span> <span class="fl">1</span>,</span>
<span>    type <span class="op">=</span> <span class="st">"operator"</span>, mesh <span class="op">=</span> <span class="va">mesh_2d</span></span>
<span>  <span class="op">)</span></span></code></pre></div>
<p>Now, we set up a vector with the response variables and create an
auxiliary replicates vector, <code>repl</code>, that contains the
indexes of the replicates of each observation. Then, we build the
<code><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame()</a></code>, that also contanis the spatial locations, and
we fit the model:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">y_vec</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html" class="external-link">as.vector</a></span><span class="op">(</span><span class="va">Y</span><span class="op">)</span></span>
<span><span class="va">repl</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">n.rep</span>, each <span class="op">=</span> <span class="va">m</span><span class="op">)</span></span>
<span><span class="va">df_data_2d</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span>y <span class="op">=</span> <span class="va">y_vec</span>, x_coord <span class="op">=</span> <span class="va">loc_2d_mesh</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>,</span>
<span>                      y_coord <span class="op">=</span> <span class="va">loc_2d_mesh</span><span class="op">[</span>,<span class="fl">2</span><span class="op">]</span><span class="op">)</span></span></code></pre></div>
<p>We can now fit the model (and speed up by setting
<code>parallel</code> to <code>TRUE</code>):</p>
<div class="sourceCode" id="cb26"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit_2d</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rspde_lme.html">rspde_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="op">-</span><span class="fl">1</span>, model <span class="op">=</span> <span class="va">op_obj</span>, </span>
<span>          data <span class="op">=</span> <span class="va">df_data_2d</span>, repl <span class="op">=</span> <span class="va">repl</span>,</span>
<span>          loc <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"x_coord"</span>, <span class="st">"y_coord"</span><span class="op">)</span>, </span>
<span>          parallel <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Let us see a summary of the fitted model:</p>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fit_2d</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Latent model - Whittle-Matern</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; rspde_lme(formula = y ~ -1, loc = c("x_coord", "y_coord"), data = df_data_2d, </span></span>
<span><span class="co">#&gt;     model = op_obj, repl = repl, parallel = TRUE)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; No fixed effects.</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Random effects:</span></span>
<span><span class="co">#&gt;       Estimate Std.error z-value</span></span>
<span><span class="co">#&gt; alpha  1.92127   0.18485  10.394</span></span>
<span><span class="co">#&gt; tau    0.01593   0.01124   1.417</span></span>
<span><span class="co">#&gt; kappa 18.13699   1.95179   9.292</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Random effects (Matern parameterization):</span></span>
<span><span class="co">#&gt;       Estimate Std.error z-value</span></span>
<span><span class="co">#&gt; nu    0.921273  0.184850   4.984</span></span>
<span><span class="co">#&gt; sigma 1.277771  0.016117  79.281</span></span>
<span><span class="co">#&gt; range 0.149683  0.004527  33.065</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Measurement error:</span></span>
<span><span class="co">#&gt;          Estimate Std.error z-value</span></span>
<span><span class="co">#&gt; std. dev 0.100475  0.002503   40.14</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Log-Likelihood:  -5833.811 </span></span>
<span><span class="co">#&gt; Number of function calls by 'optim' = 57</span></span>
<span><span class="co">#&gt; Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Time used to:     fit the model =  1.08336 mins </span></span>
<span><span class="co">#&gt;   set up the parallelization = 2.92131 secs</span></span></code></pre></div>
<p>and glance:</p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/glance.rspde_lme.html">glance</a></span><span class="op">(</span><span class="va">fit_2d</span><span class="op">)</span></span>
<span><span class="co">#&gt; <span style="color: #949494;"># A tibble: 1 × 9</span></span></span>
<span><span class="co">#&gt;    nobs sigma logLik    AIC    BIC deviance df.residual model              alpha</span></span>
<span><span class="co">#&gt;   <span style="color: #949494; font-style: italic;">&lt;int&gt;</span> <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>  <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>    <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span>       <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span> <span style="color: #949494; font-style: italic;">&lt;chr&gt;</span>              <span style="color: #949494; font-style: italic;">&lt;dbl&gt;</span></span></span>
<span><span class="co">#&gt; <span style="color: #BCBCBC;">1</span>  <span style="text-decoration: underline;">6</span>000 0.100 -<span style="color: #BB0000; text-decoration: underline;">5</span><span style="color: #BB0000;">834.</span> <span style="text-decoration: underline;">11</span>676. <span style="text-decoration: underline;">11</span>702.   <span style="text-decoration: underline;">11</span>668.        <span style="text-decoration: underline;">5</span>996 Matern approximat…  1.92</span></span></code></pre></div>
<p>Let us compare the estimated results with the true values:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  sigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="va">fit_2d</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>, </span>
<span>  range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">range</span>, <span class="va">fit_2d</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  nu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">nu</span>, <span class="va">fit_2d</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  row.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Truth"</span>, <span class="st">"Estimates"</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;              sigma     range        nu</span></span>
<span><span class="co">#&gt; Truth     1.300000 0.1500000 0.8000000</span></span>
<span><span class="co">#&gt; Estimates 1.277771 0.1496835 0.9212731</span></span></code></pre></div>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="co"># Total time</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">fit_2d</span><span class="op">$</span><span class="va">fitting_time</span><span class="op">)</span></span>
<span><span class="co">#&gt; Time difference of 1.083363 mins</span></span></code></pre></div>
<p>Finally, we observe that we can use the <code><a href="../reference/rational.order.html">rational.order()</a></code>
function, to check the order of the rational approximation of the
<code>rSPDE</code> object, as well as to use the
<code>rational.order&lt;-()</code> function to assign new orders:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/rational.order.html">rational.order</a></span><span class="op">(</span><span class="va">op_obj</span><span class="op">)</span></span>
<span><span class="co">#&gt; [1] 1</span></span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="fu"><a href="../reference/rational.order.html">rational.order</a></span><span class="op">(</span><span class="va">op_obj</span><span class="op">)</span> <span class="op">&lt;-</span> <span class="fl">2</span></span></code></pre></div>
<p>Let us fit again and check the results:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">fit_2d</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rspde_lme.html">rspde_lme</a></span><span class="op">(</span><span class="va">y</span> <span class="op">~</span> <span class="op">-</span><span class="fl">1</span>, model <span class="op">=</span> <span class="va">op_obj</span>, </span>
<span>          data <span class="op">=</span> <span class="va">df_data_2d</span>, repl <span class="op">=</span> <span class="va">repl</span>,</span>
<span>          loc <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"x_coord"</span>, <span class="st">"y_coord"</span><span class="op">)</span>, </span>
<span>          parallel <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Let us check the summary:</p>
<div class="sourceCode" id="cb34"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">fit_2d</span><span class="op">)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Latent model - Whittle-Matern</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Call:</span></span>
<span><span class="co">#&gt; rspde_lme(formula = y ~ -1, loc = c("x_coord", "y_coord"), data = df_data_2d, </span></span>
<span><span class="co">#&gt;     model = op_obj, repl = repl, parallel = TRUE)</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; No fixed effects.</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Random effects:</span></span>
<span><span class="co">#&gt;       Estimate Std.error z-value</span></span>
<span><span class="co">#&gt; alpha  1.89739   0.20293   9.350</span></span>
<span><span class="co">#&gt; tau    0.01755   0.01389   1.263</span></span>
<span><span class="co">#&gt; kappa 17.81659   2.39822   7.429</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Random effects (Matern parameterization):</span></span>
<span><span class="co">#&gt;       Estimate Std.error z-value</span></span>
<span><span class="co">#&gt; nu    0.897389  0.202929   4.422</span></span>
<span><span class="co">#&gt; sigma 1.279915  0.016123  79.383</span></span>
<span><span class="co">#&gt; range 0.150387  0.004597  32.713</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Measurement error:</span></span>
<span><span class="co">#&gt;          Estimate Std.error z-value</span></span>
<span><span class="co">#&gt; std. dev 0.100441  0.002503   40.13</span></span>
<span><span class="co">#&gt; ---</span></span>
<span><span class="co">#&gt; Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1 </span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Log-Likelihood:  -5833.769 </span></span>
<span><span class="co">#&gt; Number of function calls by 'optim' = 66</span></span>
<span><span class="co">#&gt; Optimization method used in 'optim' = L-BFGS-B</span></span>
<span><span class="co">#&gt; </span></span>
<span><span class="co">#&gt; Time used to:     fit the model =  2.29829 mins </span></span>
<span><span class="co">#&gt;   set up the parallelization = 2.88958 secs</span></span></code></pre></div>
<p>Let us compare the estimated results with the true values:</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/data.frame.html" class="external-link">data.frame</a></span><span class="op">(</span></span>
<span>  sigma <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">sigma</span>, <span class="va">fit_2d</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>, </span>
<span>  range <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">range</span>, <span class="va">fit_2d</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  nu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">nu</span>, <span class="va">fit_2d</span><span class="op">$</span><span class="va">matern_coeff</span><span class="op">$</span><span class="va">random_effects</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>,</span>
<span>  row.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Truth"</span>, <span class="st">"Estimates"</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">)</span></span>
<span><span class="co">#&gt;              sigma     range        nu</span></span>
<span><span class="co">#&gt; Truth     1.300000 0.1500000 0.8000000</span></span>
<span><span class="co">#&gt; Estimates 1.279915 0.1503872 0.8973893</span></span></code></pre></div>
<div class="sourceCode" id="cb36"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span></span>
<span><span class="co"># Total time</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">fit_2d</span><span class="op">$</span><span class="va">fitting_time</span><span class="op">)</span></span>
<span><span class="co">#&gt; Time difference of 2.298297 mins</span></span></code></pre></div>
</div>
<div class="section level2 unnumbered">
<h2 class="unnumbered" id="references">References<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-asar20" class="csl-entry">
Asar, Özgür, David Bolin, Peter Diggle, and Jonas Wallin. 2020.
<span>“Linear Mixed Effects Models for Non‐Gaussian Repeated Measurement
Data.”</span> <em>Journal of the Royal Statistical Society. Series C.
Applied Statistics</em> 69 (5): 1015–65.
</div>
<div id="ref-bolin13" class="csl-entry">
Bolin, David. 2013. <span>“Spatial Matérn Fields Driven by Non-Gaussian
Noise.”</span> <em>Scandinavian Journal of Statistics</em> 41 (3):
557–79.
</div>
<div id="ref-bolin19" class="csl-entry">
Bolin, David, and Kristin Kirchner. 2020. <span>“The Rational SPDE
Approach for Gaussian Random Fields with General Smoothness.”</span>
<em>Journal of Computational and Graphical Statistics</em> 29 (2):
274–85.
</div>
<div id="ref-lindgren11" class="csl-entry">
Lindgren, Finn, Håvard Rue, and Johan Lindström. 2011. <span>“An
Explicit Link Between Gaussian Fields and Gaussian Markov Random Fields:
The Stochastic Partial Differential Equation Approach.”</span>
<em>Journal of the Royal Statistical Society. Series B. Statistical
Methodology</em> 73 (4): 423–98.
</div>
<div id="ref-wallin15" class="csl-entry">
Wallin, Jonas, and David Bolin. 2015. <span>“Geostatistical Modelling
Using Non-Gaussian Matérn Fields.”</span> <em>Scandinavian Journal of
Statistics</em> 42 (3): 872–90.
</div>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by David Bolin, Alexandre Simas.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.9.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
