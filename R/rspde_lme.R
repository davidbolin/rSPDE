#' rSPDE linear mixed effects models
#'
#' Fitting linear mixed effects model with latent Whittle-Matern models.
#'
#' @param formula Formula object describing the relation between the response variables and the fixed effects. If the response variable is a matrix, each column of the matrix will be treated as a replicate.
#' @param loc A vector with the names of the columns in `data` that contain the observation locations, or a `matrix` or a `data.frame` containing the observation locations. If the model is of class `metric_graph`, the locations must be either a `matrix` or a `data.frame` with two columns, or a character vector with the names of the two columns. The first column being the number of the edge, and the second column being the normalized position on the edge. If the model is a 2d model, `loc` must be either a `matrix` or `data.frame` with two columns or a character vector with the name of the two columns that contain the location, the first entry corresponding to the `x` entry and the second corresponding to the `y` entry. 
#' @param data A `data.frame` containing the data to be used.
#' @param model Either an object generated by `matern.operators()` or `spde.matern.operators()`. If `NULL`, a simple linear regression will be performed. 
#' @param repl Vector indicating the replicate of each observation. If `NULL` it will assume there is only one replicate.
#' @param optim_method The method to be used with `optim` function.
#' @param starting_values_latent A vector containing the starting values for the latent model. If the latent model was generated by `matern.operators()`, then the starting values should be provided as a vector of the form c(tau,kappa) or c(sigma,range) depending on the parameterization. If the model was generated by `spde.matern.operators()`, then the starting values should be provided as a vector containing the nonstationary parameters.
#' @param start_sigma_e Starting value for the standard deviation of the measurament error.
#' @param start_nu Starting value for the smoothness parameter.
#' @param nu If `NULL`, the smoothness parameter will be estimated, otherwise the smoothness parameter will be kept fixed at the provided value.
#' @param model_matrix logical indicating whether the model matrix should be returned as component of the returned value.
#' @param parallel logical. Indicating whether to use optimParallel or not.
#' @param n_cores Number of cores to be used if parallel is true.
#' @param optim_controls Additional controls to be passed to `optim` or `optimParallel`.
#' @param improve_hessian Should a more precise estimate of the hessian be obtained? Turning on might increase the overall time.
#' @param hessian_args List of controls to be used if `improve_hessian` is `TRUE`. The list can contain the arguments to be passed to the `method.args` argument in the `hessian` function. See the help of the `hessian` function in `numDeriv` package for details. Observet that it only accepts the "Richardson" method for now, the method "complex" is not supported. 
#' @return A list containing the fitted model.
#' @rdname rspde_lme
#' @export
#' 

rspde_lme <- function(formula, loc, data, 
                model = NULL, repl = NULL,
                optim_method = "L-BFGS-B", 
                starting_values_latent = NULL,
                start_sigma_e = NULL,
                start_nu = NULL,
                nu = NULL,
                rspde_order = NULL,
                model_matrix = TRUE,
                parallel = FALSE,
                n_cores = parallel::detectCores()-1,
                optim_controls = list(),
                improve_hessian = FALSE,
                hessian_controls = list()) {

   if(!is.null(model)){
    if(!inherits(model, c("CBrSPDEobj","rSPDEobj"))){
        stop("The model should be an object of class 'CBrSPDEobj' or 'rSPDEobj'.")
    }
   }

   estimate_nu <- TRUE

   if(!is.null(nu)){
    estimate_nu <- FALSE
   }

    if(is.null(rspde_order) && !is.null(model)){
        model <- update(model, user_m = rspde_order)
    }

  if (is.null(formula)) {
    stop("No formula provided!")
  }

  call_rspde_lme <- match.call()

  if (missing(data)) {
    data <- environment(formula)
  }

  y_term <- stats::terms(formula)[[2]]

  y_resp <- eval(y_term, envir = data, enclos = parent.frame())
  y_resp <- as.numeric(y_resp)

  cov_term <- stats::delete.response(terms(formula))

  X_cov <- stats::model.matrix(cov_term, data)

  if(all(dim(X_cov) == c(0,1))){
    names_temp <- colnames(X_cov)
    X_cov <- matrix(1, nrow = length(y_resp))
    colnames(X_cov) <- names_temp
  }

  if(!is.null(model)){
    if(is.null(starting_values_latent)){
      if(!model$stationary){
          if(is.null(model$theta)){
              stop("For models given by spde.matern.operators(), theta must be non-null!")
          }
          starting_values_latent <- model$theta
      } else{
          if(model$parameterization == "spde"){
              starting_values_latent <- log(c(model$tau, model$kappa))
          } else{
              starting_values_latent <- log(c(model$sigma, model$range))
          }
      }
    } else{
      if(model$stationary){
          if(length(starting_values_latent)!=2){
              stop("starting_values_latent must be a vector of length 2.")
          }
          if(any(starting_values_latent<0)){
            stop("For stationary models, the values of starting_values_latent must be positive.")
          }
      } else{
          if(length(starting_values_latent)!=ncol(model$B.tau)){
              stop("starting_values_latent must be a vector of the same length as the number of the covariates for the latent model.")
          }
      }
    }

    if(estimate_nu){
        start_values <- c(log(c(0.1*sd(y_resp), 1)),starting_values_latent)
    } else{
        start_values <- c(log(0.1*sd(y_resp)), starting_values_latent)
    }

    if(!is.null(start_sigma_e)){
        start_values[1] <- log(start_sigma_e)
    }

  if(is.null(repl)){
    repl <- rep(1, length(y_resp))
  }

  if(is.data.frame(loc)){
    loc_df <- loc
  } else if(is.character(loc)){
    if(!model$has_graph){
        dim <- model$d
        if(length(loc) != dim){
            stop("If 'loc' is a character vector, it must have the same length as the dimension (unless model comes from a metric graph).")
        }
        if(dim == 1){
            loc_df <- matrix(data[[loc[1]]], ncol=1)
        } else if (dim == 2){
            loc_df <- cbind(as.vector(data[[loc[1]]]), 
                                    as.vector(data[[loc[2]]]))
        }
    } else{
        if(length(loc)!=2){
            stop("For a metric graph, 'loc' must have length two.")
        }
            loc_df <- cbind(as.vector(data[[loc[1]]]), 
                                    as.vector(data[[loc[2]]]))
    }
  }

    repl_val <- unique(repl)
    A_list <- list()
    # y_list <- list()
    # X_cov_list <- list()
    # has_cov <- FALSE
    # if(ncol(X_cov) > 0){
    #   has_cov <- TRUE
    # }

    if(!is.null(model$make_A)) {
        for(j in repl_val){
            ind_tmp <- (repl %in% j)
            y_tmp <- y_resp[ind_tmp]            
            na_obs <- is.na(y_tmp)
            # y_list[[as.character(j)]] <- y_tmp[!na_obs]
            A_list[[as.character(j)]] <- model$make_A(loc_df[ind_tmp,])
            A_list[[as.character(j)]] <- A_list[[as.character(j)]][!na_obs, , drop = FALSE]
            # if(has_cov){
            #   X_cov_list[[as.character(j)]] <- X_cov[ind_tmp, , drop = FALSE]
            #   X_cov_list[[as.character(j)]] <- X_cov_list[[as.character(j)]][!na_obs, , drop = FALSE]
            # }

        if(inherits(model, "CBrSPDEobj")){
                  A_list[[as.character(j)]] <- kronecker(matrix(1, 1, model$m + 1), A_list[[as.character(j)]])
        }  
        }
    } else{
      print(model$make_A)
        stop("When creating the model object using matern.operators() or spde.matern.operators(), you should either supply a graph, or a mesh, or mesh_loc (this last one only works for dimension 1).")
    }

    n_coeff_nonfixed <- length(start_values)

    model_tmp <- model
    model_tmp$mesh <- NULL
    model_tmp$graph <- NULL
    model_tmp$make_A <- NULL

    if(inherits(model, "CBrSPDEobj")){
            likelihood <- function(theta){

                sigma_e <- exp(theta[1])
                n_cov <- ncol(X_cov)
                n_initial <- n_coeff_nonfixed                
                if(estimate_nu){
                    nu <- exp(theta[2])
                    if(nu %% 1 == 0){
                      nu <- nu - 1e-5
                    }
                    nu <- min(nu, 9.99)
                    gap <- 1
                } else{
                    gap <- 0
                    if(!is.numeric(nu)){
                        stop("nu must be numeric!")
                    }
                    if(length(nu)>1){
                        stop("nu must have length 1")
                    }
                    if(nu < 0){
                        stop("nu must be positive.")
                    }
                }
                    
                if(model_tmp$stationary){
                    if(model_tmp$parameterization == "spde"){
                        tau <- exp(theta[2+gap])
                        kappa <- exp(theta[3+gap])
                        model_tmp <- update.CBrSPDEobj(model_tmp,
                            user_nu = nu, user_tau = tau,
                            user_kappa = kappa, parameterization = "spde")
                    } else{

                        sigma <- exp(theta[2+gap])
                        range <- exp(theta[3+gap])
                        model_tmp <- update.CBrSPDEobj(model_tmp,
                            user_nu = nu,
                            user_sigma = sigma, user_range = range,
                            parameterization = "matern")

                    }
                } else{
                    theta_model <- theta[(2+gap):(n_initial)]

                    model_tmp <- update.CBrSPDEobj(model_tmp,
                            user_theta = theta_model,
                            user_nu = nu)                        
                }
                
                if(n_cov > 0){
                    beta_cov <- theta[(n_initial+1):(n_initial+n_cov)]
                } else{
                    beta_cov <- NULL
                }

                loglik <- aux_lme_CBrSPDE.matern.loglike(object = model_tmp, y = y_resp, X_cov = X_cov, repl = repl,
                A_list = A_list, sigma_e = sigma_e, beta_cov = beta_cov)

            return(-loglik)
        }
    } else{
           likelihood <- function(theta){
                sigma_e <- exp(theta[1])
                n_cov <- ncol(X_cov)
                n_initial <- n_coeff_nonfixed                
                if(estimate_nu){
                    nu <- exp(theta[2])
                    gap <- 1
                } else{
                    gap <- 0
                    if(!is.numeric(nu)){
                        stop("nu must be numeric!")
                    }
                    if(length(nu)>1){
                        stop("nu must have length 1")
                    }
                    if(nu < 0){
                        stop("nu must be positive.")
                    }
                }
                if(model$stationary){
                    if(model_tmp$parameterization == "spde"){
                        tau <- exp(theta[2+gap])
                        kappa <- exp(theta[3+gap])
                        model_tmp <- update.rSPDEobj(model_tmp,
                            user_nu = nu, user_tau = tau,
                            user_kappa = kappa, parameterization = "spde")
                    } else{
                        sigma <- exp(theta[2+gap])
                        range <- exp(theta[3+gap])
                        model <- update.rSPDEobj(model_tmp,
                            user_nu = nu,
                            user_sigma = sigma, user_range = range,
                            parameterization = "matern")
                    }
                } else{
                    theta_model <- theta[(2+gap):(n_initial-1-gap)]
                    model_tmp <- update.rSPDEobj(model_tmp,
                            user_theta = theta_model,
                            user_nu = nu)
                }
                
                if(n_cov > 0){
                    beta_cov <- theta[(n_initial+1):(n_initial+n_cov)]
                } else{
                    beta_cov <- NULL
                }

                loglik <- aux_lme_rSPDE.matern.loglike(object = model_tmp, y = y_resp, X_cov = X_cov, repl = repl,
                A_list = A_list, sigma_e = sigma_e, beta_cov = beta_cov)

            return(-loglik)
        }
    }

 if(ncol(X_cov)>0 && !is.null(model)){
    names_tmp <- colnames(X_cov)
    data_tmp <- cbind(y_resp, X_cov)
    data_tmp <- na.omit(data_tmp)
    temp_coeff <- lm(data_tmp[,1] ~ data_tmp[,-1] - 1)$coeff
    names(temp_coeff) <- names_tmp
    start_values <- c(start_values, temp_coeff)
    rm(data_tmp)
  }

hessian <- TRUE

if(improve_hessian){
  hessian <- FALSE
}

time_par <- NULL

if(parallel){
  start_par <- Sys.time()
  cl <- parallel::makeCluster(n_cores)
  parallel::setDefaultCluster(cl = cl)
  parallel::clusterExport(cl, "y_resp", envir = environment())
  parallel::clusterExport(cl, "model_tmp", envir = environment())
  parallel::clusterExport(cl, "A_list", envir = environment())
  parallel::clusterExport(cl, "X_cov", envir = environment())
  # parallel::clusterExport(cl, "y_list", envir = environment())  
  parallel::clusterExport(cl, "aux_lme_CBrSPDE.matern.loglike",
                 envir = as.environment("package:rSPDE"))
  parallel::clusterExport(cl, "aux_lme_rSPDE.matern.loglike",
                 envir = as.environment("package:rSPDE"))

  end_par <- Sys.time()
  time_par <- end_par - start_par

    start_fit <- Sys.time()
    res <- optimParallel::optimParallel(start_values, 
                  likelihood, method = optim_method,
                  control = optim_controls,
                  hessian = hessian,
                  parallel = list(forward = FALSE, cl = cl,
                      loginfo = FALSE))
  end_fit <- Sys.time()
  time_fit <- end_fit-start_fit
  parallel::stopCluster(cl)
} else{
  start_fit <- Sys.time()
      res <- optim(start_values, 
                  likelihood, method = optim_method,
                  control = optim_controls,
                  hessian = hessian)
  end_fit <- Sys.time()
  time_fit <- end_fit-start_fit
}


  if(model$stationary){
    coeff <- exp(c(res$par[1:n_coeff_nonfixed]))
  } else{
    coeff <- res$par[1:n_coeff_nonfixed]
    if(estimate_nu){
      coeff[2] <- exp(coeff[2])
    }
  }
  coeff <- c(coeff, res$par[-c(1:n_coeff_nonfixed)])

  loglik <- -res$value

  n_fixed <- ncol(X_cov)
  n_random <- length(coeff) - n_fixed - 1  

  time_hessian <- NULL

  if(!improve_hessian){
    observed_fisher <- res$hessian
  } else{
    if(!is.list(hessian_args)){
      stop("hessian_controls must be a list")
    }

    start_hessian <- Sys.time()
    observed_fisher <- numDeriv::hessian(likelihood, res$par, method.args = hessian_args)
    end_hessian <- Sys.time()
    time_hessian <- end_hessian-start_hessian
  }
  inv_fisher <- tryCatch(solve(observed_fisher), error = function(e) matrix(NA, nrow(observed_fisher), ncol(observed_fisher)))
  
  std_err <- sqrt(diag(inv_fisher))

  coeff_random <- coeff[2:(n_coeff_nonfixed)]
  std_random <- std_err[2:(n_coeff_nonfixed)]

  if(model$stationary){
    if(model$parameterization == "spde"){
        par_names <- c("tau", "kappa")
    } else{
        par_names <- c("sigma", "range")
    }
  } else{
    par_names <- c("Theta 1") 
    if(ncol(model$B.tau)>2){
        for(i in 2:(ncol(model$B.tau)-1)){
            par_names <- c(par_names, paste("Theta",i))
        }
    }
  }

  if(estimate_nu){
      par_names <- c("nu", par_names)
  }

  names(coeff_random) <- par_names

  coeff_meas <- coeff[1]
  names(coeff_meas) <- "std. dev"

  std_meas <- std_err[1]

  coeff_fixed <- NULL
  if(n_fixed > 0){
    coeff_fixed <- coeff[(2+n_random):length(coeff)]
    std_fixed <- std_err[(2+n_random):length(coeff)]
  } else{
    std_fixed <- NULL
  }

  } else{ # If model is NULL
    coeff_random <- NULL
    std_random <- NULL

    if(ncol(X_cov) == 0){
      stop("The model does not have either random nor fixed effects.")
    }

    names_tmp <- colnames(X_cov)
    data_tmp <- cbind(y_resp, X_cov)
    data_tmp <- na.omit(data_tmp)
    res <- lm(data_tmp[,1] ~ data_tmp[,-1] - 1)
    coeff_fixed <- res$coeff
    names(coeff_fixed) <- names_tmp
    sm_temp <- summary(res)
    std_fixed <- sm_temp$coefficients
    rownames(std_fixed) <- names_tmp
    coeff_meas <- sm_temp$sigma
    names(coeff_meas) <- "std. dev"
    std_meas <- NULL
    loglik <- logLik(res)[[1]]

  }

  if(is.null(coeff_fixed) && is.null(coeff_random)){
    stop("The model does not have either random nor fixed effects.")
  }

  object <- list()
  object$coeff <- list(measurement_error = coeff_meas, 
  fixed_effects = coeff_fixed, random_effects = coeff_random)
  object$std_errors <- list(std_meas = std_meas,
        std_fixed = std_fixed, std_random = std_random) 
  object$call <- call_rspde_lme
  object$terms <- list(fixed_effects = X_cov)
  object$response <- list(y = y_resp)
  object$formula <- formula
  object$estimation_method <- optim_method
  object$parameterization_latent <- model$parameterization
  object$repl <- repl
  object$optim_controls <- optim_controls
  object$latent_model <- model
  object$loglik <- loglik
  object$niter <- res$counts
  object$response <- y_term
  object$covariates <- cov_term
  object$fitting_time <- time_fit
  object$improve_hessian <- improve_hessian
  object$time_hessian <- time_hessian
  object$parallel <- parallel
  object$time_par <- time_par
  if(model_matrix){
    if(ncol(X_cov)>0){
      object$model_matrix <- cbind(y_resp, X_cov)
    } else{
      object$model_matrix <- y_resp
    }
  }

  class(object) <- "rspde_lme"
  return(object)

}

#' @name logLik.rspde_lme
#' @title log-likelihood for \code{graph_lme} Objects
#' @description Gives the log-likelihood for a fitted mixed effects model with a Whittle-Matern latent model.
#' @param x object of class "rspde_lme" containing results from the fitted model.
#' @param ... further arguments passed to or from other methods.
#' @return log-likelihood at the fitted coefficients.
#' @noRd
#' @method logLik rspde_lme
#' @export 

logLik.rspde_lme <- function(object, ...){
  return(object$loglik)
}


#' @name print.rspde_lme
#' @title Print Method for \code{rspde_lme} Objects
#' @description Provides a brief description of results related to mixed effects with Whittle-Matern latent models.
#' @param x object of class "rspde_lme" containing results from the fitted model.
#' @param ... further arguments passed to or from other methods.
#' @return Called for its side effects.
#' @noRd
#' @method print rspde_lme
#' @export 

print.rspde_lme <- function(x, ...) {
  #
  if(!is.null(x$latent_model)){
    if(x$latent_model$stationary){
      call_name <- "Latent model - Whittle-Matern"
    } else{
      call_name <- "Latent model - Generalized Whittle-Matern"
    }
  } else{
    call_name <- "Linear regression model"
  }

  coeff_fixed <- x$coeff$fixed_effects
  coeff_random <- x$coeff$random_effects
  
  cat("\n")
  cat(call_name)
  cat("\n\n")
  cat("Call:\n", paste(deparse(x$call), sep = "\n", collapse = "\n"),
      "\n\n", sep = "")
  cat(paste0("Fixed effects:", "\n"))
  if(!is.null(coeff_fixed)){
    print(coeff_fixed)
  } else{
    message("No fixed effects")
  }
  cat("\n")
  cat(paste0("Random effects:", "\n"))
  if(!is.null(coeff_random)){
    print(coeff_random)
  } else{
    message("No random effects")
  }
  cat("\n")
  cat(paste0("Measurement error:", "\n"))
  print(x$coeff$measurement_error)
}


#' @name summary.rspde_lme
#' @title Summary Method for \code{rspde_lme} Objects.
#' @description Function providing a summary of results related to mixed effects regression models with Whittle-Matern latent models.
#' @param object an object of class "rspde_lme" containing results from the fitted model.
#' @param ... not used.
#' @return An object of class \code{summary_rspde_lme} containing several
#' informations of a *rspde_lme* object.
#' @method summary rspde_lme
#' @export
summary.rspde_lme <- function(object, ...) {
  ans <- list()

  nfixed <- length(object$coeff$fixed_effects)
  nrandom <- length(object$coeff$random_effects)
  model_type <- is.null(object$latent_model)
  if(!is.null(model_type)){
    if(object$latent_model$stationary){
      call_name <- "Latent model - Whittle-Matern"
    } else{
      call_name <- "Latent model - Generalized Whittle-Matern"
    }
  } else{
    call_name <- "Linear regression model"
  }

  coeff_fixed <- object$coeff$fixed_effects
  coeff_random <- object$coeff$random_effects#
  coeff_meas <- object$coeff$measurement_error

  SEr_fixed <- object$std_errors$std_fixed
  SEr_random <- object$std_errors$std_random
  SEr_meas <- object$std_errors$std_meas

  coeff <- c(coeff_fixed, coeff_random, coeff_meas)
  SEr <- c(SEr_fixed,SEr_random, SEr_meas)

  if(model_type != "linearmodel"){
    tab <- cbind(coeff, SEr, coeff / SEr, 2 * stats::pnorm(-abs(coeff / SEr)))
    colnames(tab) <- c("Estimate", "Std.error", "z-value", "Pr(>|z|)")
    rownames(tab) <- names(coeff)
    tab <- list(fixed_effects = tab[seq.int(length.out = nfixed), , drop = FALSE], random_effects = tab[seq.int(length.out = nrandom) + nfixed, , drop = FALSE], 
    meas_error = tab[seq.int(length.out = 1) + nfixed+nrandom, , drop = FALSE])
  } else{
    tab <- list(fixed_effects = SEr_fixed, coeff_meas = coeff_meas)
  }

  ans$coefficients <- tab

  ans$model_type <- model_type

  ans$call_name <- call_name

  ans$call <- object$call

  ans$loglik <- object$loglik

  ans$niter <- object$niter

  ans$fitting_time <- object$fitting_time

  ans$improve_hessian <- object$improve_hessian

  ans$time_hessian <- object$time_hessian

  ans$parallel <- object$parallel

  ans$time_par <- object$time_par

  class(ans) <- "summary_rspde_lme"
  ans
}

#' @name print.summary_rspde_lme
#' @title Print Method for \code{summary_rspde_lme} Objects
#' @description Provides a brief description of results related to mixed effects regression models with Whittle-Matern latent models.
#' @param x object of class "summary_rspde_lme" containing results of summary method applied to a fitted model.
#' @param ... further arguments passed to or from other methods.
#' @return Called for its side effects.
#' @noRd
#' @method print summary_rspde_lme
#' @export
print.summary_rspde_lme <- function(x, ...) {
  tab <- x$coefficients

  #
  digits <- max(3, getOption("digits") - 3)
  #

  call_name <- x$call_name

  cat("\n")
  cat(call_name)

  cat("\n\n")
  cat("Call:\n", paste(deparse(x$call), sep = "\n", collapse = "\n"),
      "\n", sep = "")


  #
  model_type <- tolower(x$model_type)
  #
  if(model_type != "linearmodel"){
      if (NROW(tab$fixed_effects)) {
        cat(paste0("\nFixed effects:\n"))
        stats::printCoefmat(tab[["fixed_effects"]], digits = digits, signif.legend = FALSE)
      } else {
        message("\nNo fixed effects. \n")
      }
      #
      if (NROW(tab$random_effects)) {
        cat(paste0("\nRandom effects:\n"))
        stats::printCoefmat(tab[["random_effects"]][,1:3], digits = digits, signif.legend = FALSE)
      } else {
        message("\nNo random effects. \n")
      }
      #
      cat(paste0("\nMeasurement error:\n"))
        stats::printCoefmat(tab[["meas_error"]][1,1:3,drop = FALSE], digits = digits, signif.legend = FALSE)
  } else{
        cat(paste0("\nFixed effects:\n"))
        stats::printCoefmat(tab[["fixed_effects"]], digits = digits, signif.legend = FALSE)

        message("\nNo random effects. \n")
        cat(paste0("\nMeasurement error:\n"))
        print(tab$coeff_meas)

  }
  #
  if (getOption("show.signif.stars")) {
    cat("---\nSignif. codes: ", "0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1", "\n\n")
  }
  #

  cat("Log-Likelihood: ", x$loglik,"\n")
  if(model_type != "linearmodel"){
    cat(paste0("Number of function calls by 'optim' = ", x$niter[1],"\n"))
    cat(paste0("\nTimes:"))
    cat("\t Fit the model = ", paste(trunc(x$fitting_time[[1]] * 10^5)/10^5,attr(x$fitting_time, "units"),"\n"))
    if(x$improve_hessian){
    cat(paste0("\t Compute the Hessian = ", paste(trunc(x$time_hessian[[1]] * 10^5)/10^5,attr(x$time_hessian, "units"),"\n")))      
    }
    if(x$parallel){
    cat(paste0("\t Set up the parallelization = ", paste(trunc(x$time_par[[1]] * 10^5)/10^5,attr(x$time_par, "units"),"\n")))      
    }

  }
}



#' @name predict.graph_lme
#' @title Prediction of a mixed effects regression model on a metric graph.
#' @param object The fitted object with the `graph_lme()` function 
#' @param data A `data.frame` or a `list` containing the covariates, the edge number and the distance on edge
#' for the locations to obtain the prediction.
#' @param mesh Obtain predictions for mesh nodes? The graph must have a mesh, and either `only_latent` is set to TRUE or the model does not have covariates.
#' @param mesh_h If the graph does not have a mesh, one will be created with this value of 'h'.
#' @param repl Which replicates to obtain the prediction. If `NULL` predictions will be obtained for all replicates. Default is `NULL`.
#' @param compute_variances Set to also TRUE to compute the kriging variances.
#' @param posterior_samples If `TRUE`, posterior samples will be returned.
#' @param n_samples Number of samples to be returned. Will only be used if `sampling` is `TRUE`.
#' @param only_latent Should the posterior samples and predictions be only given to the latent model?
#' @param edge_number Name of the variable that contains the edge number, the default is `edge_number`.
#' @param distance_on_edge Name of the variable that contains the distance on edge, the default is `distance_on_edge`.
#' @param normalized Are the distances on edges normalized?
#' @param return_as_list Should the means of the predictions and the posterior samples be returned as a list, with each replicate being an element?
#' @param return_original_order Should the results be return in the original (input) order or in the order inside the graph?
#' @param ... Not used.
#' @export
#' @method predict graph_lme

predict.graph_lme <- function(object, data = NULL, mesh = FALSE, mesh_h = 0.01, repl = NULL, compute_variances = FALSE, posterior_samples = FALSE,
                               n_samples = 100, only_latent = FALSE, edge_number = "edge_number",
                               distance_on_edge = "distance_on_edge", normalized = FALSE, return_as_list = FALSE, return_original_order = TRUE,
                               ...) {

  if(is.null(data)){
    if(!mesh){
      stop("If 'mesh' is false, you should supply data!")
    }
  }

  out <- list()

  coeff_fixed <- object$coeff$fixed_effects
  coeff_random <- object$coeff$random_effects
  coeff_meas <- object$coeff$measurement_error

  BC <- object$BC

  graph_bkp <- object$graph$clone()

  X_cov_initial <- stats::model.matrix(object$covariates, graph_bkp$data)
  if(ncol(X_cov_initial) > 0){
    if(mesh){
      stop("In the presence of covariates, you should provide the data, including the covariates at the prediction locations. If you only want predictions for the latent model, set 'only_latent' to TRUE.")
    }
  }


  if(sum(duplicated(cbind(data["edge_number"], data["distance_on_edge"]))) > 0){
    warning("There are duplicated locations for prediction, we will try to process the data to extract the unique locations,
    along with the corresponding covariates.")
    cov_names <- attr(object$covariates,"term.labels")
    data <- data[c(edge_number,distance_on_edge,cov_names)]
    data <- unique(data) 
    if(sum(duplicated(cbind(data["edge_number"], data["distance_on_edge"]))) > 0){
      stop("Data processing failed, please provide a data with unique locations.")
    }
  }
  
  if(!mesh){
    n_prd <- length(data[[edge_number]])
    data[["__dummy_var"]] <- rep(0, n_prd)
    # Convert data to normalized
    if(!normalized){
      data[[distance_on_edge]] <- data[[distance_on_edge]] / graph_bkp$edge_lengths[data[[edge_number]]]
    }
  } else{
    if(is.null(graph_bkp$mesh)){
      graph_bkp$build_mesh(h = mesh_h)
    }
    data <- list()
    n_prd <- nrow(graph_bkp$mesh$VtE)
    data[["__dummy_var"]] <- rep(0, n_prd)
    data[[edge_number]] <- graph_bkp$mesh$VtE[,1]
    data[[distance_on_edge]] <- graph_bkp$mesh$VtE[,2]
    normalized <- TRUE
  }

    ord_idx <- order(data[[edge_number]], data[[distance_on_edge]])
  

  if(!is.null(data[[as.character(object$response)]])){
    data[[as.character(object$response)]] <- NULL
  }

  data_graph_temp <- list()
  idx_group1 <-  graph_bkp$data[["__group"]] == graph_bkp$data[["__group"]][1]
  data_graph_temp[[edge_number]] <- graph_bkp$data[["__edge_number"]][idx_group1]
  data_graph_temp[[distance_on_edge]] <- graph_bkp$data[["__distance_on_edge"]][idx_group1]
  data_graph_temp[[as.character(object$response)]] <- graph_bkp$data[[as.character(object$response)]][idx_group1]
  data_graph_temp <- as.data.frame(data_graph_temp)

  data_prd_temp <- list()
  data_prd_temp[[edge_number]] <- data[[edge_number]]
  data_prd_temp[[distance_on_edge]] <- data[[distance_on_edge]]
  data_prd_temp[["included"]] <- TRUE

  temp_merge <- merge(data_prd_temp, data_graph_temp, all = TRUE)

  temp_merge <- temp_merge[!is.na(temp_merge[["included"]]),]

  temp_merge[["included"]] <- NULL

  data <- merge(temp_merge, data)
  
  rm(temp_merge)
  # rm(data_prd_temp)
  rm(data_graph_temp)

  old_data <- graph_bkp$data

  data[["__group"]] <- old_data[["__group"]][1]

  graph_bkp$clear_observations()

  graph_bkp$add_observations(data = data, edge_number = edge_number, distance_on_edge = distance_on_edge, normalized = TRUE, group = "__group")

  graph_bkp$add_observations(data = old_data, edge_number = "__edge_number", distance_on_edge = "__distance_on_edge", group = "__group", normalized = TRUE)

  graph_bkp$data[["__dummy_ord_var"]] <- 1:length(graph_bkp$data[["__edge_number"]])

  n <- sum(graph_bkp$data[["__group"]] == graph_bkp$data[["__group"]][1])

  ## 
  repl_vec <- graph_bkp[["data"]][["__group"]]

  if(is.null(repl)){
    u_repl <- unique(graph_bkp$data[["__group"]])
  } else{
    u_repl <- unique(repl)
  }

  ##

  X_cov_pred <- stats::model.matrix(object$covariates, graph_bkp$data)
  
  if(all(dim(X_cov_pred) == c(0,1))){
    X_cov_pred <- matrix(1, nrow = length(graph_bkp$data[["__group"]]), ncol=1)
  }
  if(ncol(X_cov_pred) > 0){
    mu <- X_cov_pred %*% coeff_fixed
  } else{
    mu <- matrix(0, nrow = length(graph_bkp$data[["__group"]]), ncol=1)
  }

  Y <- graph_bkp$data[[as.character(object$response)]] - mu

  model_type <- object$latent_model

  sigma.e <- coeff_meas[[1]]
  sigma_e <- sigma.e

  if(!is.null(graph_bkp$data[["__dummy_var"]])){
      idx_prd <- !is.na(graph_bkp$data[["__dummy_var"]][1:n])
  } else {
      idx_prd <- !is.na(graph_bkp$data[["X__dummy_var"]][1:n])
  }

  n_prd <- sum(idx_prd)

  edge_nb <- graph_bkp$data[["__edge_number"]][1:n][idx_prd]
  dist_ed <- graph_bkp$data[["__distance_on_edge"]][1:n][idx_prd]

  ## construct Q

  # graph_bkp$data <- lapply(graph_bkp$data, function(dat){dat_temp <- dat
  #                       dat_temp[graph_bkp$data[["__dummy_ord_var"]]] <- dat
  #                                       return(dat_temp)})


  if(tolower(model_type$type) == "whittlematern"){
    sigma <- object$coeff$random_effects[1]
    if(object$parameterization_latent == "spde"){
      kappa <- object$coeff$random_effects[2]
    } else{
      kappa <- sqrt(8 * 0.5) / object$coeff$random_effects[2]
    }

      # if(model_type$alpha == 1){
      #     Q <- spde_precision(kappa = kappa, sigma = sigma,
      #                       alpha = 1, graph = graph_bkp)
      # } 
      # else{
      #   PtE <- graph_bkp$get_PtE()
      #   n.c <- 1:length(graph_bkp$CoB$S)
      #   Q <- spde_precision(kappa = kappa, sigma = sigma, alpha = 2,
      #                       graph = graph_bkp, BC = BC)
      #   Qtilde <- (graph_bkp$CoB$T) %*% Q %*% t(graph_bkp$CoB$T)
      #   Qtilde <- Qtilde[-n.c,-n.c]
      #   Sigma.overdetermined  = t(graph_bkp$CoB$T[-n.c,]) %*% solve(Qtilde) %*%
      #     (graph_bkp$CoB$T[-n.c,])
      #   index.obs <- 4 * (PtE[,1] - 1) + 1.0 * (abs(PtE[, 2]) < 1e-16) +
      #     3.0 * (abs(PtE[, 2]) > 1e-16)
      #   Sigma <-  as.matrix(Sigma.overdetermined[index.obs, index.obs])
      #   Q <- solve(Sigma)        
      # }

  } else if(tolower(model_type$type) == "graphlaplacian"){
    graph_bkp$observation_to_vertex()
    sigma <- object$coeff$random_effects[1]
    #nV before 
    nV_temp <- object$nV_orig
    # graph_bkp$observation_to_vertex()
    if(graph_bkp$nV > nV_temp){
      warning("There are prediction locations outside of the observation locations. Refit the model with all the locations you want to obtain predictions.")
    }
    graph_bkp$compute_laplacian()
    if(object$parameterization_latent == "spde"){
      kappa <- object$coeff$random_effects[2]
    } else{
      kappa <- sqrt(8 * 0.5) / object$coeff$random_effects[2]
    }
      if(model_type$alpha == 1){
        Q <- (kappa^2 * Matrix::Diagonal(graph_bkp$nV, 1) + graph_bkp$Laplacian[[1]]) / sigma^2
      } else{
        Q <- kappa^2 * Matrix::Diagonal(graph_bkp$nV, 1) + graph_bkp$Laplacian[[1]]
        Q <- Q %*% Q / sigma^2
      }

  } else if(tolower(model_type$type) == "isocov"){
      if(is.character(model_type$cov_function)){
        sigma <- object$coeff$random_effects[1]
        kappa <- object$coeff$random_effects[2]
        # if(model_type$cov_function == "alpha1"){
        #   # graph_bkp$observation_to_vertex()
        #   Q <- spde_precision(kappa = kappa, sigma = sigma,
        #                     alpha = 1, graph = graph_bkp)
        # } else if(model_type$cov_function == "alpha2"){
        #   PtE <- graph_bkp$get_PtE()
        #   n.c <- 1:length(graph_bkp$CoB$S)
        #   Q <- spde_precision(kappa = kappa, sigma = sigma, alpha = 2,
        #                       graph = graph_bkp, BC = BC)
        #   Qtilde <- (graph_bkp$CoB$T) %*% Q %*% t(graph_bkp$CoB$T)
        #   Qtilde <- Qtilde[-n.c,-n.c]
        #   Sigma.overdetermined  = t(graph_bkp$CoB$T[-n.c,]) %*% solve(Qtilde) %*%
        #     (graph_bkp$CoB$T[-n.c,])
        #   index.obs <- 4 * (PtE[,1] - 1) + 1.0 * (abs(PtE[, 2]) < 1e-14) +
        #     3.0 * (abs(PtE[, 2]) > 1e-14)
        #   Sigma <-  as.matrix(Sigma.overdetermined[index.obs, index.obs])
        #   Q <- solve(Sigma)
        # } else 
        if(model_type$cov_function == "GL1"){
              #nV before 
              nV_temp <- object$nV_orig
              graph_bkp$observation_to_vertex()
              if(graph_bkp$nV > nV_temp){
                warning("There are prediction locations outside of the observation locations. Refit the model with all the locations you want to obtain predictions.")
              }
              graph_bkp$compute_laplacian()        
              Q <- (kappa^2 * Matrix::Diagonal(graph_bkp$nV, 1) + graph_bkp$Laplacian[[1]]) / sigma^2
        } else if(model_type$cov_function == "GL2"){
              #nV before 
              nV_temp <- object$nV_orig
              graph_bkp$observation_to_vertex()
              if(graph_bkp$nV > nV_temp){
                warning("There are prediction locations outside of the observation locations. Refit the model with all the locations you want to obtain predictions.")
              }
              graph_bkp$compute_laplacian()
              Q <- kappa^2 * Matrix::Diagonal(graph_bkp$nV, 1) + graph_bkp$Laplacian[[1]]
              Q <- Q %*% Q / sigma^2
        # } else if(model_type$cov_function == "exp_covariance"){
        #           graph_bkp$compute_resdist(full = TRUE)
        #           Sigma <- as.matrix(exp_covariance(graph_bkp$res_dist[[1]], c(sigma,kappa)))
        #           Q <- solve(Sigma)
        # } 
        }
      } else{
        graph_bkp$compute_resdist(full = TRUE)
        cov_function <- model_type$cov_function
        Sigma <- as.matrix(cov_function(graph_bkp$res_dist[[1]], coeff_random))
      }
  }

  # gap <- dim(Q)[1] - n
  
  ## compute Q_x|y
  # A <- Matrix::Diagonal(dim(Q)[1])[(gap+1):dim(Q)[1], ]
  # if(tolower(model_type$type) == "isocov"){
  #   # A <- Matrix::Diagonal(dim(Q)[1])
  #   # A[graph_bkp$data[["__dummy_ord_var"]],] <- A
  #   A <- Matrix::Diagonal(dim(Q)[1])[graph_bkp$data[["__dummy_ord_var"]], ]
  #   A <- Matrix::Diagonal(dim(Q)[1])[graph_bkp$PtV, ]

  #   print(graph_bkp$PtV)
  # } else{
  #   A <- Matrix::Diagonal(dim(Q)[1])[graph_bkp$PtV, ]
  # }

  cond_aux1 <- (tolower(model_type$type) == "whittlematern")
  cond_aux2 <- (tolower(model_type$type) == "isocov" && is.character(model_type$cov_function))
  if(cond_aux2){
    cond_aux2 <- (model_type$cov_function == "alpha2" || model_type$cov_function == "alpha1")
  }
  cond_wm <- cond_aux1 || cond_aux2 

  cond_isocov <- (tolower(model_type$type) == "isocov" && !is.character(model_type$cov_function))

  if(!cond_wm && !cond_isocov){
    A <- Matrix::Diagonal(dim(Q)[1])[graph_bkp$PtV, ]
  }

  idx_obs_full <- as.vector(!is.na(Y))
  
  # idx_obs_full <- !is.na(graph_bkp$data[[as.character(object$response)]])

  if(return_original_order){
          dist_ed[ord_idx] <- dist_ed
          edge_nb[ord_idx] <- edge_nb
  }

  if(!return_as_list){
    out$distance_on_edge <- rep(dist_ed,length(u_repl))
    out$edge_number <- rep(edge_nb,length(u_repl))
  }

  if(cond_wm){
    PtE_full <- graph_bkp$get_PtE()
    PtE_pred <- PtE_full[idx_prd,]
  }

  cond_alpha2 <- FALSE
  cond_alpha1 <- FALSE
  if(cond_aux1){
    if(model_type$alpha == 2){
      cond_alpha2 <- TRUE
    } else {
      cond_alpha1 <- TRUE
    }
  }
  if(cond_aux2){
    if(model_type$cov_function == "alpha2"){
      cond_alpha2 <- TRUE
    } else{
      cond_alpha1 <- TRUE
    }
  }

  if(compute_variances || posterior_samples){
    if(cond_wm){
      graph_bkp2 <- graph_bkp$clone()
      graph_bkp2$observation_to_vertex()
      if(cond_alpha1){
        Q <- spde_precision(kappa = kappa, sigma = sigma,
                          alpha = 1, graph = graph_bkp2)
      } else{
        PtE <- graph_bkp2$get_PtE()
        n.c <- 1:length(graph_bkp2$CoB$S)
        Q <- spde_precision(kappa = kappa, sigma = sigma, alpha = 2,
                            graph = graph_bkp2, BC = BC)
        Qtilde <- (graph_bkp2$CoB$T) %*% Q %*% t(graph_bkp2$CoB$T)
        Qtilde <- Qtilde[-n.c,-n.c]
        Sigma.overdetermined  = t(graph_bkp2$CoB$T[-n.c,]) %*% solve(Qtilde) %*%
          (graph_bkp2$CoB$T[-n.c,])
        index.obs <- 4 * (PtE[,1] - 1) + 1.0 * (abs(PtE[, 2]) < 1e-14) +
          3.0 * (abs(PtE[, 2]) > 1e-14)
        Sigma <-  as.matrix(Sigma.overdetermined[index.obs, index.obs])
        Q <- solve(Sigma)
      }
      A <- Matrix::Diagonal(dim(Q)[1])[graph_bkp2$PtV, ]
      rm(graph_bkp2)
    }
  }


  for(repl_y in u_repl){
    if(return_as_list){
      out$distance_on_edge[[repl_y]] <- dist_ed
      out$edge_number[[repl_y]] <- edge_nb
    }
    idx_repl <- graph_bkp$data[["__group"]] == repl_y

    idx_obs <- idx_obs_full[idx_repl]

    y_repl <- Y[idx_repl]
    y_repl <- y_repl[idx_obs]

    if(!cond_wm && !cond_isocov){
        Q_xgiveny <- t(A[idx_obs,]) %*% A[idx_obs,]/sigma_e^2 + Q
    
        mu_krig <- solve(Q_xgiveny,as.vector(t(A[idx_obs,]) %*% y_repl / sigma_e^2))
    
        # mu_krig <- mu_krig[(gap+1):length(mu_krig)]
        mu_krig <- A[idx_prd,] %*% mu_krig
    
        if(!only_latent){
          mu_fe <- mu[idx_repl, , drop = FALSE]
          mu_krig <- mu_fe[idx_prd, , drop=FALSE] + mu_krig
        } 
    } else if (cond_wm){

      PtE_obs <- PtE_full[idx_obs,]

      if(cond_alpha2){
          mu_krig <- posterior_mean_obs_alpha2(c(sigma.e,sigma,kappa),
                        graph = graph_bkp, PtE_resp = PtE_obs, resp = y_repl,
                        PtE_pred = cbind(data_prd_temp[[edge_number]], data_prd_temp[[distance_on_edge]]))
        if(!only_latent){
          mu_fe <- mu[idx_repl, , drop = FALSE]
          mu_krig <- mu_fe[idx_prd, , drop=FALSE] + mu_krig[ord_idx]
        } else{
            mu_krig <- mu_krig[ord_idx]
          }   
      } else{
          mu_krig <- posterior_mean_obs_alpha1(c(sigma.e,sigma,kappa),
                        graph = graph_bkp, PtE_resp = PtE_obs, resp = y_repl,
                        PtE_pred = cbind(data_prd_temp[[edge_number]], data_prd_temp[[distance_on_edge]]))
                        # PtE_pred = cbind(edge_nb, dist_ed))
          if(!only_latent){
            mu_fe <- mu[idx_repl, , drop = FALSE]
            mu_krig <- mu_fe[idx_prd, , drop=FALSE] + mu_krig[ord_idx]
          } else{
            mu_krig <- mu_krig[ord_idx]
          }                        
      }
    } else { 
        Sigma <- as.matrix(cov_function(graph_bkp$res_dist[[1]], coeff_random))

        cov_loc <- Sigma[idx_prd, idx_obs]
        cov_Obs <- Sigma[idx_obs, idx_obs]
        
        # Observe that the "fixed-effects" mean has been subtracted from y_repl 
    
        mu_krig <- cov_loc %*%  solve(cov_Obs, y_repl)

        if(!only_latent){
            mu_fe <- mu[idx_repl, , drop = FALSE]
            mu_krig <- mu_fe[idx_prd, , drop=FALSE] + mu_krig
          } else{
            mu_krig <- mu_krig
          }
    
    }


    mean_tmp <- as.vector(mu_krig)

    if(return_original_order){
        mean_tmp[ord_idx] <- mean_tmp
      # var_tmp[ord_idx] <- var_tmp
    } 
        
    if(!return_as_list){
      out$mean <- c(out$mean, mean_tmp)
      out$repl <- c(out$repl, rep(repl_y,n_prd))
    } else{
      out$mean[[repl_y]] <- mean_tmp
    }

    if(compute_variances || posterior_samples){
      if(cond_wm){
            Q_xgiveny <- t(A[idx_obs,]) %*% A[idx_obs,]/sigma_e^2 + Q
      } 
    }

    if (compute_variances) {
      if(!cond_isocov){
        post_cov <- A[idx_prd,]%*%solve(Q_xgiveny, t(A[idx_prd,]))
        var_tmp <- max(diag(post_cov),0)
      } else{
        var_tmp <- diag(Sigma[idx_prd, idx_prd] - Sigma[idx_prd, idx_obs] %*% solve(Sigma[idx_obs, idx_obs],t(Sigma[idx_prd, idx_obs])))
        var_tmp <- ifelse(var_tmp < 0, 0, var_tmp) # possible numerical errors
      }

        # var_tmp[graph_bkp$data[["__dummy_ord_var"]]] <- var_tmp

      if(return_original_order){
        var_tmp[ord_idx] <- var_tmp
      }
      if(!return_as_list){
        out$variance <- rep(var_tmp, length(u_repl))
      }
      else {
          for(repl_y in u_repl){
            out$variance[[repl_y]] <- var_tmp
          }
      }
    }

    if(posterior_samples){
      mean_tmp <- as.vector(mu_krig)
      if(cond_isocov){
        post_cov <- Sigma[idx_prd, idx_prd] - Sigma[idx_prd, idx_obs] %*% solve(Sigma[idx_obs, idx_obs], t(Sigma[idx_prd,  idx_obs]))
      } else{
        post_cov <- A[idx_prd,]%*%solve(Q_xgiveny, t(A[idx_prd,]))
      }
      Z <- rnorm(dim(post_cov)[1] * n_samples)
      dim(Z) <- c(dim(post_cov)[1], n_samples)
      LQ <- chol(forceSymmetric(post_cov))
      X <- LQ %*% Z
      X <- X + mean_tmp
      if(!only_latent){
        X <- X + matrix(rnorm(n_samples * length(mean_tmp), sd = sigma.e), nrow = length(mean_tmp))
      } else{
        X <- X - as.vector(mu_fe[idx_prd, , drop=FALSE])
      }

      if(return_original_order){
        X[ord_idx,] <- X
      }

      if(!return_as_list){
        out$samples <- rbind(out$samples, X)
      } else{
        out$samples[[repl_y]] <- X
      }
    }
  }

  return(out)
}


