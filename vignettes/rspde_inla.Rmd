---
title: "R-INLA implementation of the covariance-based rational approximation"
author: "David Bolin, Alexandre B. Simas, Zhen Xiong"
date: "10/29/2021"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{R-INLA implementation of the covariance-based rational approximation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
references:
- id: bolin19
  title: "The rational SPDE approach for Gaussian random fields with general smoothness"
  author:
  - family: Bolin
    given: David
  - family: Kirchner
    given: Kristin
  container-title: Journal of Computational and Graphical Statistics
  volume: 29
  issue: 2
  page: 274-285
  type: article-journal
  issued:
    year: 2020
- id: lindgren11
  title: "An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic partial differential equation approach"
  author:
  - family: Lindgren
    given: Finn
  - family: Rue
    given: Håvard
  - family: Lindström
    given: Johan
  container-title: Journal of the Royal Statistical Society. Series B. Statistical Methodology
  volume: 73
  issue: 4
  page: 423--498
  type: article-journal
  issued:
    year: 2011
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction 

In this vignette we will illustrate how to do statistical inference with 
the covariance-based rational SPDE approach. The covariance-based
rational approximation is related to the [rational approximation by Bolin
and Kirchner (2020)](https://www.tandfonline.com/doi/full/10.1080/10618600.2019.1665537).

We will consider a real world data set measuring one month precipitation 
from the Paraná region in Brazil. We will also provide a 
step-by-step illustration on how to use our implementation of the 
covariance-based rational approximation to the R-INLA package.

It is important to mention that one can improve the performance
by using the PARDISO solver. Please, go to (https://www.pardiso-project.org/r-inla/#license)
to apply for a license. Also, use `inla.pardiso()` for instructions on 
how to enable the PARDISO sparse library.

## Covariance-based rational SPDE approach

Let us first discuss the basic setup. We want to model the precipitation as 
a two-dimensional random field $u$ within a bounded domain, where each 
location on the domain associates with a random variable which describe 
the local precipitation. 

In the SPDE approach, we model $u$ as the solution of the following SPDE: 
$$L^{\alpha/2}(\tau u) = \mathcal{W},$$ 
where 
$L  = -\Delta +\kappa^2 I$ and $\mathcal{W}$ is the standard Gaussian white noise. 
Here, $\alpha$, $\kappa$ and $\tau$ are three parameters we want to estimate. In
the standard SPDE approach, we write, for a general dimension $d$, 
$\alpha = \nu + d/2$ and assume $\nu$ to be fixed. In the rational SPDE approach
we are able to estimate a general smoothness $\nu$ from the data.

Now let us briefly describe how covariance based rational SPDE approach works 
in statistical inference. 

First, we approximate the random field $u$, which is the solution of the
SPDE written above, by using the finite element method: 
$$u_h(s_i)=\sum_{j=1}^{n_h} \hat{u}_j \varphi_j(s_i),$$ 
where $\{\hat{u}_j\}_{j = 1}^{n_h}$ are stochastic weights and $\{\varphi_j(s_i)\}_{j = 1}^{n_h}$ are fixed basis functions. The corresponding operator $L$ in terms of the finite element approximation is given by $L_h$. 

Now, by using the rational approximation, we can approximate covariance operator 
$L_h^{\alpha}$ as 
$$L_{h,m}^{-\alpha} = L_h^{-m_\alpha} p(L_h^{-1})q(L_h^{-1})^{-1}.$$
Here $m_{\alpha}$ is set by user and it controls the regularity of $u_h$, 
$m$ is the order of rational approximation, 
$p(L_h^{-1}) = \sum_{i=0}^m a_i L_h^{m-i}$ and 
$q(L_h^{-1}) = \sum_{j=0}^m b_j L_h^{m-i}$ where 
$\{a_i\}_{i = 0}^m$ and $\{b_j\}_{j = 0}^m$ are known coefficients 
obtained from the rational approximation. 

The next step is to obtain the decomposition of $p(L_h^{-1})q(L_h^{-1})^{-1}$ 
into partial fractions to get the new representation: 
$$L_{h,m}^{-\alpha} =L_h^{-m_\alpha} \left(\sum_{i=1}^{m}  r_i  (L_h-p_i I)^{-1} +k\right).$$
Based on the above operator equation, we can derive the covariance matrix of the stochastic weights $\hat{\textbf{u}}$, where $\hat{\textbf{u}}=[\hat{u}_1,...,\hat{u}_{n_h}]^\top$, 
as 
$$\mathbf{\Sigma}_{\hat{\textbf{u}}} = (\textbf{L}^{-1}\textbf{C})^{m_{\alpha}} \sum_{i=1}^{m}r_i(\textbf{L}-p_i\textbf{C})^{-1}+\textbf{K}. $$
Here $\textbf{C}$ is mass matrix, $\textbf{L} = \kappa^2\textbf{C}+\textbf{G}$, $\textbf{G}$ is stiffness matrix and
$$\textbf{K}=\left\{
	\begin{array}{lcl}
		k\textbf{C}      &      & {m_{\alpha}=0}\\
		k\textbf{L}^{-1}(\textbf{C}\textbf{L}^{-1})^{m_{\alpha}-1}    &      & {m_{\alpha}>=1}\\
	\end{array} \right.$$
	

This actually indicates that we can express $\hat{\textbf{u}}$ as $$\hat{\textbf{u}}=\sum_{i=1}^{m+1}\textbf{x}_i .$$

Here 
$$\textbf{x}_i \sim N(\textbf{0},\textbf{Q}_i^{-1})$$
where $\textbf{Q}_i$ is the precision matrix of $\textbf{x}_i$ and 
$$\textbf{Q}_i=\left \{
	\begin{array}{lcl}
		(\textbf{L}-p_i\textbf{C})(\textbf{C}^{-1}\textbf{L})^{m_{\alpha}}/r_i      &      & {i = 1,...,m}\\
		 \textbf{K}^{-1}   &      & {i = m+1}\\
	\end{array} \right.$$

Now we can replace the Matérn latent field by the latent vector given above, which
has precision matrix given by
$$\textbf{Q}=\begin{bmatrix}\textbf{Q}_1& &\\&\ddots&\\& &\textbf{Q}_{m+1}\end{bmatrix},$$
replace the standard $A$ matrix from the SPDE approach by the following $A$ matrix: $$\overline{\textbf{A}}=\begin{bmatrix}\textbf{A}&\cdots&\textbf{A}\end{bmatrix}_{n\times n_h(m+1)},$$ 
where
$$\textbf{A}=\begin{bmatrix}\varphi_1(s_1)&\cdots&\varphi_{n_h}(s_1)\\\vdots&\vdots&\vdots\\\varphi_1(s_n)&\cdots&\varphi_{n_h}(s_n)\end{bmatrix}.$$

With these elements, we can use INLA to compute the posterior distribution of the three parameters we want to estimate.

The computational cost of a covariance-based rational approximation of order $m$ 
is approximately the same as the standard rational approximation of order $m/2$.
Therefore, we will use a convention to say that a covariance-based rational 
approximation is of order $k$, to mean that we are choosing $m=2k$. So,
a covariance-based rational approximation of order $2$, means that we are choosing
$m=4$, with the same computational cost as choosing $m=2$ in the standard rational
approximation.


## Example with real data

To illustrate our implementation of rSPDE in INLA we will consider a dataset
available in INLA. This data has also been used to illustrate the SPDE approach,
see for instance the book [Advanced Spatial Modeling with Stochastic Partial Differential Equations Using R and INLA](https://www.routledge.com/Advanced-Spatial-Modeling-with-Stochastic-Partial-Differential-Equations/Krainski-Gomez-Rubio-Bakka-Lenzi-Castro-Camilo-Simpson-Lindgren-Rue/p/book/9780367570644) and also the vignette [Spatial Statistics using R-INLA and Gaussian Markov random fields](https://sites.stat.washington.edu/peter/591/INLA.html).

The data consist of precipitation measurements from the Paraná region in Brazil
and were provided by the Brazilian National Water Agency. The data were collected
at 616 gauge stations in Paraná state, south of Brazil, for each day in 2011.

## A rSPDE model for precipitation

We will follow the vignette [Spatial Statistics using R-INLA and Gaussian Markov random fields](https://sites.stat.washington.edu/peter/591/INLA.html). 
As precipitation data are always positive, we will assume it is Gamma distributed. 
INLA uses the following parameterisation of the Gamma distribution, 
$$\Gamma(\mu, c\phi): \pi (y) = \frac{1}{\Gamma(c\phi)} \left(\frac{c\phi}{\mu}\right)^{c\phi} y^{c\phi - 1} \exp\left(-\frac{c\phi y}{\mu}\right) .$$
In this parameterisation, the distribution has expected value $E(x) = \mu$ and variance $V(x) = \mu^2/(c\phi)$, where $c$ is a fixed (known) scaling parameter and $1/\phi$ is a dispersion parameter.

In this example $\mu$ will be modelled using a stochastic model that includes both covariates 
and spatial structure, resulting in the latent Gaussian model for the precipitation measurements
$$\begin{align} y_i\mid \mu(s_i), \theta &\sim \Gamma(\mu(s_i),c\phi)\\ \log (\mu(s)) &= \eta(s) = \sum_k f_k(c_k(s))+x(s)\\ \theta &\sim \pi(\theta) \end{align}.$$

where $y_i$ denotes the measurement taken at location $s_i$, $c_k(s)$ are covariates, $x(s)$ is a mean-zero Gaussian Matérn field, and $\theta$ is a vector containing all parameters of the model,
including smoothness of the field. That is, by using the rSPDE model, we will 
also be able to estimate the smoothness of the latent field.

## Examining the data
We will be using INLA. To install INLA go to [R-INLA Project](https://www.r-inla.org/download-install).

We begin by loading some libraries we need to get the data and build the plots.

```{r message=FALSE}
library(gridExtra)
library(ggplot2)
library(lattice)
library(INLA)
library(splancs)
library(fields)
```

Let us load the data and the border of the region

```{r message=FALSE}
data(PRprec)
data(PRborder)
```

The data frame contains daily measurements at 616 stations for the year 2011, as well as coordinates and altitude information for the measurement stations. We will not analyse the full spatio-temporal data set, but instead look at the total precipitation in January, which we calculate as

```{r message=FALSE}
Y <- rowMeans(PRprec[, 3 + 1:31])
```

In the next snippet of code, we extract the coordinates and altitudes 
and remove the locations with missing values.

```{r message=FALSE}
ind <- !is.na(Y)
Y <- Y[ind]
coords <- as.matrix(PRprec[ind, 1:2])
alt <- PRprec$Altitude[ind]
```

Let us build a plot for the precipitations:

```{r message=FALSE,fig.width=6, fig.height=4}
ggplot() + geom_point(aes(x = coords[, 1], y = coords[, 2], colour = Y), size = 2, 
    alpha = 1) + scale_colour_gradientn(colours = tim.colors(100)) + geom_path(aes(x = PRborder[, 
    1], y = PRborder[, 2])) + geom_path(aes(x = PRborder[1034:1078, 1], y = PRborder[1034:1078, 
    2]), colour = "red")
```

The red line in the figure shows the coast line, and we expect the distance to 
the coast to be a good covariate for precipitation. 

This covariate is not 
available, so let us calculate it for each observation location:

```{r message=FALSE}
seaDist <- apply(spDists(coords, PRborder[1034:1078, ], longlat = TRUE), 1, 
    min)
```

Now, let us plot the precipitation as a function of the possible covariates:

```{r message=FALSE, fig.width=6, fig.height=4}
par(mfrow = c(2, 2))
plot(coords[, 1], Y, cex = 0.5, xlab = "Longitude")
plot(coords[, 2], Y, cex = 0.5, xlab = "Latitude")
plot(seaDist, Y, cex = 0.5, xlab = "Distance to sea")
plot(alt, Y, cex = 0.5, xlab = "Altitude")
par(mfrow = c(1, 1))
```


## Creating the rSPDE model

To use the INLA implementation of the rSPDE model we need to load the functions:
```{r message=FALSE}
library(rSPDE)
```

### Mesh

We can use INLA for creating the mesh. Let us create a mesh which is based 
on a non-convex hull to avoid adding many small triangles outside the domain of interest (more triangles = larger computation times):

```{r message=FALSE, fig.width=6, fig.height=4}
prdomain <- inla.nonconvex.hull(coords, -0.03, -0.05, resolution = c(100, 100))
prmesh <- inla.mesh.2d(boundary = prdomain, max.edge = c(0.45, 1), cutoff = 0.2)
plot(prmesh, asp = 1, main = "")
lines(PRborder, col = 3)
points(coords[, 1], coords[, 2], pch = 19, cex = 0.5, col = "red")
```

### The observation matrix (A)

We now create the $A$ matrix, that connects the mesh to the observation 
locations and then create the rSPDE model.

For this task we need to use a rSPDE specific function, since the size of
the $A$ matrix depends on the order of the rational approximation.

The default order is 2 for our covariance-based rational approximation. 
As mentioned in the description of the covariance-based rational approximation,
what we call here order 2 is actually order 4, but has the same computational cost
as a standard rational approximation of order 2.

There is an option to fix some smoothness, or the estimate smoothness. The
default is to estimate smoothness.

In this first example we will assume we want a rational approximation of order
2, where we want to estimate the smoothness.

To this end we can use the `rspde_create_A` function. Since we will assume order
2 and that we want to estimate smoothness, the required parameters are simply 
the mesh and the locations:

```{r message=FALSE}
Abar <- rspde_create_A(inla_mesh = prmesh, loc = coords)
```

### Setting up the rSPDE model

To set up a rSPDE model, all we need is the mesh and the dimension. 
By default it will assume that we want to estimate the smoothness parameter
and that we will do a covariance-based rational approximation of order 2.

We will also see other options for setting up rSPDE models such as keeping
the smoothness parameter fixed and/or increasing the order of the covariance-based
rational approximation.

Therefore, to set up a model all we have to do is use the `create_rspde_model` function:

```{r message=FALSE}
rspde_model <- create_rspde_model(inla_mesh = prmesh, optimize=FALSE)
```

### The inla.stack

Since the covariates already are evaluated at the observation locations, 
we only want to apply the $A$ matrix to the spatial effect and not the 
fixed effects. We can use the `inla.stack` function.

The difference is that we need to use the function `rspde_make_index` to
create the index:

```{r message=FALSE}
mesh.index <- rspde_make_index(name = "field", inla_mesh = prmesh)
```

We can then create the stack in a standard manner:

```{r message=FALSE}
stk.dat <- inla.stack(
  data = list(y = Y), A = list(Abar, 1), tag = "est", 
  effects = list(c(mesh.index, 
                   list(Intercept = 1)), 
                 list(long = inla.group(coords[, 1]), 
                      lat = inla.group(coords[,2]),
                      seaDist = inla.group(seaDist))))
```

Here the observation matrix $A$ is applied to the spatial effect and the 
intercept while an identity observation matrix, denoted by $1$, 
is applied to the covariates. This means the covariates are unaffected 
by the observation matrix. 

The observation matrices in $A=list(Abar,1)$ are used to link the corresponding 
elements in the effects-list to the observations. Thus in our model the 
latent spatial field `mesh.index` and the intercept are linked to the 
log-expectation of the observations, i.e. $\eta(s)$, through the $A$-matrix.
The covariates, on the other hand, are linked directly to $\eta(s)$. 
The `stk.dat` object defined above implies the following principal linkage 
between model components and observations 
$$\eta(s) \sim A x(s) + A \text{ Intercept} + \text{long} + \text{lat}+ \text{seaDist}.$$
$\eta(s)$ will then be used in the observation-likelihood, 
$$y_i\mid \eta(s_i),\theta \sim \Gamma(\exp(\eta (s_i)), c\phi).$$


## Model fitting

We will build a model using the distance to the sea $x_i$ 
as a covariate through an improper CAR(1) model with 
$\beta_{ij}=1(i\sim j)$, which INLA calls a random walk of order 1.

```{r message=FALSE}
f.s <- y ~ -1 + Intercept +  f(seaDist, model = "rw1") + 
  f(field, model = rspde_model) 
```
Here `-1` is added to remove R's implicit intercept, which is replaced 
by the explicit `+Intercept` from when we created the stack. 

To fit the model we can use INLA:

```{r message=FALSE, warning=FALSE}
rspde_fit <- inla(f.s, family = "Gamma", data = inla.stack.data(stk.dat), 
            verbose = FALSE, 
            control.inla=list(int.strategy='eb'),
            control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE))
```

## INLA results

We can look at some summaries of the posterior distributions for the parameters, 
for example the fixed effects (i.e. the intercept) and the hyper-parameters 
(i.e. dispersion in the gamma likelihood, the precision of the RW1, 
and the parameters of the spatial field):

```{r}
summary(rspde_fit)
```

Let $\theta_1 = Theta1$, $\theta_2=Theta2$ and $\theta_3=Theta3$, in terms of 
the SPDE
$$(\kappa^2 I - \Delta)^\beta(\tau u) = \mathcal{W},$$
where $\beta = \nu/2 + d/4$, we have that
$$\kappa = \exp(\theta_1), \quad \nu = \exp(\theta_2) + d/4, \quad \tau = \exp(\theta_3).$$


## Changing the order of the rational approximation

To change the order of the rational approximation all we have to do
is set the argument `rspde_order` to the desired value. The current available
possibilities are `2,3` and `4` (corresponding to `4,6` and `8` to the 
standard rational approximation). 

Let us fit the above model with the covariance-based rational approximation
of order `3`:

* We build a new model:
```{r message=FALSE}
rspde_model_3 <- create_rspde_model(inla_mesh = prmesh, rspde_order = 3,
                                    optimize=FALSE)
```

* We create a new $A$ matrix:
```{r message=FALSE}
Abar_3 <- rspde_create_A(inla_mesh = prmesh, loc = coords, rspde_order = 3)
```

* We create a new index:
```{r message=FALSE}
mesh.index.3 <- rspde_make_index(name = "field", inla_mesh = prmesh, 
                                 rspde_order = 3)
```

Now the remaining is standard:

```{r message=FALSE}
stk.dat.3 <- inla.stack(
  data = list(y = Y), A = list(Abar_3, 1), tag = "est", 
  effects = list(c(mesh.index.3, 
                   list(Intercept = 1)), 
                 list(long = inla.group(coords[, 1]), 
                      lat = inla.group(coords[,2]),
                      seaDist = inla.group(seaDist))))

f.s.3 <- y ~ -1 + Intercept +  f(seaDist, model = "rw1") +
  f(field, model = rspde_model_3)

rspde_fit_3 <- inla(f.s.3, family = "Gamma", data = inla.stack.data(stk.dat.3), 
                    verbose = FALSE, 
            control.inla=list(int.strategy='eb'),
            control.predictor = list(A = inla.stack.A(stk.dat.3), compute = TRUE))
```

Let us see the summary:
```{r}
summary(rspde_fit_3)
```

## Estimating models with fixed smoothness

We can fix the smoothness, say $\nu$, of the model by providing the value of $\nu$.

When the smoothness, $\nu$, is fixed, we can have two possibilities:

* $\alpha = \nu + d/2$ is integer;

* $\alpha = \nu + d/2$ is not integer.

The first case, i.e., when $\alpha$ is integer, has much less computational
cost. Furthermore, the $A$ matrix is different than the $A$ matrix for the 
non-integer $\alpha$. 

The $A$ matrix is the same for all values of $\nu$ such that $\alpha$ is integer.
So, the $A$ matrix for these cases only need to be computed once. The same
holds for the `index` obtained from the `rspde_make_index` function.

In the second case the $A$ matrix only depend on the order of the rational
approximation and not on $\nu$. Therefore, if the matrix $A$ has already been
computed for some order, then the $A$ matrix will be same for all the values
of $\nu$ such that $\alpha$ is non-integer. The same holds for the
`index` obtained from the `rspde_make_index` function.

If $\nu$ is fixed, we have that the parameters returned by INLA are
$$\kappa = \exp(\theta_1)\quad\hbox{and}\quad\tau = \exp(\theta_2).$$

### Estimating models with fixed smoothness and non-integer $\alpha$

Recall that 
$$\nu = \exp(\theta_2)+d/4.$$

Thus, let us consider a fixed $\nu$ given by the mean of $\nu$ 
obtained from the
third-order model, namely, the fit given by `rspde_fit_3`, 
which is approximately $\nu = 0.78$.

Let us also consider initially a model of order 2.

Notice that for this $\nu$, the value of $\alpha$ is non-integer, so we
can use the $A$ matrix and the index of the first fitted model, 
which is also of order 2.

Therefore, all we have to do is build a new model in which we set
 `nu` to `0.78`:

```{r message=FALSE}
rspde_model_fix <- create_rspde_model(inla_mesh = prmesh, rspde_order = 2,
                                       nu = 0.78, optimize=FALSE)
```

Let us now fit the model:

```{r message=FALSE}
f.s.fix <- y ~ -1 + Intercept +  f(seaDist, model = "rw1") +
  f(field, model = rspde_model_fix)

rspde_fix <- inla(f.s.fix, family = "Gamma", data = inla.stack.data(stk.dat), 
                verbose = FALSE, 
              control.inla=list(int.strategy='eb'),
              control.predictor = list(A = inla.stack.A(stk.dat), compute = TRUE))
```

Here we have the summary:
```{r}
summary(rspde_fix)
```

#### Increasing the order

Let us fit the same model as above, but with order 3 from the covariance-based
rational approximation.

Notice that we already computed the $A$ matrix and the `index` for the third order
model. Thus, all we have to do is build a new model and fit:

```{r message=FALSE}
rspde_model_fix_3 <- create_rspde_model(inla_mesh = prmesh, rspde_order = 3,
                                       nu = 0.78)

f.s.fix.3 <- y ~ -1 + Intercept +  f(seaDist, model = "rw1") + 
  f(field, model = rspde_model_fix_3)

rspde_fix_3 <- inla(f.s.fix.3, family = "Gamma", data = inla.stack.data(stk.dat.3), 
                  verbose = FALSE, 
                control.inla=list(int.strategy='eb'),
                control.predictor = list(A = inla.stack.A(stk.dat.3), compute = TRUE))
```

Here we have the summary:
```{r}
summary(rspde_fix_3)
```

### Estimating models with fixed smoothness and integer $\alpha$

We will illustrate this case to describe a two-stages strategy to reduce
computational cost. 

To such an end we will dedicate an entire section to the strategy.

## Two-stages estimation strategy

To be able to use R-INLA to fit a rSPDE model, we need to restrict the interval
of estimation of the smoothness parameter to a bounded interval. Furthermore,
the optimization will be carried out based on the sparsity of the precision matrix
on the value of $\nu$ on the supremum of this interval. The reason is that the
precision matrix gets denser as $\nu$ increases. Therefore, the smaller we can 
define the maximum value of $\nu$, the faster the optimization will be.

The default maximum value of $\nu$ is `7` and can be changed by setting
the argument `nu_upper_bound` to the desired value inside 
the `create_rspde_model` function.

Notice, however, that since we do not know the true value of $\nu$ we need an
strategy to be able to reduce the computational cost and still obtain a 
reasonable estimate of $\nu$.

### The strategy

The core of the strategy comes from the fact that the sparsity of the
precision matrix increases with $\nu$ as long as $\alpha=\nu+d/2$ is non-integer.
If $\alpha$ is integer, then the sparsity is the same, regardless of $\nu$.
Furthermore, the size of the precision matrix for the case in which $\alpha$
is integer is also much smaller than in the non-integer case. More precisely, 
if we consider a precision matrix from the covariance-based rational 
approximation of order $m$, then the precision matrix has size
$(2m+1)N\times (2m+1)N$, where $N$ is the number of rows of the 
precision matrix for the integer case.

The idea is then to do sequential estimates of the parameters with $\nu$
fixed and being chosen across the integers until the marginal likelihood,
evaluated at the fitted parameters for that fixed $\nu$, starts to decrease. 
We then choose such a $\nu$ as the upper bound.

Let us now illustrate the idea explicitly.

Since we are in dimension $d=2$, and $\nu>0$, the smallest value of $\nu$
that makes $\alpha = \nu + 1$ an integer is $\nu=1$. Let us fit such a model.

To this end we need to compute a new $A$ matrix:

```{r message=FALSE}
Abar.int <- rspde_create_A(inla_mesh = prmesh, loc = coords,
                       nu = 1)
```

a new index:

```{r message=FALSE}
mesh.index.int <- rspde_make_index(name = "field", inla_mesh = prmesh,
                                  nu = 1)
```

create a new model (remember to set `nu=1`):

```{r message=FALSE}
rspde_model_fix_int1 <- create_rspde_model(inla_mesh = prmesh,
                                     nu = 1, optimize = TRUE)
```

The remaining is standard:

```{r message=FALSE}
stk.dat.int <- inla.stack(
  data = list(y = Y), A = list(Abar.int, 1), tag = "est", 
  effects = list(c(mesh.index.int, 
                   list(Intercept = 1)), 
                 list(long = inla.group(coords[, 1]), 
                      lat = inla.group(coords[,2]),
                      seaDist = inla.group(seaDist))))

f.s.fix.int.1 <- y ~ -1 + Intercept +  f(seaDist, model = "rw1") +
  f(field, model = rspde_model_fix_int1)

rspde_fix_int_1 <- inla(f.s.fix.int.1, family = "Gamma", 
                      data = inla.stack.data(stk.dat.int), verbose = FALSE, 
                  control.inla=list(int.strategy='eb'),
                  control.predictor = list(A = inla.stack.A(stk.dat.int), 
                                           compute = TRUE))
```

Let us check the summary:

```{r}
summary(rspde_fix_int_1)
```

The value of the marginal likelihood for this model was `-1259.47`.

Let us now estimate the model for the next value of $\nu$ such that $\alpha$
is an integer. Such value is $\nu = 2$. Let us fit such a model.

Notice that we do not need to compute the $A$ matrix nor the index since 
we already computed them.

Thus,

```{r message=FALSE}
rspde_model_fix_int2 <- create_rspde_model(inla_mesh = prmesh,
                                            nu = 2)

f.s.fix.int.2 <- y ~ -1 + Intercept +  f(seaDist, model = "rw1") +
  f(field, model = rspde_model_fix_int2)

rspde_fix_int_2 <- inla(f.s.fix.int.2, family = "Gamma", 
                      data = inla.stack.data(stk.dat.int), verbose = FALSE, 
                      control.inla=list(int.strategy='eb'),
                      control.predictor = list(A = inla.stack.A(stk.dat.int), 
                                               compute = TRUE))
```

Let us now check the summary:

```{r}
summary(rspde_fix_int_2)
```

Now, observe that the marginal likelihood for $\nu=2$ was `-1262.25` which is smaller
than `-1259.47`. Thus, we expect the true $\nu$ to be less than `2`. Hence,
we will set `2` as our upper bound for $\nu$ by setting `nu_upper_bound = 2` 
inside the `create_rspde_model` function:

```{r message=FALSE}
rspde_model_gen <- create_rspde_model(inla_mesh = prmesh, d=2, 
                                      nu_upper_bound = 2)

f.s.gen <- y ~ -1 + Intercept +  f(seaDist, model = "rw1") +
  f(field, model = rspde_model_gen)

rspde_gen <- inla(f.s.gen, family = "Gamma", 
                      data = inla.stack.data(stk.dat), verbose = FALSE, 
                      control.inla=list(int.strategy='eb'),
                      control.predictor = list(A = inla.stack.A(stk.dat), 
                                               compute = TRUE))
```

Let us see the summary:
```{r}
summary(rspde_gen)
```

Let us compare the computational times for the first model, with the
default value of `nu_upper_bound`, with the one obtained from the
two-stages strategy:

```{r}
rspde_fit$cpu.used

rspde_fix_int_1$cpu.used
rspde_fix_int_2$cpu.used
rspde_gen$cpu.used
```

Observe that time computational time of the model 
`rspde_fit` was bigger than the sum of the computational times of `rspde_fix_int_1`,
`rspde_fix_int_2` and `rspde_gen`.

## References 