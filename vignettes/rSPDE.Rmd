---
title: "An introduction to the rSPDE package"
author: "David Bolin and Alexandre B. Simas"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{An introduction to the rSPDE package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
references:
- id: bolin19
  title: "The rational SPDE approach for Gaussian random fields with general smoothness"
  author:
  - family: Bolin
    given: David
  - family: Kirchner
    given: Kristin
  container-title: Journal of Computational and Graphical Statistics
  volume: 29
  issue: 2
  page: 274-285
  type: article-journal
  issued:
    year: 2020
- id: lindgren11
  title: "An explicit link between Gaussian fields and Gaussian Markov random fields: the stochastic partial differential equation approach"
  author:
  - family: Lindgren
    given: Finn
  - family: Rue
    given: Håvard
  - family: Lindström
    given: Johan
  container-title: Journal of the Royal Statistical Society. Series B. Statistical Methodology
  volume: 73
  issue: 4
  page: 423--498
  type: article-journal
  issued:
    year: 2011
- id: bolin13
  title: "Spatial Matérn Fields Driven by Non-Gaussian Noise"
  author:
    - family: Bolin
      given: David
  container-title: Scandinavian Journal of Statistics
  volume: 41
  issue: 3
  page: 557-579
  type: article-journal
  issued:
    year: 2013
- id: wallin15
  title: "Geostatistical Modelling Using Non-Gaussian Matérn Fields"
  author:
    - family: Wallin
      given: Jonas
    - family: Bolin
      given: David
  container-title: Scandinavian Journal of Statistics
  volume: 42
  issue: 3
  page: 872-890
  type: article-journal
  issued:
    year: 2015
- id: asar20
  title: "Linear mixed effects models for non‐Gaussian repeated measurement data"
  author:
    - family: Asar
      given: Özgür
    - family: Bolin
      given: David
    - family: Diggle
      given: Peter
    - family: Wallin
      given: Jonas
  container-title: Journal of the Royal Statistical Society. Series C. Applied Statistics
  volume: 69
  issue: 5
  page: 1015-1065
  type: article-journal
  issued:
    year: 2020 
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

set.seed(1)
```

```{r inla_link, include = FALSE}
inla_link <- function() {
  sprintf("[%s](%s)", "`R-INLA`", "https://www.r-inla.org")
}
```

## Introduction

In this vignette we provide a brief introduction to the `rSPDE`
package. We begin by using the package to generate a simple data set. Then,
we will analyze this data set using the `rSPDE` package.

We have two main "families" of functions inside the `rSPDE` package:

* The `r inla_link()` implementation of the rational SPDE approach of [@bolin19](https://www.tandfonline.com/doi/full/10.1080/10618600.2019.1665537);

* The rational SPDE approach.

We will analyze the same data set using both approaches.
We also have specific vignettes for each of the aforementioned family. More precisely,
we have the following additional vignettes:

* [R-INLA implementation of the rational SPDE approach](rspde_inla.html)

* [Rational approximation with the rSPDE package](rspde_cov.html)

We also have a separate group of functions for performing operator-based
rational approximations. These will be useful when performing rational 
approximations for fractional SPDE models with non-Gaussian noise. An
example in which such approximation is suitable is when one has the
so-called type-G Lévy noises. 

We refer the reader to [@wallin15](https://onlinelibrary.wiley.com/doi/full/10.1111/sjos.12141), 
[@bolin13](https://onlinelibrary.wiley.com/doi/abs/10.1111/sjos.12046) and
[@asar20](https://rss.onlinelibrary.wiley.com/doi/pdf/10.1111/rssc.12405)
for examples of models driven by type-G Lévy noises. We also refer the reader
to the [`ngme` package](https://github.com/davidbolin/ngme) where one can fit such models.

We explore the functions for performing the operator-based rational approximation
on the vignette:

* [Operator-based rational approximation with the rSPDE package](rspde_base.html)

## A toy data set

We begin by generating a toy data set.

For this illustration, we will simulate a data set on a two-dimensional spatial domain. 
To this end, we need to construct a mesh over the domain of interest and then compute 
the matrices needed to define the operator. We will use the `r inla_link()` package
to create the mesh and obtain the matrices of interest.

We will begin by defining a mesh over $[0,1]\times [0, 1]$:

```{r, message=FALSE, warning=FALSE, fig.align='center'}
library(INLA)
n_loc <- 2000
loc_2d_mesh <- matrix(runif(n_loc * 2), n_loc, 2)
mesh_2d <- inla.mesh.2d(
  loc = loc_2d_mesh,
  cutoff = 0.05,
  max.edge = c(0.1, 0.5)
)
plot(mesh_2d, main = "")
```

We will now use the `matern.operators()` function to construct a rational SPDE approximation of 
order $m=2$ for a Gaussian random field with a Matérn covariance function on
$[0,1]\times [0, 1]$. We choose $\nu=0.5$ which corresponds to exponential
covariance. We also set $\sigma=1$ and the range as $0.2$.

```{r, message=FALSE}
library(rSPDE)
sigma <- 1
range <- 0.2
nu <- 0.5
kappa <- sqrt(8 * nu) / range
op <- matern.operators(
  mesh = mesh_2d, nu = nu,
  kappa = kappa, sigma = sigma, m = 2
)
```

We are now in a position to simulate the latent field $u$:

```{r}
u <- simulate(op)
```

Let us then consider a simple Gaussian linear model
of a latent spatial field $u(\mathbf{s})$, observed at
$m$ locations, $\{\mathbf{s}_1 , \ldots , \mathbf{s}_m \}$.
For each $i = 1,\ldots,m,$ we have
$$
\begin{align} 
y_i &= u(\mathbf{s}_i)+\varepsilon_i\\
\end{align},
$$
where $\varepsilon_1,\ldots,\varepsilon_{m}$ are iid normally distributed
with mean 0 and standard deviation 0.1.

We now obtain a realization of $y$. We will use the `r inla_link()` function `inla.spde.make.A()` to construct the observation matrix.

```{r}
A <- inla.spde.make.A(
  mesh = mesh_2d,
  loc = loc_2d_mesh
)
sigma.e <- 0.1
y <- A %*% u + rnorm(n_loc) * sigma.e
```

The observed data can be seen in the following image.

```{r,fig.align = "center", echo=FALSE}
library(ggplot2)
library(gridExtra)
df <- data.frame(x1 = as.double(loc_2d_mesh[, 1]),
   x2 = as.double(loc_2d_mesh[, 2]), y = as.double(y))
p <- ggplot(df, aes(x = x1, y = x2, col = y)) +
  geom_point() +
  scale_color_gradient(low = "yellow", high = "red")
tryCatch(
  {
    print(p)
  },
  error = function(e) {
    print("Unable to build the plot")
  }
)
```

The simulated random field is shown in the following figure.

```{r, fig.show='hold', fig.align = "center",echo=FALSE}
proj <- inla.mesh.projector(mesh_2d, dims = c(100, 100))
field <- inla.mesh.project(proj, field = as.vector(u))
grd <- expand.grid(1:100, 1:100) / 100
field.df <- cbind(grd, as.vector(field))
colnames(field.df) <- c("x1", "x2", "y")
p <- ggplot(field.df, aes(x = x1, y = x2, fill = y)) +
  geom_raster() +
  scale_fill_gradient(low = "yellow", high = "red")
tryCatch(
  {
    print(p)
  },
  error = function(e) {
    print("Unable to build the plot")
  }
)
```

## Fitting the model with `R-INLA` implementation of the rational SPDE approach

We will now fit the model of the toy data set using our `r inla_link()` implementation of the
rational SPDE approach. Further details on this implementation can be found in
 [R-INLA implementation of the rational SPDE approach](rspde_inla.html).
 
We begin by creating the $A$ matrix, the index, and the
`inla.stack` object.

```{r}
Abar <- rspde.make.A(mesh = mesh_2d, loc = loc_2d_mesh)
mesh.index <- rspde.make.index(name = "field", mesh = mesh_2d)

st.dat <- inla.stack(
  data = list(y = as.vector(y)),
  A = Abar,
  effects = mesh.index
)
```

We now create the model object. We need to set
an upper bound for the smoothness parameter $\nu$. When
we increase the upper bound for $\nu$
we also increase the computational cost. For this example we set `nu_upper_bound=1`.
See the  [R-INLA implementation of the rational SPDE approach](rspde_inla.html)
for further details.

```{r}
rspde_model <- rspde.matern(
  mesh = mesh_2d,
  nu_upper_bound = 2
)
```

Finally, we create the formula and fit:

```{r message=FALSE, warning=FALSE}
f <-
  y ~ -1 + f(field, model = rspde_model)
rspde_fit <-
  rspde.inla(f,
    data = inla.stack.data(st.dat),
    family = "gaussian",
    control.predictor =
      list(A = inla.stack.A(st.dat))
  )
```

We can get the summary:
```{r}
summary(rspde_fit)
```

and the summary in the user's scale:
```{r}
result_fit <- rspde.result(rspde_fit, "field", rspde_model)
summary(result_fit)
tau <- op$tau
result_df <- data.frame(
  parameter = c("tau", "kappa", "nu"),
  true = c(tau, kappa, nu), mean = c(
    result_fit$summary.tau$mean,
    result_fit$summary.kappa$mean,
    result_fit$summary.nu$mean
  ),
  mode = c(
    result_fit$summary.tau$mode,
    result_fit$summary.kappa$mode,
    result_fit$summary.nu$mode
  )
)
print(result_df)
```


## Kringing with `R-INLA` implementation of the rational SPDE approach

Let us now obtain predictions (i.e., do kriging) of the latent field on 
a dense grid in the region.

We begin by creating the grid in which we want to do the predictions. To this end,
we can use the `rspde.mesh.projector()` function. This function has the same arguments
as the function `inla.mesh.projector()` the only difference being that the rSPDE
version also has an argument `nu` and an argument `rspde_order`. Thus, we
proceed in the same fashion as we would in `r inla_link()`'s standard SPDE implementation:


```{r create_proj_grid}
projgrid <- rspde.mesh.projector(mesh_2d,
  xlim = c(0, 1),
  ylim = c(0, 1)
)
```

This lattice contains 100 × 100 locations (the default). 

Let us plot the locations that we will do prediction:

```{r plot_prd, fig.align='center'}
coord.prd <- projgrid$lattice$loc
plot(coord.prd, type = "p", cex = 0.1)
```

Let us now calculate the predictions jointly with the estimation. To this end, first, 
we begin by linking the prediction coordinates to the mesh nodes through an $A$
 matrix

```{r A_prd}
A.prd <- projgrid$proj$A
```

We now make a stack for the prediction locations. We have no data at the prediction locations, so we set `y=
NA`. We then join this stack with the estimation stack.

```{r stk.prd}
ef.prd <- list(c(mesh.index))
st.prd <- inla.stack(
  data = list(y = NA),
  A = list(A.prd), tag = "prd",
  effects = ef.prd
)
st.all <- inla.stack(st.dat, st.prd)
```

Doing the joint estimation takes a while, and we therefore turn off the computation of certain things that we are not interested in, such as the marginals for the random effect. 
We will also use a simplified integration strategy (actually only using the posterior mode of the hyper-parameters) through the command `control.inla = list(int.strategy = "eb")`, i.e. empirical Bayes:

```{r fit_prd, message=FALSE, warning=FALSE}
rspde_fitprd <- rspde.inla(f,
  family = "Gaussian",
  data = inla.stack.data(st.all),
  control.predictor = list(
    A = inla.stack.A(st.all),
    compute = TRUE, link = 1
  ),
  control.compute = list(
    return.marginals = FALSE,
    return.marginals.predictor = FALSE
  ),
  control.inla = list(int.strategy = "eb")
)
```

We then extract the indices to the prediction nodes and then extract the mean and the standard deviation of the response:

```{r stk.mean.sd}
id.prd <- inla.stack.index(st.all, "prd")$data
m.prd <- matrix(rspde_fitprd$summary.fitted.values$mean[id.prd], 100, 100)
sd.prd <- matrix(rspde_fitprd$summary.fitted.values$sd[id.prd], 100, 100)
```

Finally, we plot the results. First the mean:

```{r plot_pred, echo=FALSE, fig.align='center'}
grd <- expand.grid(1:100, 1:100) / 100
field.pred.df <- cbind(grd, as.vector(m.prd))
colnames(field.pred.df) <- c("x1", "x2", "y")
p <- ggplot(field.pred.df, aes(x = x1, y = x2, fill = y)) +
  geom_raster() +
  scale_fill_gradient(low = "yellow", high = "red")
tryCatch(
  {
    print(p)
  },
  error = function(e) {
    print("Unable to build the plot")
  }
)
```

Then, the std. deviations:

```{r plot_pred_sd, fig.align='center', echo=FALSE}
field.pred.sd.df <- cbind(grd, as.vector(sd.prd))
colnames(field.pred.sd.df) <- c("x1", "x2", "y")
p <- ggplot(field.pred.sd.df, aes(x = x1, y = x2, fill = y)) +
  geom_raster()
tryCatch(
  {
    print(p)
  },
  error = function(e) {
    print("Unable to build the plot")
  }
)
```


## Fitting the model with `rSPDE`

We will now fit the model of the toy data set without using `r inla_link()`.
To this end we will use the rational approximation functions from 
`rSPDE` package. Further details can be found in the vignette
[Rational approximation with the rSPDE package](rspde_cov.html).

We will now use the 
function `rSPDE.matern.loglike()` to define the likelihood. This function
is object-based, in the sense that it obtains several of the quantities
it needs from the `rSPDE` model object. 

Notice that we already created a `rSPDE` model object to simulate the data.
We will, then, use the same model object. Recall that the `rSPDE` model
object we created is `op`. We also already have the $A$ matrix connecting
the observation locations to the mesh, and we simply called it `A`.

To simplify parameter estimation, we create an objective function to minimize 
which is the negative log-likelihood, parametrized using the logarithm of each 
parameter to avoid constrained optimization. 

```{r}
mlik <- function(theta, Y, A, op) {
  sigma <- exp(theta[1])
  kappa <- exp(theta[2])
  nu <- exp(theta[3])
  return(-rSPDE::rSPDE.matern.loglike(
    object = op, Y = Y,
    A = A, user_kappa = kappa, user_sigma = sigma,
    user_nu = nu, sigma.e = exp(theta[4])
  ))
}
```

We can now estimate the parameter using `optimParallel()` (one can also
use `optim()`):

```{r}
library(optimParallel)
# Preparing the parallel

# Checking if we have a limit to the number of cores
chk <- Sys.getenv("_R_CHECK_LIMIT_CORES_", "")
if (nzchar(chk) && chk == "TRUE") {
  n_cores <- 2L
} else {
  n_cores <- parallel::detectCores() - 1
}

cl <- makeCluster(n_cores)
setDefaultCluster(cl = cl)

# Fitting the model
theta0 <- c(
  get.inital.values.rSPDE(mesh = mesh_2d),
  log(0.1 * sqrt(var(as.vector(y))))
)
start_time <- Sys.time()
pars <- optimParallel(theta0, mlik, Y = y, A = A, op = op)
end_time <- Sys.time()
total_time <- end_time - start_time
results <- data.frame(
  sigma = c(sigma, exp(pars$par[1])),
  kappa = c(kappa, exp(pars$par[2])),
  nu = c(nu, exp(pars$par[3])),
  sigma.e = c(sigma.e, exp(pars$par[4])),
  row.names = c("True", "Estimate")
)
print(results)
# Total time
print(total_time)
```


## Kringing with `rSPDE`

We will now do kringing on the same dense grid
we did for the `r inla_link()`-based rational SPDE approach,
but now using the `rSPDE` functions. To this end we
will use the `predict` method on the `rSPDE` model object.

Observe that we need an $A$ matrix connecting the mesh to the 
prediction locations. 

Let us now create the $A$ matrix for the same prediction locations we used for the
previous case (using the `r inla_link()` implementation):

```{r create_proj_grid_prd2}
predgrid <- inla.mesh.projector(mesh_2d,
  xlim = c(0, 1),
  ylim = c(0, 1)
)
A.prd2 <- predgrid$proj$A
```

We will now use the `predict()` method on the `rSPDE` model object
with the argument `compute.variances` set to `TRUE` so that
we can plot the standard deviations. Let us also update the values of 
the `rSPDE` model object to the fitted ones, and also save the estimated
value of `sigma.e`.

```{r}
sigma.e.est <- exp(pars$par[4])
op.prd <- update(op,
  user_sigma = exp(pars$par[1]),
  user_kappa = exp(pars$par[2]),
  user_nu = exp(pars$par[3])
)

pred.rspde <- predict(op.prd,
  A = A, Aprd = A.prd2, Y = y,
  sigma.e = sigma.e.est,
  compute.variances = TRUE
)
```

Finally, we plot the results. First the mean:

```{r plot_pred2, fig.align='center', echo=FALSE}
field.pred2.df <- cbind(grd, as.vector(pred.rspde$mean))
colnames(field.pred2.df) <- c("x1", "x2", "y")
p <- ggplot(field.pred2.df, aes(x = x1, y = x2, fill = y)) +
  geom_raster() +
  scale_fill_gradient(low = "yellow", high = "red")
tryCatch(
  {
    print(p)
  },
  error = function(e) {
    print("Unable to build the plot")
  }
)
```

Then, the std. deviations:

```{r plot_pred_sd2, fig.align='center', echo=FALSE}
field.pred2.sd.df <- cbind(grd, as.vector(sqrt(pred.rspde$variance)))
colnames(field.pred2.sd.df) <- c("x1", "x2", "y")
p <- ggplot(field.pred2.sd.df, aes(x = x1, y = x2, fill = y)) +
  geom_raster()
tryCatch(
  {
    print(p)
  },
  error = function(e) {
    print("Unable to build the plot")
  }
)
```


# References

