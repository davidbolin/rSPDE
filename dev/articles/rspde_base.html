<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Using the rational approximation with the `rSPDE` package • rSPDE</title>
<!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/yeti/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script><meta property="og:title" content="Using the rational approximation with the `rSPDE` package">
<meta property="og:description" content="rSPDE">
<meta name="robots" content="noindex">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body data-spy="scroll" data-target="#toc">
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">rSPDE</a>
        <span class="version label label-danger" data-toggle="tooltip" data-placement="bottom" title="In-development version">0.6.2.9000</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../articles/rSPDE.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="../articles/rspde_base.html">Using the rational approximation with the `rSPDE` package</a>
    </li>
    <li>
      <a href="../articles/rspde_cov.html">Using the covariance-based rational approximation with the `rSPDE` package</a>
    </li>
    <li>
      <a href="../articles/rspde_inla.html">R-INLA implementation of the covariance-based rational approximation</a>
    </li>
  </ul>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a href="https://github.com/davidbolin/rSPDE/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      

      </header><script src="rspde_base_files/accessible-code-block-0.0.1/empty-anchor.js"></script><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1 data-toc-skip>Using the rational approximation with the <code>rSPDE</code> package</h1>
                        <h4 class="author">David Bolin</h4>
            
            <h4 class="date">2021-12-04</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/davidbolin/rSPDE/blob/master/vignettes/rspde_base.Rmd"><code>vignettes/rspde_base.Rmd</code></a></small>
      <div class="hidden name"><code>rspde_base.Rmd</code></div>

    </div>

    
    
<div id="introduction" class="section level1">
<h1 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h1>
<p>Several popular Gaussian random field models can be represented as solutions to stochastic partial differential equations (SPDEs) of the form <span class="math display">\[
L^{\beta} (\tau u) = \mathcal{W}.
\]</span></p>
<p>Here <span class="math inline">\(\mathcal{W}\)</span> is Gaussian white noise, <span class="math inline">\(L\)</span> is a second-order differential operator, the fractional power <span class="math inline">\(\beta&gt;0\)</span> determines the smoothness of <span class="math inline">\(u\)</span>, and <span class="math inline">\(\tau&gt;0\)</span> scales the variance of <span class="math inline">\(u\)</span>. The simplest example is a model on <span class="math inline">\(\mathbb{R}^d\)</span> with <span class="math inline">\(L = \kappa^2 - \Delta\)</span>, which results in a Gaussian random field <span class="math inline">\(u\)</span> with a Matérn covariance function <span class="math display">\[
C(h) = \frac{\sigma^2}{2^{\nu-1}\Gamma(\nu)}(\kappa h)^\nu K_\nu(\kappa h).
\]</span> If <span class="math inline">\(2\beta\)</span> is an integer and if the domain <span class="math inline">\(\mathcal{D}\)</span> where the model is defined is bounded, then <span class="math inline">\(u\)</span> can be approximated by a Gaussian Markov random field (GMRF) <span class="math inline">\(\boldsymbol{\mathrm{u}}\)</span> via a finite element method (FEM) for the SPDE. Specifically, the approximation can be written as <span class="math display">\[
u_h(s) = \sum_{i=1}^n u_i \varphi_i(s).
\]</span> Here <span class="math inline">\(\{\varphi_i\}\)</span> are piecewise linear basis functions defined by some triangulation of <span class="math inline">\(\mathcal{D}\)</span> and the vector of weights <span class="math inline">\(\boldsymbol{\mathrm{u}} = (u_1,\ldots,u_n)^T\)</span> is normally distributed, <span class="math inline">\(N(\boldsymbol{\mathrm{u}},\tilde{\boldsymbol{\mathrm{Q}}}^{-1})\)</span>, where <span class="math inline">\(\tilde{\boldsymbol{\mathrm{Q}}}\)</span> is sparse. See <span class="citation">(Lindgren, Rue, and Lindström 2011)</span> for further details.</p>
<p>The <code>rSPDE</code> package provides corresponding computationally efficient approximations for the case when <span class="math inline">\(\beta\)</span> is a general fractional power. The main idea is to combine the FEM approximation with a rational approximation of the fractional operator. The rational SPDE approach results in an approximation of the original SPDE which is of the form <span class="math inline">\(P_l x = P_r \mathcal{W}\)</span>, where <span class="math inline">\(P_l\)</span> and <span class="math inline">\(P_r\)</span> are non-fractional operators defined in terms of polynomials <span class="math inline">\(p_l\)</span> and <span class="math inline">\(p_r\)</span>. The order of <span class="math inline">\(p_r\)</span> is given by <span class="math inline">\(m\)</span> and the order of <span class="math inline">\(p_l\)</span> is <span class="math inline">\(m + m_{\beta}\)</span> where <span class="math inline">\(m_{\beta}\)</span> is the integer part of <span class="math inline">\(\beta\)</span> if <span class="math inline">\(\beta&gt;1\)</span> and <span class="math inline">\(m_{\beta} = 1\)</span> otherwise.</p>
<p>Combining the rational approximation of the operator with the FEM discretization yields an approximation <span class="math inline">\(u_h\)</span> of <span class="math inline">\(u\)</span> of the basis expansion form above. The difference to the non-fractional case is that the vector of stochastic weights now is <span class="math inline">\(\boldsymbol{\mathrm{u}} \sim N(\boldsymbol{\mathrm{0}},\boldsymbol{\mathrm{P}}_r\boldsymbol{\mathrm{Q}}^{-1}\boldsymbol{\mathrm{P}}_r^T)\)</span> where <span class="math inline">\(\boldsymbol{\mathrm{Q}}\)</span> and <span class="math inline">\(\boldsymbol{\mathrm{P}}_r\)</span> are sparse matrices. Alternatively, <span class="math inline">\(\boldsymbol{\mathrm{u}}\)</span> can be represented as <span class="math inline">\(\boldsymbol{\mathrm{u}} = \boldsymbol{\mathrm{P}}_r \boldsymbol{\mathrm{x}}\)</span> where <span class="math inline">\(\boldsymbol{\mathrm{x}} \sim N(\boldsymbol{\mathrm{0}},\boldsymbol{\mathrm{Q}}^{-1})\)</span>, which means that the discrete approximation is a latent GMRF. This can be used for computationally efficient inference and simulation. See <span class="citation">(Bolin and Kirchner 2020)</span> for further details.</p>
</div>
<div id="using-the-package" class="section level1">
<h1 class="hasAnchor">
<a href="#using-the-package" class="anchor"></a>Using the package</h1>
<p>The main purpose of the <code>rSPDE</code> package is to provide functions for creating the rational approximation, which means assembling the matrices <span class="math inline">\(\boldsymbol{\mathrm{Q}}\)</span> and <span class="math inline">\(\boldsymbol{\mathrm{P}}_r\)</span>. There are three main functions for computing the rational approximation. The most general function is <code>fractional.operators</code>, which works for a wide class of models with a general differential operator <span class="math inline">\(L\)</span>. For the stationary Matérn case, where <span class="math inline">\(L = \kappa^2 - \Delta\)</span>, the function <code>matern.operators</code> provides a simplified model specification. For the generalized non-stationary Matérn model, defined through the SPDE <span class="math display">\[
(\kappa(s)^2 - \Delta)^\beta (\tau(s)u(s)) = \mathcal{W},
\]</span> the function <code>spde.matern.operators</code> can be used.</p>
<p>Once the approximation has been constructed, it can be included manually in statistical models just as for the non-fractional case. The package has some built-in functions for basic use of the approximation, such as <code>simulate</code> which can be applied for simulation of the field. There are also functions for likelihood evaluation and kriging prediction for geostatistical models with Gaussian measurement noise where <span class="math inline">\(u\)</span> is included. In the following sections, we will illustrate the usage of these functions.</p>
<div id="constructing-the-approximation" class="section level2">
<h2 class="hasAnchor">
<a href="#constructing-the-approximation" class="anchor"></a>Constructing the approximation</h2>
<p>In this section, we explain how the different main functions can be used for constructing the rational approximation. The first step for constructing the rational SPDE approximation is to define the FEM mesh. For illustration purposes, the <code>rSPDE</code> package contains a simple FEM implementation for models on <span class="math inline">\(\mathbb{R}\)</span> which we will use first. We will then illustrate how spatial models can be constructed, if the FEM implementation of the <code>R-INLA</code> package is used instead.</p>
<p>Assume that we want to define a model on the interval <span class="math inline">\([0,1]\)</span>. We then start by defining a vector with mesh nodes <span class="math inline">\(s_i\)</span> where the basis functions <span class="math inline">\(\varphi_i\)</span> are centered.</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">s</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">0</span>, to <span class="op">=</span> <span class="fl">1</span>, length.out <span class="op">=</span> <span class="fl">101</span><span class="op">)</span></code></pre></div>
<p>Based on these nodes, we use the built-in function <code>rSPDE.fem1d</code> to assemble two matrices needed for creating the approximation of a basic Matérn model. These matrices are the mass matrix <span class="math inline">\(\boldsymbol{\mathrm{C}}\)</span>, with elements <span class="math inline">\(C_{ij} = \int \varphi_j(s) \varphi_i(s) ds\)</span>, and the stiffness matrix <span class="math inline">\(\boldsymbol{\mathrm{G}}\)</span>, with elements <span class="math inline">\(G_{ij} = \int \nabla\varphi_j(s) \cdot \nabla\varphi_i(s) ds\)</span>.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">fem</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rSPDE.fem1d.html">rSPDE.fem1d</a></span><span class="op">(</span><span class="va">s</span><span class="op">)</span></code></pre></div>
<p>We can now use <code>matern.operators</code> to construct a rational SPDE approximation of degree <span class="math inline">\(m=1\)</span> for a Gaussian random field with a Matérn covariance function on the interval.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">kappa</span> <span class="op">&lt;-</span> <span class="fl">20</span>
<span class="va">sigma</span> <span class="op">&lt;-</span> <span class="fl">2</span>
<span class="va">nu</span> <span class="op">&lt;-</span> <span class="fl">0.8</span>
<span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span>kappa <span class="op">=</span> <span class="va">kappa</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,
                       G <span class="op">=</span> <span class="va">fem</span><span class="op">$</span><span class="va">G</span>, C <span class="op">=</span> <span class="va">fem</span><span class="op">$</span><span class="va">C</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<p>The object <code>op</code> contains the matrices needed for evaluating the distribution of the stochastic weights <span class="math inline">\(\boldsymbol{\mathrm{u}}\)</span>. If we want to evaluate <span class="math inline">\(u_h(s)\)</span> at some locations <span class="math inline">\(s_1,\ldots, s_n\)</span>, we need to multiply the weights with the basis functions <span class="math inline">\(\varphi_i(s)\)</span> evaluated at the locations. For this, we can construct the observation matrix <span class="math inline">\(\boldsymbol{\mathrm{A}}\)</span> with elements <span class="math inline">\(A_{ij} = \varphi_j(s_i)\)</span>, linking the FEM basis functions to the locations. This matrix can be constructed using the function <code>rSPDE.A1d</code>.</p>
<p>To evaluate the accuracy of the approximation, let us compute the covariance function between the process at <span class="math inline">\(s=0.5\)</span> and all other locations in <code>s</code> and compare with the true Matérn covariance function. The covariances can be calculated as <span class="math display">\[
\boldsymbol{\mathrm{A}} \boldsymbol{\mathrm{P}}_r \boldsymbol{\mathrm{Q}}^{-1}\boldsymbol{\mathrm{P}}_r^T\boldsymbol{\mathrm{v}}.
\]</span> Here <span class="math inline">\(\boldsymbol{\mathrm{A}}\)</span> is an identity matrix since we are evaluating the approximation in the nodes of the FEM mesh and <span class="math inline">\(\boldsymbol{\mathrm{v}}\)</span> is a vector with all basis functions evaluated in <span class="math inline">\(s=0.5\)</span>.</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">v</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="fu"><a href="../reference/rSPDE.A1d.html">rSPDE.A1d</a></span><span class="op">(</span><span class="va">s</span>,<span class="fl">0.5</span><span class="op">)</span><span class="op">)</span>
<span class="va">c.approx</span> <span class="op">&lt;-</span> <span class="va">op</span><span class="op">$</span><span class="va">Pr</span> <span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html">solve</a></span><span class="op">(</span><span class="va">op</span><span class="op">$</span><span class="va">Q</span>, <span class="va">op</span><span class="op">$</span><span class="va">Pr</span> <span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span> <span class="va">v</span><span class="op">)</span>
<span class="va">c.true</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.covariance.html">matern.covariance</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">abs</a></span><span class="op">(</span><span class="va">s</span> <span class="op">-</span> <span class="fl">0.5</span><span class="op">)</span>, <span class="va">kappa</span>, <span class="va">nu</span>, <span class="va">sigma</span><span class="op">)</span> </code></pre></div>
<p>The covariance function and the error compared with the Matérn covariance are shown in the following figure. <img src="rspde_base_files/figure-html/unnamed-chunk-5-1.png" width="672" style="display: block; margin: auto;"></p>
<p>To improve the approximation we can increase the degree of the polynomials, by increasing <span class="math inline">\(m\)</span>, and/or increase the number of basis functions used for the FEM approximation. Let us, for example, compute the approximation with <span class="math inline">\(m=2\)</span> using the same mesh, as well as the approximation when we increase the number of basis functions and use <span class="math inline">\(m=1\)</span> and <span class="math inline">\(m=2\)</span>.</p>
<div class="sourceCode" id="cb5"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">op2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span>kappa <span class="op">=</span> <span class="va">kappa</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,
                       G <span class="op">=</span> <span class="va">fem</span><span class="op">$</span><span class="va">G</span>, C <span class="op">=</span> <span class="va">fem</span><span class="op">$</span><span class="va">C</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="fl">2</span><span class="op">)</span>
<span class="va">c.approx2</span> <span class="op">&lt;-</span> <span class="va">op2</span><span class="op">$</span><span class="va">Pr</span> <span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html">solve</a></span><span class="op">(</span><span class="va">op2</span><span class="op">$</span><span class="va">Q</span>, <span class="va">op2</span><span class="op">$</span><span class="va">Pr</span> <span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span> <span class="va">v</span><span class="op">)</span>

<span class="va">s2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">0</span>, to <span class="op">=</span> <span class="fl">1</span>, length.out <span class="op">=</span> <span class="fl">501</span><span class="op">)</span>
<span class="va">fem2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rSPDE.fem1d.html">rSPDE.fem1d</a></span><span class="op">(</span><span class="va">s2</span><span class="op">)</span>
<span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span>kappa <span class="op">=</span> <span class="va">kappa</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,
                       G <span class="op">=</span> <span class="va">fem2</span><span class="op">$</span><span class="va">G</span>, C <span class="op">=</span> <span class="va">fem2</span><span class="op">$</span><span class="va">C</span>, d <span class="op">=</span> <span class="fl">1</span>, m<span class="op">=</span><span class="fl">1</span><span class="op">)</span>
<span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rSPDE.A1d.html">rSPDE.A1d</a></span><span class="op">(</span><span class="va">s2</span>,<span class="va">s</span><span class="op">)</span>
<span class="va">v</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="fu"><a href="../reference/rSPDE.A1d.html">rSPDE.A1d</a></span><span class="op">(</span><span class="va">s2</span>,<span class="fl">0.5</span><span class="op">)</span><span class="op">)</span>
<span class="va">c.approx3</span> <span class="op">&lt;-</span> <span class="va">A</span><span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span><span class="va">op</span><span class="op">$</span><span class="va">Pr</span> <span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html">solve</a></span><span class="op">(</span><span class="va">op</span><span class="op">$</span><span class="va">Q</span>, <span class="va">op</span><span class="op">$</span><span class="va">Pr</span> <span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span> <span class="va">v</span><span class="op">)</span>
<span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span>kappa <span class="op">=</span> <span class="va">kappa</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,
                       G <span class="op">=</span> <span class="va">fem2</span><span class="op">$</span><span class="va">G</span>, C <span class="op">=</span> <span class="va">fem2</span><span class="op">$</span><span class="va">C</span>, d <span class="op">=</span> <span class="fl">1</span>, m<span class="op">=</span><span class="fl">2</span><span class="op">)</span>
<span class="va">c.approx4</span> <span class="op">&lt;-</span> <span class="va">A</span><span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span><span class="va">op</span><span class="op">$</span><span class="va">Pr</span> <span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html">solve</a></span><span class="op">(</span><span class="va">op</span><span class="op">$</span><span class="va">Q</span>, <span class="va">op</span><span class="op">$</span><span class="va">Pr</span> <span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span> <span class="va">v</span><span class="op">)</span></code></pre></div>
<p>The resulting errors are shown in the following figure.</p>
<p><img src="rspde_base_files/figure-html/unnamed-chunk-7-1.png" width="672" style="display: block; margin: auto;"></p>
<p>Since the error induced by the rational approximation decreases exponentially in <span class="math inline">\(m\)</span>, there is in general rarely a need for an approximation with a large value of <span class="math inline">\(m\)</span>. This is good because the number of non-zero elements in <span class="math inline">\(\boldsymbol{\mathrm{P}}_r\)</span> and <span class="math inline">\(\boldsymbol{\mathrm{Q}}\)</span> increases with <span class="math inline">\(m\)</span>, which makes the approximation more computationally costly to use. Further, the condition number of <span class="math inline">\(\boldsymbol{\mathrm{P}}_r\)</span> and <span class="math inline">\(\boldsymbol{\mathrm{Q}}\)</span> increases with <span class="math inline">\(m\)</span>, which can cause numerical problems when working with these matrices. To illustrate this, let us compute the norm of the approximation error for different <span class="math inline">\(m\)</span>.</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">errors</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">4</span><span class="op">)</span>
<span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span><span class="op">{</span>
  <span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span>kappa <span class="op">=</span> <span class="va">kappa</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,
                       G <span class="op">=</span> <span class="va">fem2</span><span class="op">$</span><span class="va">G</span>, C <span class="op">=</span> <span class="va">fem2</span><span class="op">$</span><span class="va">C</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="va">i</span><span class="op">)</span>
  <span class="va">c.app</span> <span class="op">&lt;-</span> <span class="va">A</span><span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span><span class="va">op</span><span class="op">$</span><span class="va">Pr</span> <span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/solve-methods.html">solve</a></span><span class="op">(</span><span class="va">op</span><span class="op">$</span><span class="va">Q</span>, <span class="va">op</span><span class="op">$</span><span class="va">Pr</span> <span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span> <span class="va">v</span><span class="op">)</span>
  <span class="va">errors</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/norm.html">norm</a></span><span class="op">(</span><span class="va">c.true</span><span class="op">-</span><span class="va">c.app</span><span class="op">)</span>
<span class="op">}</span>
<span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">errors</span><span class="op">)</span>
<span class="co">#&gt; [1]  1.0068624  0.1080323 52.4789665 54.6447496</span></code></pre></div>
<p>We see that the error decreases when increasing <span class="math inline">\(m\)</span> from <span class="math inline">\(1\)</span> to <span class="math inline">\(2\)</span>, but is very large for <span class="math inline">\(m=3\)</span> and <span class="math inline">\(m=4\)</span>. The reason for this is not that the approximation is bad, but that the numerical accuracy of the product <span class="math inline">\(\boldsymbol{\mathrm{P}}_r\boldsymbol{\mathrm{Q}}^{-1}\boldsymbol{\mathrm{P}}_rv\)</span> is low due to the high condition numbers of the matrices. To solve this issue, the package contains functions for performing operations such as <span class="math inline">\(\boldsymbol{\mathrm{P}}_rv\)</span> or <span class="math inline">\(\boldsymbol{\mathrm{P}}_r^{-1}v\)</span> that takes advantage of the structure of <span class="math inline">\(\boldsymbol{\mathrm{P}}_r\)</span> to avoid numerical issues. A complete list of these function can be seen by typing <code><a href="../reference/operator.operations.html">?operator.operations</a></code>. One of these functions is <code>Sigma.mult</code>, which performs the multiplication <span class="math inline">\(\boldsymbol{\mathrm{P}}_r\boldsymbol{\mathrm{Q}}^{-1}\boldsymbol{\mathrm{P}}_rv\)</span> in a more numerically stable way. Let us use this function to compute the errors of the approximations again to see that we indeed get better approximations as <span class="math inline">\(m\)</span> increases.</p>
<div class="sourceCode" id="cb7"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">errors2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html">rep</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">4</span><span class="op">)</span>
<span class="kw">for</span><span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fl">4</span><span class="op">)</span><span class="op">{</span>
  <span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/matern.operators.html">matern.operators</a></span><span class="op">(</span>kappa <span class="op">=</span> <span class="va">kappa</span>, sigma <span class="op">=</span> <span class="va">sigma</span>, nu <span class="op">=</span> <span class="va">nu</span>,
                       G <span class="op">=</span> <span class="va">fem2</span><span class="op">$</span><span class="va">G</span>, C <span class="op">=</span> <span class="va">fem2</span><span class="op">$</span><span class="va">C</span>, d <span class="op">=</span> <span class="fl">1</span>, m <span class="op">=</span> <span class="va">i</span><span class="op">)</span>
  <span class="va">c.app</span> <span class="op">&lt;-</span> <span class="va">A</span><span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span><span class="fu"><a href="../reference/operator.operations.html">Sigma.mult</a></span><span class="op">(</span><span class="va">op</span>, <span class="va">v</span><span class="op">)</span>
  <span class="va">errors2</span><span class="op">[</span><span class="va">i</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/norm.html">norm</a></span><span class="op">(</span><span class="va">c.true</span><span class="op">-</span><span class="va">c.app</span><span class="op">)</span>
<span class="op">}</span>
<span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">errors2</span><span class="op">)</span>
<span class="co">#&gt; [1] 1.00686123 0.10297336 0.02812262 0.02279198</span></code></pre></div>
</div>
</div>
<div id="a-non-stationary-model" class="section level1">
<h1 class="hasAnchor">
<a href="#a-non-stationary-model" class="anchor"></a>A non-stationary model</h1>
<p>Let us now examine a non-stationary model <span class="math inline">\((\kappa(s)^2 - \Delta)^\beta (\tau(s)u(s)) = \mathcal{W}\)</span> with <span class="math inline">\(\kappa(s) = 10(1+2s^2)\)</span> and <span class="math inline">\(\tau(s) = 0.1(1 - 0.7s^2)\)</span>. We can then use <code>spde.matern.operators</code> to create the rational approximation with <span class="math inline">\(m=1\)</span> as follows.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">s</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">0</span>, to <span class="op">=</span> <span class="fl">1</span>, length.out <span class="op">=</span> <span class="fl">501</span><span class="op">)</span>
<span class="va">fem</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rSPDE.fem1d.html">rSPDE.fem1d</a></span><span class="op">(</span><span class="va">s</span><span class="op">)</span>
<span class="va">kappa</span> <span class="op">&lt;-</span>  <span class="fl">10</span><span class="op">*</span><span class="op">(</span><span class="fl">1</span><span class="op">+</span><span class="fl">2</span><span class="op">*</span><span class="va">s</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span>
<span class="va">tau</span> <span class="op">&lt;-</span>  <span class="fl">0.1</span><span class="op">*</span><span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="fl">0.7</span><span class="op">*</span><span class="va">s</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span>
<span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/spde.matern.operators.html">spde.matern.operators</a></span><span class="op">(</span>kappa <span class="op">=</span> <span class="va">kappa</span>, tau <span class="op">=</span> <span class="va">tau</span>, nu <span class="op">=</span> <span class="va">nu</span>, 
                            G <span class="op">=</span> <span class="va">fem</span><span class="op">$</span><span class="va">G</span>, C <span class="op">=</span> <span class="va">fem</span><span class="op">$</span><span class="va">C</span>, d <span class="op">=</span> <span class="fl">1</span>, m<span class="op">=</span><span class="fl">1</span><span class="op">)</span></code></pre></div>
<p>Let us compute the covariance function <span class="math inline">\(C(s,s_i)\)</span> of the non-stationary model for the locations <span class="math inline">\(s_1=0.1, s_2 = 0.5,\)</span> and <span class="math inline">\(s_3 = 0.9\)</span>.</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">v</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/t.html">t</a></span><span class="op">(</span><span class="fu"><a href="../reference/rSPDE.A1d.html">rSPDE.A1d</a></span><span class="op">(</span><span class="va">s</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">0.1</span>,<span class="fl">0.5</span>,<span class="fl">0.9</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
<span class="va">covs</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/operator.operations.html">Sigma.mult</a></span><span class="op">(</span><span class="va">op</span>, <span class="va">v</span><span class="op">)</span></code></pre></div>
<p>The three covariances are shown in the following figure. <img src="rspde_base_files/figure-html/unnamed-chunk-12-1.png" width="672" style="display: block; margin: auto;"></p>
<p>We see that this choice of <span class="math inline">\(\kappa(s)\)</span> and <span class="math inline">\(\tau(s)\)</span> results in a model with longer range for small values of <span class="math inline">\(s\)</span> and smaller variance in the middle of the domain. We can also apply the general function <code>fractional.operators</code> to construct the approximation. This function requires that one supplies a discretization of the non-fractional operator <span class="math inline">\(L\)</span>, as well as a scaling factor <span class="math inline">\(c&gt;0\)</span> which is a lower bound for the smallest eigenvalue of <span class="math inline">\(L\)</span>. In our case we have <span class="math inline">\(L = \kappa(s)^2 - \Delta\)</span>, and the eigenvalues of this operator is bounded from below by <span class="math inline">\(c = \min_s \kappa(s)^2\)</span>. We compute this constant and the discrete operator.</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">c</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="va">kappa</span><span class="op">)</span><span class="op">^</span><span class="fl">2</span>
<span class="va">L</span> <span class="op">=</span> <span class="va">fem</span><span class="op">$</span><span class="va">G</span> <span class="op">+</span> <span class="va">fem</span><span class="op">$</span><span class="va">C</span> <span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span> <span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/Diagonal.html">Diagonal</a></span><span class="op">(</span><span class="fl">501</span>, <span class="va">kappa</span><span class="op">^</span><span class="fl">2</span><span class="op">)</span></code></pre></div>
<p>Another difference between <code>fractional.operators</code> and the previous functions for constructing the approximation, is that it requires specifying <span class="math inline">\(\beta\)</span> instead of the smoothness parameter <span class="math inline">\(\nu\)</span> for the Matérn covariance. These two parameters are related as <span class="math inline">\(2\beta = \nu + d/2\)</span>.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fractional.operators.html">fractional.operators</a></span><span class="op">(</span>L <span class="op">=</span> <span class="va">L</span>, beta <span class="op">=</span> <span class="op">(</span><span class="va">nu</span> <span class="op">+</span> <span class="fl">1</span><span class="op">/</span><span class="fl">2</span><span class="op">)</span><span class="op">/</span><span class="fl">2</span>, C <span class="op">=</span> <span class="va">fem</span><span class="op">$</span><span class="va">C</span>, 
                           scale.factor <span class="op">=</span> <span class="va">c</span>, tau <span class="op">=</span> <span class="va">tau</span>, m <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<p>Let’s make sure that we have the same approximation by comparing the previously computed covariances.</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">covs2</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/operator.operations.html">Sigma.mult</a></span><span class="op">(</span><span class="va">op</span>,<span class="va">v</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/pkg/Matrix/man/norm.html">norm</a></span><span class="op">(</span><span class="va">covs</span><span class="op">-</span><span class="va">covs2</span><span class="op">)</span>
<span class="co">#&gt; [1] 0</span></code></pre></div>
<p>Obviously, it is simpler to use <code>spde.matern.operators</code> in this case, but the advantage with <code>fractional.operators</code> is that it also can be used for other more general models such as one with <span class="math inline">\(L = \kappa(s)^2 - \nabla \cdot (\boldsymbol{\mathrm{H}}(s) \nabla)\)</span> for some matrix-valued function <span class="math inline">\(\boldsymbol{\mathrm{H}}(s)\)</span>.</p>
<div id="using-the-approximation" class="section level2">
<h2 class="hasAnchor">
<a href="#using-the-approximation" class="anchor"></a>Using the approximation</h2>
<p>For any approximation, constructed using the functions <code>fractional.operators</code>, <code>matern.operators</code>, or <code>spde.matern.operators</code>, we can simulate from the model using <code>simulate</code>.</p>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/simulate.html">simulate</a></span><span class="op">(</span><span class="va">op</span><span class="op">)</span></code></pre></div>
<p>There is also built-in support for kriging prediction. To illustrate this, we use the simulation to create some noisy observations of the process. For this, we first construct the observation matrix linking the FEM basis functions to the locations where we want to simulate. We first randomly generate some observation locations and then construct the matrix.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">n.obs</span> <span class="op">&lt;-</span> <span class="fl">20</span>
<span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span>n <span class="op">=</span> <span class="va">n.obs</span>, min <span class="op">=</span> <span class="fl">0</span>, max <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>
<span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rSPDE.A1d.html">rSPDE.A1d</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">obs.loc</span><span class="op">)</span></code></pre></div>
<p>We now generate the observations as <span class="math inline">\(Y_i = u(s_i) + \varepsilon_i\)</span>, where <span class="math inline">\(\varepsilon_i \sim N(0,\sigma_e^2)\)</span> is Gaussian measurement noise.</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">sigma.e</span> <span class="op">&lt;-</span> <span class="fl">0.3</span>
<span class="va">Y</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">as.vector</a></span><span class="op">(</span><span class="va">A</span> <span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span> <span class="va">u</span> <span class="op">+</span> <span class="va">sigma.e</span> <span class="op">*</span> <span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>Finally, we compute the kriging prediction of the process <span class="math inline">\(u\)</span> at the locations in <code>s</code> based on these observations. To specify which locations that should be predicted, the argument <code>Aprd</code> is used. This argument should be an observation matrix that links the mesh locations to the prediction locations.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">A.krig</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/rSPDE.A1d.html">rSPDE.A1d</a></span><span class="op">(</span><span class="va">s</span>, <span class="va">s</span><span class="op">)</span>
<span class="va">u.krig</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">op</span>, A <span class="op">=</span> <span class="va">A</span>, Aprd <span class="op">=</span> <span class="va">A.krig</span>, Y <span class="op">=</span> <span class="va">Y</span>, sigma.e <span class="op">=</span> <span class="va">sigma.e</span><span class="op">)</span></code></pre></div>
<p>The process simulation, the observed data, and the kriging prediction are shown in the following figure.</p>
<p><img src="rspde_base_files/figure-html/unnamed-chunk-20-1.png" width="672" style="display: block; margin: auto;"></p>
</div>
</div>
<div id="spatial-data-and-parameter-estimation" class="section level1">
<h1 class="hasAnchor">
<a href="#spatial-data-and-parameter-estimation" class="anchor"></a>Spatial data and parameter estimation</h1>
<p>The functions used in the previous examples also work for spatial models. We then need to construct a mesh over the domain of interest and then compute the matrices needed to define the operator. These tasks can be performed, for example, using the <code>R-INLA</code> package. Let us start by defining a mesh over <span class="math inline">\([0,1]\times [0, 1]\)</span> and compute the mass and stiffness matrices for that mesh.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">0</span>, to <span class="op">=</span> <span class="fl">10</span>, length.out <span class="op">=</span> <span class="fl">70</span><span class="op">)</span>
<span class="va">mesh</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/INLA/man/inla.mesh.create.html">inla.mesh.create</a></span><span class="op">(</span>lattice <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/pkg/INLA/man/inla.mesh.lattice.html">inla.mesh.lattice</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">x</span>, y <span class="op">=</span> <span class="va">x</span><span class="op">)</span>, 
                         extend <span class="op">=</span> <span class="cn">FALSE</span>, refine <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span>
<span class="va">fem</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/INLA/man/inla.fmesher.smorg.html">inla.fmesher.smorg</a></span><span class="op">(</span><span class="va">mesh</span><span class="op">$</span><span class="va">loc</span>, <span class="va">mesh</span><span class="op">$</span><span class="va">graph</span><span class="op">$</span><span class="va">tv</span>, fem <span class="op">=</span> <span class="fl">2</span>,
                         output <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span><span class="st">"c0"</span>, <span class="st">"c1"</span>, <span class="st">"g1"</span><span class="op">)</span><span class="op">)</span>
<span class="va">C</span> <span class="op">&lt;-</span> <span class="va">fem</span><span class="op">$</span><span class="va">c0</span>
<span class="va">G</span> <span class="op">&lt;-</span> <span class="va">fem</span><span class="op">$</span><span class="va">g1</span></code></pre></div>
<p>We can now use these matrices to define a rational SPDE approximation of degree <span class="math inline">\(m=1\)</span> for a Matérn model in the same was as before. We use <span class="math inline">\(\nu=0.5\)</span> so that the model has an exponential covariance function.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">kappa</span> <span class="op">&lt;-</span> <span class="fl">0.5</span>
<span class="va">tau</span> <span class="op">&lt;-</span> <span class="fl">1</span>
<span class="va">nu</span> <span class="op">&lt;-</span> <span class="fl">0.5</span>
<span class="va">op</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/spde.matern.operators.html">spde.matern.operators</a></span><span class="op">(</span>kappa <span class="op">=</span> <span class="va">kappa</span>, tau <span class="op">=</span> <span class="va">tau</span>, nu <span class="op">=</span> <span class="va">nu</span>, G <span class="op">=</span> <span class="va">G</span>, C <span class="op">=</span> <span class="va">C</span>, d <span class="op">=</span> <span class="fl">2</span>, m <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></code></pre></div>
<p>Now let us simulate some noisy data that we will use to estimate the parameters of the model. To construct the observation matrix, we use the <code>R-INLA</code> function <code>inla.spde.make.A</code>.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">u</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/simulate.html">simulate</a></span><span class="op">(</span><span class="va">op</span><span class="op">)</span>
<span class="va">n.obs</span> <span class="op">&lt;-</span> <span class="fl">4000</span>
<span class="va">obs.loc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/cbind.html">cbind</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span>n <span class="op">=</span> <span class="va">n.obs</span>, min <span class="op">=</span> <span class="fl">0</span>, max <span class="op">=</span> <span class="fl">1</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/stats/Uniform.html">runif</a></span><span class="op">(</span>n <span class="op">=</span> <span class="va">n.obs</span>, min <span class="op">=</span> <span class="fl">0</span>, max <span class="op">=</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span>
<span class="va">A</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/pkg/INLA/man/inla.spde.make.A.html">inla.spde.make.A</a></span><span class="op">(</span><span class="va">mesh</span>, loc <span class="op">=</span> <span class="va">obs.loc</span><span class="op">)</span>
<span class="va">sigma.</span><span class="op">&lt;-</span> <span class="fl">0.1</span>
<span class="va">Y</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/vector.html">as.vector</a></span><span class="op">(</span><span class="va">A</span> <span class="op"><a href="https://rdrr.io/pkg/Matrix/man/matrix-products.html">%*%</a></span> <span class="va">u</span> <span class="op">+</span> <span class="va">sigma.e</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/stats/Normal.html">rnorm</a></span><span class="op">(</span><span class="va">n.obs</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<p>The simulated random field as well as the observation locations are shown in the following figure. <img src="rspde_base_files/figure-html/unnamed-chunk-24-1.png" width="672" style="display: block; margin: auto;"></p>
<p>For each type of rational approximation of degree <span class="math inline">\(m\)</span>, there is a corresponding likelihood function that can be used for likelihood-based parameter estimation. Since we constructed the model with <code>matern.operators</code>, we can use the function <code>matern.loglike</code> to define the likelihood. To simplify parameter estimation, we create an objective function to maximize which is the negative log-likelihood, parametrized using the logarithm of each parameter to avoid constrained optimization.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">mlik</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">theta</span>, <span class="va">Y</span>, <span class="va">G</span>, <span class="va">C</span>, <span class="va">A</span><span class="op">)</span> <span class="op">{</span>
  <span class="kw"><a href="https://rdrr.io/r/base/function.html">return</a></span><span class="op">(</span><span class="op">-</span><span class="fu"><a href="../reference/spde.matern.loglike.html">spde.matern.loglike</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">theta</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">theta</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">theta</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">theta</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span>,
                              Y <span class="op">=</span> <span class="va">Y</span>, G <span class="op">=</span> <span class="va">G</span>, C <span class="op">=</span> <span class="va">C</span>, A <span class="op">=</span> <span class="va">A</span>, d <span class="op">=</span> <span class="fl">2</span>, m<span class="op">=</span><span class="fl">1</span><span class="op">)</span><span class="op">)</span>
<span class="op">}</span></code></pre></div>
<p>We can now estimate the parameter using <code>optim</code>.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">theta0</span> <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Log.html">log</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html">var</a></span><span class="op">(</span><span class="va">Y</span><span class="op">)</span><span class="op">)</span>, <span class="fl">1</span>,<span class="fl">0.1</span><span class="op">*</span><span class="fu"><a href="https://rdrr.io/r/base/MathFun.html">sqrt</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/cor.html">var</a></span><span class="op">(</span><span class="va">Y</span><span class="op">)</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
<span class="va">pars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/optim.html">optim</a></span><span class="op">(</span><span class="va">theta0</span>, <span class="va">mlik</span>, Y <span class="op">=</span> <span class="va">Y</span>, G <span class="op">=</span> <span class="va">G</span>, C <span class="op">=</span> <span class="va">C</span>, A <span class="op">=</span> <span class="va">A</span>, method <span class="op">=</span> <span class="st">"L-BFGS-B"</span><span class="op">)</span>
<span class="va">results</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/data.frame.html">data.frame</a></span><span class="op">(</span>kappa <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">kappa</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">pars</span><span class="op">$</span><span class="va">par</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>, 
                      tau <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">tau</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">pars</span><span class="op">$</span><span class="va">par</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>,
                      nu <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">nu</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">pars</span><span class="op">$</span><span class="va">par</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>,
                      sigma.e <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">sigma.e</span>, <span class="fu"><a href="https://rdrr.io/r/base/Log.html">exp</a></span><span class="op">(</span><span class="va">pars</span><span class="op">$</span><span class="va">par</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span><span class="op">)</span><span class="op">)</span>,
                      row.names <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"True"</span>, <span class="st">"Estimate"</span><span class="op">)</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/base/print.html">print</a></span><span class="op">(</span><span class="va">results</span><span class="op">)</span>
<span class="co">#&gt;              kappa      tau        nu   sigma.e</span>
<span class="co">#&gt; True     0.5000000 1.000000 0.5000000 0.3000000</span>
<span class="co">#&gt; Estimate 0.5531397 1.133612 0.4944743 0.2953928</span></code></pre></div>
</div>
<div id="references" class="section level1 unnumbered">
<h1 class="hasAnchor">
<a href="#references" class="anchor"></a>References</h1>
<div id="refs" class="references">
<div id="ref-bolin19">
<p>Bolin, David, and Kristin Kirchner. 2020. “The Rational SPDE Approach for Gaussian Random Fields with General Smoothness.” <em>Journal of Computational and Graphical Statistics</em> 29 (2): 274–85.</p>
</div>
<div id="ref-lindgren11">
<p>Lindgren, Finn, Håvard Rue, and Johan Lindström. 2011. “An Explicit Link Between Gaussian Fields and Gaussian Markov Random Fields: The Stochastic Partial Differential Equation Approach.” <em>Journal of the Royal Statistical Society. Series B. Statistical Methodology</em> 73 (4): 423–98.</p>
</div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">

        <nav id="toc" data-toggle="toc"><h2 data-toc-skip>Contents</h2>
    </nav>
</div>

</div>



      <footer><div class="copyright">
  <p>Developed by David Bolin, Alexandre Simas.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
</div>

  


  </body>
</html>
